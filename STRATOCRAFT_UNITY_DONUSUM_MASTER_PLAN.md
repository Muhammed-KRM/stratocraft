# ğŸ“˜ STRATOCRAFT: MMO - GRAND MASTER ARCHITECTURE
## Unity DÃ¶nÃ¼ÅŸÃ¼m Master PlanÄ± (Nihai SÃ¼rÃ¼m)

**Vizyon:** "Minecraft'Ä±n Ã–zgÃ¼rlÃ¼ÄŸÃ¼ + Astroneer'Ä±n Teknolojisi + Rust'Ä±n VahÅŸiliÄŸi"  
**Motor:** Unity 2022 LTS (veya Unity 6)  
**Mimari:** Server-Authoritative, GPU-Accelerated Voxel World  
**Hedef:** 1000 kiÅŸilik MMO sunucu

---

## ğŸ“‹ Ä°Ã‡Ä°NDEKÄ°LER

1. [Oyunun Felsefesi ve Vizyonu](#bÃ¶lÃ¼m-1-oyunun-felsefesi-ve-vizyonu)
2. [KullanÄ±lacak Teknolojiler](#bÃ¶lÃ¼m-2-kullanÄ±lacak-teknolojiler-tech-stack)
3. [Dosya YapÄ±sÄ±](#bÃ¶lÃ¼m-3-nihai-ve-birleÅŸtirilmiÅŸ-dosya-yapÄ±sÄ±)
4. [GeliÅŸtirme FazlarÄ±](#bÃ¶lÃ¼m-4-geliÅŸtirme-fazlarÄ±)
5. [Kritik Ä°puÃ§larÄ±](#kritik-ipuÃ§larÄ±)
6. [Java'dan Unity'ye GeÃ§iÅŸ HaritasÄ±](#bÃ¶lÃ¼m-5-javadan-unityye-geÃ§iÅŸ-haritasÄ±)

---

## ğŸ§­ BÃ–LÃœM 1: OYUNUN FELSEFESÄ° VE VÄ°ZYONU

Stratocraft, oyuncuyu elinden tutan bir oyun deÄŸildir. AcÄ±masÄ±z, sosyal ve mÃ¼hendislik odaklÄ±dÄ±r.

### Temel Prensipler

**1. Kod Kanundur (Code is Law)**
- Adminler oyuna karÄ±ÅŸmaz
- Oyuncular arasÄ± hukuk, "Kontrat" sistemiyle saÄŸlanÄ±r
- SÃ¶zleÅŸmeyi bozanÄ± oyun motoru otomatik cezalandÄ±rÄ±r

**2. SÃ¶zlÃ¼ Komut Yok**
- `/claim`, `/home`, `/tpa` gibi komutlar yoktur
- IÅŸÄ±nlanmak mÄ± istiyorsun? IÅŸÄ±nlanma BataryasÄ± kuracaksÄ±n
- BÃ¶lge mi almak istiyorsun? Kristal dikeceksin
- Her ÅŸey fizikseldir

**3. YÃ¼ksek Risk, YÃ¼ksek Ã–dÃ¼l**
- Merkez gÃ¼venlidir ama kaynak azdÄ±r
- Uzaklara gittikÃ§e (Deep Zone) Titanlar ve Felaketler baÅŸlar
- En deÄŸerli madenler (KÄ±zÄ±l Elmas, Titanyum) Deep Zone'da

**4. MÃ¼hendislik BÃ¼yÃ¼sÃ¼**
- BÃ¼yÃ¼ yapmak iÃ§in asa sallamazsÄ±n
- Yere taÅŸlarÄ± geometrik bir dÃ¼zenle (RitÃ¼el) dizersin
- DoÄŸru dizersen bÃ¼yÃ¼ Ã§alÄ±ÅŸÄ±r

---

## ğŸ› ï¸ BÃ–LÃœM 2: KULLANILACAK TEKNOLOJÄ°LER (TECH STACK)

Bu parÃ§alarÄ± indireceÄŸiz. Bunlar projenin motorunu oluÅŸturacak.

### Temel Teknolojiler

| BileÅŸen | SeÃ§ilen Teknoloji | Kaynak | GÃ¶revi | Faz |
|---------|-------------------|--------|--------|-----|
| **Zemin Motoru** | Scrawk / Marching Cubes on GPU | GitHub | Ä°ÅŸlemciyi (CPU) yormadan ekran kartÄ±nda sonsuz dÃ¼nya oluÅŸturur (GPU fallback sistemi ile) | FAZ 1-2 |
| **AÄŸ Motoru** | FishNet | Asset Store | 1000 oyuncu senkronizasyonu iÃ§in en optimize Ã§Ã¶zÃ¼m | FAZ 1-8 |
| **Biyom MatematiÄŸi** | FastNoiseLite | GitHub | Scrawk'Ä±n iÃ§ine entegre edilerek Ã‡Ã¶l, DaÄŸ, Nehir ayrÄ±mlarÄ±nÄ± hesaplar | FAZ 3 |
| **VeritabanÄ±** | SQLite (sqlite-net-pcl) | NuGet | Oyuncu verisi, klan sÄ±nÄ±rlarÄ± ve kontratlar iÃ§in | FAZ 1-8 |
| **Yapay Zeka** | Panda BT (Behavior Tree) | GitHub | TitanlarÄ±n karmaÅŸÄ±k savaÅŸ fazlarÄ±nÄ± yÃ¶netmek iÃ§in | FAZ 5 |
| **GÃ¶rsel** | Kenney Assets | Kenney.nl | DÃ¼ÅŸÃ¼k poligonlu (Low-Poly) modeller | TÃ¼m Fazlar |

### Faz BazlÄ± Teknolojiler

#### FAZ 1-2: AltyapÄ± ve DÃ¼nya OluÅŸumu
- **Unity Compute Shaders** - GPU'da density hesaplama (TerrainDensity.compute)
- **Unity Job System + Burst Compiler** - CPU fallback ve paralel iÅŸlemler (CalculateDensityJob, BuildMeshJob)
- **Unity SystemInfo API** - GPU desteÄŸi kontrolÃ¼ ve fallback sistemi (SystemInfo.supportsComputeShaders)
- **Unity Coroutines** - Asenkron chunk yÃ¼kleme (UI donmasÄ±nÄ± Ã¶nleme)
- **Unity Mesh API** - Chunk mesh oluÅŸturma (MeshBuilder.cs)
- **Unity ScriptableObject** - Data-driven item/mob tanÄ±mlarÄ±
- **Unity NavMesh** - Mob pathfinding (FAZ 5'te kullanÄ±lacak)

#### FAZ 3: DoÄŸa, Su ve Biyomlar
- **GPU Instancing** - Binlerce aÄŸaÃ§/kaya render (VegetationSpawner.cs - eski sistem)
- **Object Pooling** - Performans optimizasyonu (aÄŸaÃ§/kaya yeniden kullanÄ±mÄ±)
- **Shader Graph** - Okyanus materyali (OceanPlane.cs)
- **FastNoiseLite** - Biyom ve maÄŸara gÃ¼rÃ¼ltÃ¼sÃ¼ (TerrainDensity.compute)
- **Unity Job System + Burst Compiler** - Paralel aÄŸaÃ§ generation (VoxelTreeGenerator.cs - GenerateTreeJob), paralel maden spawn (OreSpawner.cs - SpawnOresInChunkJob)
- **Unity Coroutines** - AÅŸamalÄ± aÄŸaÃ§ bÃ¼yÃ¼me (TreeGrowthSystem.cs - 5 bÃ¼yÃ¼me aÅŸamasÄ±)
- **Unity Mesh API** - Variant mesh generation (VariantMeshGenerator.cs - 740 variant algoritma tabanlÄ± mesh generation)
- **Unity JSON** - Blueprint kaydetme/yÃ¼kleme (BlueprintSystem.cs - yapÄ± kayÄ±t sistemi)
- **Unity Compute Shaders** - Voxel su simÃ¼lasyonu (WaterSim.compute - Minecraft benzeri matematiksel su mekaniÄŸi)

#### FAZ 4: Oyun Mekanikleri
- **ScriptableObject** - ItemDefinition, RitualRecipe, BiomeDefinition, ChiselDefinition
- **Flood-Fill Algorithm** - Territory hesaplama (TerritoryManager.cs)
- **Unity Job System + Burst Compiler** - Territory flood-fill optimizasyonu (FloodFillJob)
- **SQLite** - Contract ve territory verileri (DatabaseManager.cs)
- **Unity Raycast API** - Blok seÃ§imi (ChiselRaycast.cs - Voxel terrain uyumlu, raycast cache optimizasyonu)
- **Unity Mesh API** - Variant mesh generation (BlockCuttingSystem.cs - VariantMeshGenerator entegrasyonu)
- **Unity JSON** - Åekil kayÄ±t sistemi (ShapeApplicationSystem.cs - 9 slot persistent storage)
- **Unity LineRenderer** - Kesim Ã§izgileri ve grid Ã§izgileri (BlockSelectionVisualizer.cs - gÃ¶rsel geri bildirim)
- **Unity Particle System** - Kesim efektleri (toz bulutlarÄ±, talaÅŸ parÃ§acÄ±klarÄ±, kÄ±vÄ±lcÄ±m - malzeme bazlÄ± efektler)
- **Unity Coroutines** - Chunk regeneration batch sistemi (BlockCuttingSystem.cs - performans optimizasyonu)
- **C# Dictionary/Queue** - Cache ve pooling sistemleri (Raycast cache, Mesh pooling, Variant cache - performans optimizasyonlarÄ±)

#### FAZ 5: Yapay Zeka, SavaÅŸ ve Felaketler
- **Unity NavMesh** - Dinamik NavMesh baking (ChunkNavMeshBaker.cs)
- **State Machine** - Normal mob AI (MobAI.cs)
- **Panda BT** - Boss AI (BossAI.cs)
- **Unity Physics** - Collision detection (Combat system)
- **Unity Animator** - Mob animasyonlarÄ±

#### FAZ 6: ArayÃ¼z (UI), EtkileÅŸim ve Cila
- **TextMeshPro** - UI metinleri (Unity yerleÅŸik)
- **DoTween** - UI animasyonlarÄ± (Asset Store - Free)
- **Unity Canvas** - UI sistemi (Unity yerleÅŸik)
- **Unity Audio** - Ses sistemi (Unity yerleÅŸik)
- **Unity Raycast** - EtkileÅŸim kontrolÃ¼ (InteractionController.cs)

#### FAZ 7: GÃ¼Ã§ Sistemi, Binekler ve SavaÅŸ Makineleri
- **FishNet Ownership** - Binek kontrolÃ¼ (RideableMob.cs)
- **SQLite** - GÃ¼Ã§ profili kayÄ±tlarÄ± (PlayerPowerProfile, ClanPowerProfile)
- **Unity Coroutines** - Async iÅŸlemler (Power calculation)
- **Cache System** - Custom performans optimizasyonu

#### FAZ 8: Eksik Sistemler, Admin KomutlarÄ± ve Config YÃ¶netimi
- **Unity NavMesh** - Kervan pathfinding (CaravanManager.cs)
- **Unity Physics** - OverlapSphere, Projectile physics (ResearchManager, SiegeWeaponManager)
- **DoTween** - Supply Drop animasyonu (SupplyDropManager.cs)
- **Unity Editor API** - Config editor (ConfigEditor.cs)
- **Unity Input System** - Tab completion (AdminTabCompleter.cs)
- **Unity LineRenderer** - Hayalet tarif Ã§izgileri (GhostRecipeManager.cs)
- **Unity Event System** - GÃ¶rev ilerleme takibi (MissionManager.cs)

---

## ğŸ“‚ BÃ–LÃœM 3: NÄ°HAÄ° VE BÄ°RLEÅTÄ°RÄ°LMÄ°Å DOSYA YAPISI

Eski "Ã–zellik OdaklÄ±" yapÄ± ile yeni "Motor OdaklÄ±" yapÄ±nÄ±n birleÅŸimi.

```
Assets/
â”œâ”€â”€ _Stratocraft/
â”‚   â”œâ”€â”€ _Bootstrap/                     (BAÅLANGIÃ‡)
â”‚   â”‚   â”œâ”€â”€ GameEntry.cs                (Oyunun Start tuÅŸu)
â”‚   â”‚   â”œâ”€â”€ NetworkBootstrap.cs         (FishNet ayarlarÄ±)
â”‚   â”‚   â””â”€â”€ ServerConfig.json           (Port, Seed, MaxPlayers)
â”‚   â”‚
â”‚   â”œâ”€â”€ Data/                           (VERÄ°TABANI - ScriptableObjects)
â”‚   â”‚   â”œâ”€â”€ Biomes/                     (Biyom TanÄ±mlarÄ±)
â”‚   â”‚   â”‚   â”œâ”€â”€ DesertDef.asset         (SÄ±caklÄ±k: YÃ¼ksek, Nem: DÃ¼ÅŸÃ¼k)
â”‚   â”‚   â”‚   â”œâ”€â”€ ForestDef.asset
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Items/                      (EÅŸya TanÄ±mlarÄ±)
â”‚   â”‚   â”‚   â”œâ”€â”€ Resources/              (Titanium.asset)
â”‚   â”‚   â”‚   â”œâ”€â”€ Traps/                  (LandMine.asset)
â”‚   â”‚   â”‚   â”œâ”€â”€ Structures/             (ClanCrystal.asset)
â”‚   â”‚   â”‚   â””â”€â”€ Tools/                  (Aletler)
â”‚   â”‚   â”‚       â””â”€â”€ Chisels/            (ChiselDefinition.asset - Odun/TaÅŸ/Metal Kesici)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Recipes/                    (Tarifler)
â”‚   â”‚   â”‚   â”œâ”€â”€ Rituals/                (Batarya kurulum ÅŸemalarÄ±)
â”‚   â”‚   â”‚   â”œâ”€â”€ Crafting/               (CraftingRecipe.cs - ADIM 1.6)
â”‚   â”‚   â”‚   â”œâ”€â”€ Cooking/                 (CookingRecipe.cs - ADIM 1.14)
â”‚   â”‚   â”‚   â””â”€â”€ Smelting/               (SmeltingRecipe.cs - ADIM 1.24)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ NPCs/                       (NPC TanÄ±mlarÄ± - ADIM 1.10)
â”‚   â”‚   â”‚   â””â”€â”€ NPCDefinition.cs
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Mounts/                     (Binek TanÄ±mlarÄ± - ADIM 1.11)
â”‚   â”‚   â”‚   â”œâ”€â”€ SaddleDefinition.cs
â”‚   â”‚   â”‚   â””â”€â”€ MountArmorDefinition.cs
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Bosses/                     (Boss TanÄ±mlarÄ± - ADIM 1.12)
â”‚   â”‚   â”‚   â”œâ”€â”€ BossArenaDefinition.cs
â”‚   â”‚   â”‚   â””â”€â”€ BossLootTableDefinition.cs
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Mobs/                       (Mob TanÄ±mlarÄ± - ADIM 1.13)
â”‚   â”‚   â”‚   â”œâ”€â”€ MobClassDefinition.cs
â”‚   â”‚   â”‚   â””â”€â”€ MobArmorDefinition.cs
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Food/                       (Yemek TanÄ±mlarÄ± - ADIM 1.14)
â”‚   â”‚   â”‚   â”œâ”€â”€ FoodDefinition.cs
â”‚   â”‚   â”‚   â””â”€â”€ CookingRecipe.cs
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ StatusEffects/              (Durum Efekt TanÄ±mlarÄ± - ADIM 1.15)
â”‚   â”‚   â”‚   â”œâ”€â”€ StatusEffectDefinition.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ DiseaseDefinition.cs
â”‚   â”‚   â”‚   â””â”€â”€ CureItemDefinition.cs
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Dungeons/                   (Zindan TanÄ±mlarÄ± - ADIM 1.17)
â”‚   â”‚   â”‚   â””â”€â”€ DungeonDefinition.cs
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Spells/                     (BÃ¼yÃ¼ TanÄ±mlarÄ± - ADIM 1.18)
â”‚   â”‚   â”‚   â””â”€â”€ SpellDefinition.cs
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Tech/                       (Teknoloji TanÄ±mlarÄ± - ADIM 1.19)
â”‚   â”‚   â”‚   â””â”€â”€ TechNodeDefinition.cs
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Vehicles/                   (AraÃ§ TanÄ±mlarÄ± - ADIM 1.20)
â”‚   â”‚   â”‚   â””â”€â”€ VehicleDefinition.cs
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Pets/                       (Pet TanÄ±mlarÄ± - ADIM 1.21)
â”‚   â”‚   â”‚   â””â”€â”€ PetDefinition.cs
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Crops/                      (Bitki TanÄ±mlarÄ± - ADIM 1.22)
â”‚   â”‚   â”‚   â””â”€â”€ CropDefinition.cs
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Fish/                       (BalÄ±k TanÄ±mlarÄ± - ADIM 1.23)
â”‚   â”‚   â”‚   â””â”€â”€ FishDefinition.cs
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Chests/                     (SandÄ±k TanÄ±mlarÄ± - ADIM 1.25)
â”‚   â”‚   â”‚   â””â”€â”€ ChestDefinition.cs
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Furniture/                  (Mobilya TanÄ±mlarÄ± - ADIM 1.8)
â”‚   â”‚   â”‚   â””â”€â”€ FurnitureDefinition.cs
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Enchantments/               (BÃ¼yÃ¼ TanÄ±mlarÄ± - ADIM 1.9)
â”‚   â”‚   â”‚   â””â”€â”€ EnchantmentDefinition.cs
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Mobs/                       (CanlÄ± Verileri)
â”‚   â”‚   â”‚   â”œâ”€â”€ Stats/                  (TitanHP.asset)
â”‚   â”‚   â”‚   â””â”€â”€ LootTables/             (Drop oranlarÄ±)
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ Economy/                    (Ekonomi)
â”‚   â”‚       â”œâ”€â”€ Contracts/              (Åablon kontratlar)
â”‚   â”‚       â””â”€â”€ ShopList.asset
â”‚   â”‚
â”‚   â”œâ”€â”€ Engine/                         (MOTOR KODLARI - Scrawk & GPU)
â”‚   â”‚   â”œâ”€â”€ ComputeShaders/             (HLSL KodlarÄ± - Ekran KartÄ±)
â”‚   â”‚   â”‚   â”œâ”€â”€ TerrainDensity.compute  (Zemin ÅŸekli & Madenler)
â”‚   â”‚   â”‚   â”œâ”€â”€ WaterSim.compute        (Su akÄ±ÅŸ fiziÄŸi)
â”‚   â”‚   â”‚   â”œâ”€â”€ NoiseLib.compute        (FastNoiseLite kÃ¼tÃ¼phanesi)
â”‚   â”‚   â”‚   â”œâ”€â”€ DualContouring.compute  (Dual Contouring algoritmasÄ±)
â”‚   â”‚   â”‚   â””â”€â”€ TriplanarTexture.compute (Triplanar texturing)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Shaders/                     (Fragment/Vertex Shader'lar)
â”‚   â”‚   â”‚   â””â”€â”€ TerrainShader.shader    (Terrain shader - Triplanar texturing)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Core/                       (C# YÃ¶neticileri)
â”‚   â”‚   â”‚   â”œâ”€â”€ ChunkManager.cs         (Sonsuz dÃ¼nya sistemi - YÃ¼ksek performanslÄ±)
â”‚   â”‚   â”‚   â”œâ”€â”€ VoxelGrid.cs            (Veri tutucu)
â”‚   â”‚   â”‚   â”œâ”€â”€ MeshBuilder.cs          (Åekil Ã§izici)
â”‚   â”‚   â”‚   â”œâ”€â”€ TerrainMaterialManager.cs (Terrain materyalleri yÃ¶neticisi)
â”‚   â”‚   â”‚   â”œâ”€â”€ TerrainPoint.cs         (Terrain noktasÄ± veri yapÄ±sÄ±)
â”‚   â”‚   â”‚   â””â”€â”€ GameTimeManager.cs      (GÃ¼n/gece dÃ¶ngÃ¼sÃ¼)
â”‚   â”‚
â”‚   â”œâ”€â”€ Scripts/                        (OYUN MANTIÄI - Gameplay)
â”‚   â”‚   â”œâ”€â”€ Core/                       (Managerlar)
â”‚   â”‚   â”‚   â”œâ”€â”€ ServiceLocator.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ DatabaseManager.cs      (SQLite)
â”‚   â”‚   â”‚   â””â”€â”€ Definitions/            (ItemDefinition.cs vb.)
â”‚   â”‚   â”‚       â”œâ”€â”€ ItemDefinition.cs   (isChisel, chiselDefinition, chiselLevel eklendi)
â”‚   â”‚   â”‚       â”œâ”€â”€ IEquippable.cs      (Alet interface'i)
â”‚   â”‚   â”‚       â””â”€â”€ CutMode.cs          (Kesim modu enum'larÄ±)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Systems/                    (MEKANÄ°KLER)
â”‚   â”‚   â”‚   â”œâ”€â”€ Mining/                 (NetworkMining.cs)
â”‚   â”‚   â”‚   â”œâ”€â”€ Rituals/                (RitualManager.cs)
â”‚   â”‚   â”‚   â”œâ”€â”€ Clans/                  (TerritoryManager.cs)
â”‚   â”‚   â”‚   â”œâ”€â”€ Combat/                 (Damage, Traps)
â”‚   â”‚   â”‚   â”œâ”€â”€ Economy/                (ContractManager.cs)
â”‚   â”‚   â”‚   â”œâ”€â”€ Building/               (Ä°nÅŸa Sistemi)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ChiselTool.cs       (Blok ÅŸekillendirme aleti)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ChiselRaycast.cs    (Voxel terrain raycast)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ BlockSelectionVisualizer.cs (SeÃ§im gÃ¶rselleÅŸtirme)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ BlockCuttingSystem.cs (Kesim mekaniÄŸi)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ShapeApplicationSystem.cs (Åekil kayÄ±t/uygulama)
â”‚   â”‚   â”‚   â”œâ”€â”€ Crafting/               (Crafting Sistemi - ADIM 1.6)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ CraftingTable.cs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ CraftingManager.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ Inventory/              (Envanter Sistemi - ADIM 1.7)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ InventorySlot.cs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ PlayerInventory.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ Furniture/              (Furniture Sistemi - ADIM 1.8)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ FurniturePlacer.cs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ FurnitureInteraction.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ Tools/                  (Ä°ÅŸlevsel Item'ler - ADIM 1.9)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ToolDurability.cs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RepairStation.cs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ UpgradeStation.cs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ EnchantmentSystem.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ NPCs/                   (NPC Sistemi - ADIM 1.10)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ NPCAI.cs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ VillagerTrading.cs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ DialogueSystem.cs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ VillageGenerator.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ Mounts/                 (GeliÅŸmiÅŸ Binek Sistemi - ADIM 1.11)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ MountInventory.cs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ MountArmor.cs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ MountAbilities.cs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ MountLeveling.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ Bosses/                 (GeliÅŸmiÅŸ Boss Sistemi - ADIM 1.12)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ DragonAI.cs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ BossArena.cs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ BossLootTable.cs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ BossPhaseSystem.cs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ BossSummoning.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ Mobs/                   (Ã–zel CanlÄ± Tipleri - ADIM 1.13)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ MobAbilitySystem.cs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ MobArmorSystem.cs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ MobLeveling.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ Food/                   (Yemek ve AÃ§lÄ±k Sistemi - ADIM 1.14)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ HungerSystem.cs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ CookingStation.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ StatusEffects/          (HastalÄ±k ve Durum Sistemi - ADIM 1.15)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ StatusEffectManager.cs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ DiseaseSystem.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ Weather/               (Zaman ve Hava Sistemi - ADIM 1.16)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ WeatherSystem.cs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ SeasonSystem.cs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ TemperatureSystem.cs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ WeatherEffects.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ Dungeons/               (Zindan ve MaÄŸara Sistemi - ADIM 1.17)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ DungeonGenerator.cs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ DungeonEntrance.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ Magic/                 (Magic ve BÃ¼yÃ¼ Sistemi - ADIM 1.18)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ManaSystem.cs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ SpellCasting.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ Tech/                  (Teknoloji AÄŸacÄ± - ADIM 1.19)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ TechTreeManager.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ Vehicles/              (AraÃ§ ve UlaÅŸÄ±m Sistemi - ADIM 1.20)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ VehicleController.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ Pets/                  (Pet ve Ev HayvanÄ± Sistemi - ADIM 1.21)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ PetSystem.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ Farming/               (TarÄ±m ve Ã‡iftÃ§ilik Sistemi - ADIM 1.22)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ FarmingSystem.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ Fishing/               (BalÄ±kÃ§Ä±lÄ±k Sistemi - ADIM 1.23)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ FishingSystem.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ Smelting/              (Madencilik ve Eritme Sistemi - ADIM 1.24)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ SmeltingSystem.cs
â”‚   â”‚   â”‚   â””â”€â”€ Storage/               (Depolama ve SandÄ±k Sistemi - ADIM 1.25)
â”‚   â”‚   â”‚       â””â”€â”€ ChestInventory.cs
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ AI/                         (YAPAY ZEKA)
â”‚   â”‚   â”‚   â”œâ”€â”€ Core/                   (Panda BT entegrasyonu)
â”‚   â”‚   â”‚   â””â”€â”€ Bosses/                 (TitanController.cs)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Network/                    (FishNet Player)
â”‚   â”‚   â”‚   â”œâ”€â”€ PlayerController.cs
â”‚   â”‚   â”‚   â””â”€â”€ SyncWorld.cs            (Seed senkronizasyonu)
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ UI/                         (ARAYÃœZ)
â”‚   â”‚
â”‚   â””â”€â”€ Art/                            (GÃ–RSEL)
â”‚       â”œâ”€â”€ _External/                  (Scrawk, FishNet, Kenney)
â”‚       â”œâ”€â”€ Models/                     (Ã–zel Modeller)
â”‚       â”œâ”€â”€ Materials/                  (Zemin ve Su materyalleri)
â”‚       â”‚   â”œâ”€â”€ Terrain/                (Terrain materyalleri)
â”‚       â”‚   â”‚   â”œâ”€â”€ Grass.mat           (Ã‡imen)
â”‚       â”‚   â”‚   â”œâ”€â”€ Dirt.mat            (Toprak)
â”‚       â”‚   â”‚   â”œâ”€â”€ Stone.mat           (TaÅŸ)
â”‚       â”‚   â”‚   â”œâ”€â”€ Sand.mat            (Kum)
â”‚       â”‚   â”‚   â””â”€â”€ Snow.mat            (Kar)
â”‚       â”‚   â””â”€â”€ Triplanar/              (Triplanar texture'lar)
â”‚       â””â”€â”€ Textures/                    (Terrain texture'larÄ±)
```

---

## ğŸš€ BÃ–LÃœM 4: GELÄ°ÅTÄ°RME FAZLARI

---

# ğŸ“˜ FAZ 1 & 2: ALTYAPI KURULUMU VE DÃœNYA OLUÅUMU

**AmaÃ§:** 1000 kiÅŸinin baÄŸlanabileceÄŸi bir aÄŸ altyapÄ±sÄ± kurmak ve GPU Ã¼zerinde Ã§alÄ±ÅŸan, kazÄ±labilir, sonsuz bir dÃ¼nya yaratmak.

**SÃ¼re Tahmini:** 2-3 hafta  
**Zorluk:** â­â­â­â­â­ (En zor faz - GPU ve Network altyapÄ±sÄ±)

---

## ğŸ› ï¸ ADIM 1: GEREKLÄ° ARAÃ‡LARIN KURULUMU

AÅŸaÄŸÄ±daki paketleri indir ve projene import et.

### 1.1 FishNet (Networking)

**Link:** [Unity Asset Store - FishNet](https://assetstore.unity.com/packages/tools/network/fish-net-networking-evolved-207815)

**Kurulum:**
1. Unity Asset Store'dan satÄ±n al veya Ã¼cretsiz versiyonunu indir
2. Unity'de `Assets` â†’ `Import Package` â†’ `Custom Package` â†’ FishNet.unitypackage
3. Import edilen dosyalar `Assets/FishNet/` altÄ±na yerleÅŸir
4. **Ã–NEMLÄ°:** FishNet'i `_Stratocraft/Art/_External/FishNet/` altÄ±na taÅŸÄ± (organizasyon iÃ§in)

**AmaÃ§:** Sunucu-Ä°stemci baÄŸlantÄ±sÄ±, 1000 oyuncu senkronizasyonu

---

### 1.2 Scrawk / Marching Cubes on GPU

**Link:** [GitHub - Scrawk/Marching-Cubes-On-The-GPU](https://github.com/Scrawk/Marching-Cubes-On-The-GPU)

**Kurulum:**
1. GitHub'dan "Code â†’ Download ZIP" yap
2. ZIP'i aÃ§ ve ÅŸu klasÃ¶rleri bul:
   - `Scripts/` klasÃ¶rÃ¼ â†’ `_Stratocraft/Engine/Core/` altÄ±na kopyala
   - `Shaders/` klasÃ¶rÃ¼ â†’ `_Stratocraft/Engine/ComputeShaders/` altÄ±na kopyala
3. `Demo/` klasÃ¶rÃ¼nÃ¼ silebilirsin (test iÃ§in gerekli deÄŸil)

**Ã–nemli Dosyalar:**
- `MarchingCubesGPU.cs` â†’ Chunk oluÅŸturma scripti
- `TerrainDensity.compute` â†’ GPU shader (modifiye edilecek)
- `MeshBuilder.cs` â†’ Mesh oluÅŸturma

**AmaÃ§:** GPU Ã¼zerinde voxel dÃ¼nya oluÅŸturma (CPU'yu yormadan)

---

### 1.3 FastNoiseLite (Matematik)

**Link:** [GitHub - FastNoiseLite (C#)](https://github.com/Auburn/FastNoiseLite)

**Kurulum:**
1. GitHub'dan C# versiyonunu indir
2. `FastNoiseLite.cs` dosyasÄ±nÄ± `_Stratocraft/Engine/Core/` altÄ±na kopyala
3. HLSL versiyonu iÃ§in: `FastNoiseLite.compute` dosyasÄ±nÄ± `_Stratocraft/Engine/ComputeShaders/Includes/` altÄ±na kopyala

**AmaÃ§:** BiyomlarÄ± oluÅŸturmak iÃ§in geliÅŸmiÅŸ gÃ¼rÃ¼ltÃ¼ algoritmalarÄ± (Ã‡Ã¶l, DaÄŸ, Nehir)

---

### 1.4 SQLite (VeritabanÄ±)

**Kurulum:**
1. Unity Package Manager â†’ `+` â†’ `Add package from git URL`
2. URL: `https://github.com/praeclarum/sqlite-net.git`
3. Alternatif: NuGet'ten `.dll` indirip `Plugins/` altÄ±na koy

**AmaÃ§:** Oyuncu verisi, klan sÄ±nÄ±rlarÄ± ve kontratlar iÃ§in kalÄ±cÄ± veri saklama

---

### 1.5 Unity Input System

**Kurulum:**
1. Unity Package Manager â†’ `Window` â†’ `Package Manager`
2. `Unity Registry` seÃ§
3. `Input System` paketini bul ve `Install` tÄ±kla
4. Eski Input Manager'Ä± devre dÄ±ÅŸÄ± bÄ±rak (sorulduÄŸunda)

**AmaÃ§:** Modern input sistemi (klavye, fare, gamepad)

---

## ğŸ’» ADIM 2: Ã‡EKÄ°RDEK KODLAR (CORE)

### 2.1 ServiceLocator.cs

**Dosya:** `_Stratocraft/Scripts/Core/ServiceLocator.cs`

**AmaÃ§:** TÃ¼m sistemlerin birbirine ulaÅŸmasÄ±nÄ± saÄŸlayan merkezi yÃ¶netici (Singleton pattern)

**Kod:**

```csharp
using UnityEngine;
using System;
using System.Collections.Generic;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Service Locator Pattern - TÃ¼m sistemlerin merkezi eriÅŸim noktasÄ±
/// Thread-safe ve performanslÄ± eriÅŸim iÃ§in Dictionary kullanÄ±r
/// </summary>
public class ServiceLocator : MonoBehaviour {
    public static ServiceLocator Instance { get; private set; }
    
    // âœ… OPTÄ°MÄ°ZE: Dictionary kullan (O(1) lookup)
    private Dictionary<Type, object> _services = new Dictionary<Type, object>();
    
    // âœ… OPTÄ°MÄ°ZE: Thread-safety iÃ§in lock (multi-threaded iÅŸlemler iÃ§in)
    private readonly object _lock = new object();

    void Awake() {
        // âœ… Singleton pattern - Sadece bir instance olmalÄ±
        if (Instance != null) { 
            Destroy(gameObject); 
            return; 
        }
        
        Instance = this;
        DontDestroyOnLoad(gameObject); // Sahne deÄŸiÅŸimlerinde korunur
        Debug.Log("[System] Stratocraft Motoru BaÅŸlatÄ±lÄ±yor...");
    }

    /// <summary>
    /// Servis kaydet (Ã¶rnek: Register<DatabaseManager>(dbManager))
    /// </summary>
    public void Register<T>(T service) where T : class {
        if (service == null) {
            Debug.LogError($"[ServiceLocator] Null servis kaydedilemez: {typeof(T).Name}");
            return;
        }
        
        lock (_lock) {
            var type = typeof(T);
            if (_services.ContainsKey(type)) {
                Debug.LogWarning($"[ServiceLocator] Servis zaten kayÄ±tlÄ±: {type.Name}, Ã¼zerine yazÄ±lÄ±yor...");
                _services[type] = service;
            } else {
                _services.Add(type, service);
            }
        }
    }

    /// <summary>
    /// Servis al (Ã¶rnek: var db = Get<DatabaseManager>())
    /// </summary>
    public T Get<T>() where T : class {
        var type = typeof(T);
        
        lock (_lock) {
            if (_services.TryGetValue(type, out var service)) {
                return service as T;
            }
        }
        
        Debug.LogError($"[ServiceLocator] Servis bulunamadÄ±: {type.Name}");
        return default;
    }

    /// <summary>
    /// Servis var mÄ± kontrol et
    /// </summary>
    public bool Has<T>() where T : class {
        lock (_lock) {
            return _services.ContainsKey(typeof(T));
        }
    }

    /// <summary>
    /// TÃ¼m servisleri temizle (oyun kapanÄ±rken)
    /// </summary>
    public void Clear() {
        lock (_lock) {
            _services.Clear();
        }
    }
}
```

**KullanÄ±m Ã–rneÄŸi:**
```csharp
// Servis kaydet
ServiceLocator.Instance.Register<DatabaseManager>(databaseManager);

// Servis al
var db = ServiceLocator.Instance.Get<DatabaseManager>();
```

---

### 2.2 GameEntry.cs

**Dosya:** `_Stratocraft/_Bootstrap/GameEntry.cs`

**AmaÃ§:** Oyunun baÅŸlangÄ±Ã§ noktasÄ±, tÃ¼m sistemlerin baÅŸlatÄ±lmasÄ±

**Kod:**

```csharp
using UnityEngine;
using FishNet.Object;
using FishNet.Managing;

/// <summary>
/// âœ… Oyunun ana giriÅŸ noktasÄ± - TÃ¼m sistemler buradan baÅŸlatÄ±lÄ±r
/// </summary>
public class GameEntry : MonoBehaviour {
    [Header("Referanslar")]
    public NetworkManager networkManager;
    public GameObject playerPrefab;
    
    [Header("Ayarlar")]
    public int worldSeed = 12345; // VarsayÄ±lan seed (ServerConfig.json'dan okunacak)
    public int maxPlayers = 1000;
    
    private ChunkManager _chunkManager;
    private DatabaseManager _databaseManager;
    
    void Start() {
        Debug.Log("[GameEntry] Stratocraft baÅŸlatÄ±lÄ±yor...");
        
        // âœ… ServiceLocator'Ä± baÅŸlat
        if (ServiceLocator.Instance == null) {
            GameObject locatorObj = new GameObject("ServiceLocator");
            locatorObj.AddComponent<ServiceLocator>();
        }
        
        // âœ… VeritabanÄ± baÅŸlat (async - performans iÃ§in)
        InitializeDatabase();
        
        // âœ… AÄŸ baÅŸlat
        InitializeNetwork();
        
        // âœ… DÃ¼nya baÅŸlat (aÄŸ hazÄ±r olduktan sonra)
        InitializeWorld();
    }
    
    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: VeritabanÄ± baÅŸlatma (async - UI donmasÄ±nÄ± Ã¶nler)
    /// </summary>
    async void InitializeDatabase() {
        _databaseManager = new DatabaseManager();
        await _databaseManager.InitializeAsync();
        
        ServiceLocator.Instance.Register<DatabaseManager>(_databaseManager);
        Debug.Log("[GameEntry] VeritabanÄ± hazÄ±r");
    }
    
    /// <summary>
    /// AÄŸ baÅŸlat (FishNet)
    /// </summary>
    void InitializeNetwork() {
        if (networkManager == null) {
            Debug.LogError("[GameEntry] NetworkManager bulunamadÄ±!");
            return;
        }
        
        // FishNet otomatik baÅŸlatÄ±lÄ±r (NetworkManager component'i var)
        Debug.Log("[GameEntry] AÄŸ sistemi hazÄ±r");
    }
    
    /// <summary>
    /// DÃ¼nya baÅŸlat (ChunkManager)
    /// </summary>
    void InitializeWorld() {
        _chunkManager = FindObjectOfType<ChunkManager>();
        if (_chunkManager == null) {
            Debug.LogError("[GameEntry] ChunkManager bulunamadÄ±!");
            return;
        }
        
        // Seed'i ChunkManager'a gÃ¶nder (SyncWorld.cs'den gelecek)
        // Åimdilik varsayÄ±lan seed kullan
        _chunkManager.InitializeWorld(worldSeed, null); // Player transform sonra eklenecek
        
        ServiceLocator.Instance.Register<ChunkManager>(_chunkManager);
        Debug.Log("[GameEntry] DÃ¼nya sistemi hazÄ±r");
    }
    
    void OnDestroy() {
        // âœ… Temizlik
        if (_databaseManager != null) {
            _databaseManager.Close();
        }
        
        ServiceLocator.Instance?.Clear();
    }
}
```

---

### 2.3 NetworkBootstrap.cs

**Dosya:** `_Stratocraft/_Bootstrap/NetworkBootstrap.cs`

**AmaÃ§:** FishNet aÄŸ ayarlarÄ±nÄ± yapÄ±landÄ±rma

**Kod:**

```csharp
using UnityEngine;
using FishNet.Managing;
using FishNet.Managing.Server;
using FishNet.Managing.Client;

/// <summary>
/// âœ… FishNet aÄŸ baÅŸlatÄ±cÄ± - Sunucu/Client ayarlarÄ±
/// </summary>
public class NetworkBootstrap : MonoBehaviour {
    [Header("Ayarlar")]
    public ushort port = 7770;
    public int maxPlayers = 1000;
    public bool startAsServer = true; // Editor'de test iÃ§in
    
    private NetworkManager _networkManager;
    
    void Start() {
        _networkManager = FindObjectOfType<NetworkManager>();
        if (_networkManager == null) {
            Debug.LogError("[NetworkBootstrap] NetworkManager bulunamadÄ±!");
            return;
        }
        
        // âœ… AyarlarÄ± uygula
        ConfigureNetwork();
        
        // âœ… Otomatik baÅŸlat (isteÄŸe baÄŸlÄ±)
        if (startAsServer && Application.isEditor) {
            StartServer();
        }
    }
    
    void ConfigureNetwork() {
        // Sunucu ayarlarÄ±
        if (_networkManager.ServerManager != null) {
            _networkManager.ServerManager.OnServerConnectionState += OnServerConnectionState;
        }
        
        // Client ayarlarÄ±
        if (_networkManager.ClientManager != null) {
            _networkManager.ClientManager.OnClientConnectionState += OnClientConnectionState;
        }
        
        Debug.Log($"[NetworkBootstrap] AÄŸ yapÄ±landÄ±rÄ±ldÄ± - Port: {port}, Max Players: {maxPlayers}");
    }
    
    /// <summary>
    /// Sunucu baÅŸlat
    /// </summary>
    public void StartServer() {
        if (_networkManager == null) return;
        
        _networkManager.ServerManager.StartConnection();
        Debug.Log("[NetworkBootstrap] Sunucu baÅŸlatÄ±ldÄ±");
    }
    
    /// <summary>
    /// Client baÄŸlan
    /// </summary>
    public void StartClient(string address = "localhost") {
        if (_networkManager == null) return;
        
        _networkManager.ClientManager.StartConnection(address, port);
        Debug.Log($"[NetworkBootstrap] Client baÄŸlanÄ±yor: {address}:{port}");
    }
    
    void OnServerConnectionState(ServerConnectionStateArgs args) {
        if (args.ConnectionState == LocalConnectionState.Started) {
            Debug.Log("[NetworkBootstrap] Sunucu baÅŸarÄ±yla baÅŸlatÄ±ldÄ±");
        }
    }
    
    void OnClientConnectionState(ClientConnectionStateArgs args) {
        if (args.ConnectionState == LocalConnectionState.Started) {
            Debug.Log("[NetworkBootstrap] Client baÅŸarÄ±yla baÄŸlandÄ±");
        }
    }
}
```

---

### 2.4 DatabaseManager.cs

**Dosya:** `_Stratocraft/Scripts/Core/DatabaseManager.cs`

**AmaÃ§:** SQLite veritabanÄ± yÃ¶netimi (async, thread-safe, cache desteÄŸi)

**Kod:**

```csharp
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SQLite;
using System.IO;
using System.Threading.Tasks;
using UnityEngine;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: SQLite veritabanÄ± yÃ¶neticisi
/// - Async operations (UI donmasÄ±nÄ± Ã¶nler)
/// - Thread-safe (multi-threaded iÅŸlemler iÃ§in)
/// - Connection pooling (performans)
/// - Cache sistemi (sÄ±k kullanÄ±lan sorgular)
/// </summary>
public class DatabaseManager {
    private string _databasePath;
    private SQLiteConnection _connection;
    private bool _isInitialized = false;
    
    // âœ… OPTÄ°MÄ°ZE: Connection string cache
    private string _connectionString;
    
    // âœ… OPTÄ°MÄ°ZE: Query cache (sÄ±k kullanÄ±lan sorgular iÃ§in)
    private Dictionary<string, object> _queryCache = new Dictionary<string, object>();
    private float _cacheExpiryTime = 5f; // 5 saniye cache sÃ¼resi
    private Dictionary<string, float> _cacheTimestamps = new Dictionary<string, float>();
    
    /// <summary>
    /// âœ… VeritabanÄ±nÄ± baÅŸlat (async)
    /// </summary>
    public async Task InitializeAsync() {
        if (_isInitialized) return;
        
        // âœ… VeritabanÄ± dosya yolu
        _databasePath = Path.Combine(Application.persistentDataPath, "stratocraft.db");
        _connectionString = $"Data Source={_databasePath};Version=3;";
        
        // âœ… Async olarak veritabanÄ± oluÅŸtur
        await Task.Run(() => {
            try {
                // âœ… VeritabanÄ± dosyasÄ± yoksa oluÅŸtur
                if (!File.Exists(_databasePath)) {
                    SQLiteConnection.CreateFile(_databasePath);
                    Debug.Log($"[DatabaseManager] VeritabanÄ± oluÅŸturuldu: {_databasePath}");
                }
                
                // âœ… BaÄŸlantÄ± aÃ§
                _connection = new SQLiteConnection(_connectionString);
                _connection.Open();
                
                // âœ… TablolarÄ± oluÅŸtur
                CreateTables();
                
                _isInitialized = true;
                Debug.Log("[DatabaseManager] VeritabanÄ± baÅŸlatÄ±ldÄ±");
            } catch (Exception e) {
                Debug.LogError($"[DatabaseManager] BaÅŸlatma hatasÄ±: {e.Message}");
                throw;
            }
        });
    }
    
    /// <summary>
    /// âœ… TablolarÄ± oluÅŸtur
    /// </summary>
    private void CreateTables() {
        using (var cmd = _connection.CreateCommand()) {
            // âœ… Oyuncu tablosu
            cmd.CommandText = @"
                CREATE TABLE IF NOT EXISTS players (
                    id TEXT PRIMARY KEY,
                    name TEXT NOT NULL,
                    gold INTEGER DEFAULT 0,
                    created_at INTEGER NOT NULL,
                    last_login INTEGER
                )";
            cmd.ExecuteNonQuery();
            
            // âœ… Klan tablosu
            cmd.CommandText = @"
                CREATE TABLE IF NOT EXISTS clans (
                    id TEXT PRIMARY KEY,
                    name TEXT NOT NULL,
                    leader_id TEXT NOT NULL,
                    created_at INTEGER NOT NULL,
                    level INTEGER DEFAULT 1
                )";
            cmd.ExecuteNonQuery();
            
            // âœ… BÃ¶lge tablosu
            cmd.CommandText = @"
                CREATE TABLE IF NOT EXISTS territories (
                    id TEXT PRIMARY KEY,
                    clan_id TEXT NOT NULL,
                    center_x REAL NOT NULL,
                    center_y REAL NOT NULL,
                    center_z REAL NOT NULL,
                    radius REAL NOT NULL,
                    created_at INTEGER NOT NULL,
                    FOREIGN KEY (clan_id) REFERENCES clans(id)
                )";
            cmd.ExecuteNonQuery();
            
            // âœ… Kontrat tablosu
            cmd.CommandText = @"
                CREATE TABLE IF NOT EXISTS contracts (
                    id TEXT PRIMARY KEY,
                    employer_id TEXT NOT NULL,
                    target_id TEXT,
                    type TEXT NOT NULL,
                    reward_gold INTEGER DEFAULT 0,
                    penalty_gold INTEGER DEFAULT 0,
                    is_completed INTEGER DEFAULT 0,
                    created_at INTEGER NOT NULL,
                    deadline INTEGER,
                    completed_at INTEGER,
                    FOREIGN KEY (employer_id) REFERENCES players(id),
                    FOREIGN KEY (target_id) REFERENCES players(id)
                )";
            cmd.ExecuteNonQuery();
            
            // âœ… Ä°ttifak tablosu (FAZ 8)
            cmd.CommandText = @"
                CREATE TABLE IF NOT EXISTS alliances (
                    id TEXT PRIMARY KEY,
                    clan1_id TEXT NOT NULL,
                    clan2_id TEXT NOT NULL,
                    created_at INTEGER NOT NULL,
                    FOREIGN KEY (clan1_id) REFERENCES clans(id),
                    FOREIGN KEY (clan2_id) REFERENCES clans(id)
                )";
            cmd.ExecuteNonQuery();
            
            // âœ… Kervan tablosu (FAZ 8)
            cmd.CommandText = @"
                CREATE TABLE IF NOT EXISTS caravans (
                    id TEXT PRIMARY KEY,
                    player_id TEXT NOT NULL,
                    start_x REAL NOT NULL,
                    start_y REAL NOT NULL,
                    start_z REAL NOT NULL,
                    end_x REAL NOT NULL,
                    end_y REAL NOT NULL,
                    end_z REAL NOT NULL,
                    total_value REAL NOT NULL,
                    status TEXT NOT NULL,
                    created_at INTEGER NOT NULL,
                    arrived_at INTEGER,
                    FOREIGN KEY (player_id) REFERENCES players(id)
                )";
            cmd.ExecuteNonQuery();
            
            // âœ… AraÅŸtÄ±rma tablosu (FAZ 8)
            cmd.CommandText = @"
                CREATE TABLE IF NOT EXISTS researches (
                    id TEXT PRIMARY KEY,
                    player_id TEXT NOT NULL,
                    recipe_id TEXT NOT NULL,
                    research_location_x REAL,
                    research_location_y REAL,
                    research_location_z REAL,
                    is_completed INTEGER DEFAULT 0,
                    completed_at INTEGER,
                    created_at INTEGER NOT NULL,
                    FOREIGN KEY (player_id) REFERENCES players(id)
                )";
            cmd.ExecuteNonQuery();
            
            // âœ… Ãœreme tablosu (FAZ 8)
            cmd.CommandText = @"
                CREATE TABLE IF NOT EXISTS breedings (
                    id TEXT PRIMARY KEY,
                    player_id TEXT NOT NULL,
                    female_mob_id TEXT NOT NULL,
                    male_mob_id TEXT NOT NULL,
                    breeding_core_x REAL NOT NULL,
                    breeding_core_y REAL NOT NULL,
                    breeding_core_z REAL NOT NULL,
                    status TEXT NOT NULL,
                    created_at INTEGER NOT NULL,
                    completed_at INTEGER,
                    FOREIGN KEY (player_id) REFERENCES players(id)
                )";
            cmd.ExecuteNonQuery();
            
            // âœ… Market tablosu (FAZ 8)
            cmd.CommandText = @"
                CREATE TABLE IF NOT EXISTS shops (
                    id TEXT PRIMARY KEY,
                    owner_id TEXT NOT NULL,
                    shop_name TEXT NOT NULL,
                    location_x REAL NOT NULL,
                    location_y REAL NOT NULL,
                    location_z REAL NOT NULL,
                    is_protected INTEGER DEFAULT 0,
                    created_at INTEGER NOT NULL,
                    FOREIGN KEY (owner_id) REFERENCES players(id)
                )";
            cmd.ExecuteNonQuery();
            
            // âœ… Market item tablosu (FAZ 8)
            cmd.CommandText = @"
                CREATE TABLE IF NOT EXISTS shop_items (
                    id TEXT PRIMARY KEY,
                    shop_id TEXT NOT NULL,
                    item_id TEXT NOT NULL,
                    quantity INTEGER NOT NULL,
                    price_item_id TEXT NOT NULL,
                    price_quantity INTEGER NOT NULL,
                    stock INTEGER NOT NULL,
                    FOREIGN KEY (shop_id) REFERENCES shops(id)
                )";
            cmd.ExecuteNonQuery();
            
            // âœ… GÃ¶rev tablosu (FAZ 8)
            cmd.CommandText = @"
                CREATE TABLE IF NOT EXISTS missions (
                    id TEXT PRIMARY KEY,
                    player_id TEXT NOT NULL,
                    mission_type TEXT NOT NULL,
                    difficulty TEXT NOT NULL,
                    target_amount INTEGER NOT NULL,
                    progress INTEGER DEFAULT 0,
                    reward_item_id TEXT,
                    reward_gold INTEGER DEFAULT 0,
                    status TEXT NOT NULL,
                    created_at INTEGER NOT NULL,
                    deadline INTEGER,
                    completed_at INTEGER,
                    FOREIGN KEY (player_id) REFERENCES players(id)
                )";
            cmd.ExecuteNonQuery();
            
            // âœ… Supply Drop tablosu (FAZ 8)
            cmd.CommandText = @"
                CREATE TABLE IF NOT EXISTS supply_drops (
                    id TEXT PRIMARY KEY,
                    location_x REAL NOT NULL,
                    location_y REAL NOT NULL,
                    location_z REAL NOT NULL,
                    claimed_by TEXT,
                    claimed_at INTEGER,
                    created_at INTEGER NOT NULL,
                    FOREIGN KEY (claimed_by) REFERENCES players(id)
                )";
            cmd.ExecuteNonQuery();
            
            Debug.Log("[DatabaseManager] Tablolar oluÅŸturuldu");
        }
    }
    
    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: BaÄŸlantÄ± al (connection pooling)
    /// </summary>
    private SQLiteConnection GetConnection() {
        if (_connection == null || _connection.State != ConnectionState.Open) {
            _connection = new SQLiteConnection(_connectionString);
            _connection.Open();
        }
        return _connection;
    }
    
    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: Cache'den sorgu kontrolÃ¼
    /// </summary>
    private bool TryGetFromCache<T>(string query, out T result) {
        if (_queryCache.TryGetValue(query, out object cached)) {
            if (_cacheTimestamps.TryGetValue(query, out float timestamp)) {
                if (Time.time - timestamp < _cacheExpiryTime) {
                    result = (T)cached;
                    return true;
                } else {
                    // âœ… Cache sÃ¼resi dolmuÅŸ, temizle
                    _queryCache.Remove(query);
                    _cacheTimestamps.Remove(query);
                }
            }
        }
        result = default(T);
        return false;
    }
    
    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: Cache'e ekle
    /// </summary>
    private void AddToCache(string query, object result) {
        _queryCache[query] = result;
        _cacheTimestamps[query] = Time.time;
    }
    
    /// <summary>
    /// âœ… Generic sorgu Ã§alÄ±ÅŸtÄ±r (async)
    /// </summary>
    public async Task<int> ExecuteNonQueryAsync(string query, Dictionary<string, object> parameters = null) {
        return await Task.Run(() => {
            try {
                using (var connection = GetConnection()) {
                    using (var cmd = connection.CreateCommand()) {
                        cmd.CommandText = query;
                        
                        // âœ… Parametreleri ekle
                        if (parameters != null) {
                            foreach (var param in parameters) {
                                cmd.Parameters.AddWithValue(param.Key, param.Value ?? DBNull.Value);
                            }
                        }
                        
                        return cmd.ExecuteNonQuery();
                    }
                }
            } catch (Exception e) {
                Debug.LogError($"[DatabaseManager] Sorgu hatasÄ±: {e.Message}\nQuery: {query}");
                throw;
            }
        });
    }
    
    /// <summary>
    /// âœ… Generic sorgu Ã§alÄ±ÅŸtÄ±r ve sonuÃ§ dÃ¶ndÃ¼r (async)
    /// </summary>
    public async Task<List<Dictionary<string, object>>> ExecuteQueryAsync(string query, Dictionary<string, object> parameters = null) {
        // âœ… Cache kontrolÃ¼
        if (TryGetFromCache(query, out List<Dictionary<string, object>> cachedResult)) {
            return cachedResult;
        }
        
        return await Task.Run(() => {
            try {
                List<Dictionary<string, object>> results = new List<Dictionary<string, object>>();
                
                using (var connection = GetConnection()) {
                    using (var cmd = connection.CreateCommand()) {
                        cmd.CommandText = query;
                        
                        // âœ… Parametreleri ekle
                        if (parameters != null) {
                            foreach (var param in parameters) {
                                cmd.Parameters.AddWithValue(param.Key, param.Value ?? DBNull.Value);
                            }
                        }
                        
                        using (var reader = cmd.ExecuteReader()) {
                            while (reader.Read()) {
                                Dictionary<string, object> row = new Dictionary<string, object>();
                                
                                for (int i = 0; i < reader.FieldCount; i++) {
                                    string columnName = reader.GetName(i);
                                    object value = reader.IsDBNull(i) ? null : reader.GetValue(i);
                                    row[columnName] = value;
                                }
                                
                                results.Add(row);
                            }
                        }
                    }
                }
                
                // âœ… Cache'e ekle
                AddToCache(query, results);
                
                return results;
            } catch (Exception e) {
                Debug.LogError($"[DatabaseManager] Sorgu hatasÄ±: {e.Message}\nQuery: {query}");
                throw;
            }
        });
    }
    
    /// <summary>
    /// âœ… VeritabanÄ±nÄ± kapat
    /// </summary>
    public void Close() {
        if (_connection != null) {
            _connection.Close();
            _connection.Dispose();
            _connection = null;
        }
        
        _isInitialized = false;
        _queryCache.Clear();
        _cacheTimestamps.Clear();
        
        Debug.Log("[DatabaseManager] VeritabanÄ± kapatÄ±ldÄ±");
    }
    
    /// <summary>
    /// âœ… Cache'i temizle
    /// </summary>
    public void ClearCache() {
        _queryCache.Clear();
        _cacheTimestamps.Clear();
    }
    
    // ========== FAZ 8: EKSÄ°K SÄ°STEMLER Ä°Ã‡Ä°N DATABASE METODLARI ==========
    
    /// <summary>
    /// âœ… Kervan kaydet (FAZ 8)
    /// </summary>
    public async Task InsertCaravanAsync(string caravanId, string playerId, Vector3 startPos, Vector3 endPos, float totalValue) {
        string query = @"
            INSERT INTO caravans (id, player_id, start_x, start_y, start_z, end_x, end_y, end_z, total_value, status, created_at)
            VALUES (@id, @playerId, @startX, @startY, @startZ, @endX, @endY, @endZ, @totalValue, @status, @createdAt)";
        
        var parameters = new Dictionary<string, object> {
            { "@id", caravanId },
            { "@playerId", playerId },
            { "@startX", startPos.x },
            { "@startY", startPos.y },
            { "@startZ", startPos.z },
            { "@endX", endPos.x },
            { "@endY", endPos.y },
            { "@endZ", endPos.z },
            { "@totalValue", totalValue },
            { "@status", "ACTIVE" },
            { "@createdAt", (long)(System.DateTime.UtcNow - new System.DateTime(1970, 1, 1)).TotalSeconds) }
        };
        
        await ExecuteNonQueryAsync(query, parameters);
    }
    
    /// <summary>
    /// âœ… Kervan durumunu gÃ¼ncelle (FAZ 8)
    /// </summary>
    public async Task UpdateCaravanStatusAsync(string caravanId, string status) {
        string query = @"
            UPDATE caravans 
            SET status = @status, arrived_at = @arrivedAt 
            WHERE id = @id";
        
        var parameters = new Dictionary<string, object> {
            { "@id", caravanId },
            { "@status", status },
            { "@arrivedAt", status == "ARRIVED" ? (long)(System.DateTime.UtcNow - new System.DateTime(1970, 1, 1)).TotalSeconds : (object)DBNull.Value }
        };
        
        await ExecuteNonQueryAsync(query, parameters);
    }
    
    /// <summary>
    /// âœ… AraÅŸtÄ±rma kaydet (FAZ 8)
    /// </summary>
    public async Task InsertResearchAsync(string researchId, string playerId, string recipeId, Vector3? location = null) {
        string query = @"
            INSERT INTO researches (id, player_id, recipe_id, research_location_x, research_location_y, research_location_z, is_completed, created_at)
            VALUES (@id, @playerId, @recipeId, @locX, @locY, @locZ, 0, @createdAt)";
        
        var parameters = new Dictionary<string, object> {
            { "@id", researchId },
            { "@playerId", playerId },
            { "@recipeId", recipeId },
            { "@locX", location.HasValue ? (object)location.Value.x : DBNull.Value },
            { "@locY", location.HasValue ? (object)location.Value.y : DBNull.Value },
            { "@locZ", location.HasValue ? (object)location.Value.z : DBNull.Value },
            { "@createdAt", (long)(System.DateTime.UtcNow - new System.DateTime(1970, 1, 1)).TotalSeconds) }
        };
        
        await ExecuteNonQueryAsync(query, parameters);
    }
    
    /// <summary>
    /// âœ… Oyuncunun araÅŸtÄ±rdÄ±ÄŸÄ± tarifleri al (FAZ 8)
    /// </summary>
    public async Task<List<string>> GetPlayerResearchesAsync(string playerId) {
        string query = "SELECT recipe_id FROM researches WHERE player_id = @playerId AND is_completed = 1";
        var parameters = new Dictionary<string, object> { { "@playerId", playerId } };
        
        var results = await ExecuteQueryAsync(query, parameters);
        return results.Select(r => r["recipe_id"].ToString()).ToList();
    }
    
    /// <summary>
    /// âœ… Ãœreme kaydet (FAZ 8)
    /// </summary>
    public async Task InsertBreedingAsync(string breedingId, string playerId, string femaleMobId, string maleMobId, Vector3 corePosition) {
        string query = @"
            INSERT INTO breedings (id, player_id, female_mob_id, male_mob_id, breeding_core_x, breeding_core_y, breeding_core_z, status, created_at)
            VALUES (@id, @playerId, @femaleMobId, @maleMobId, @coreX, @coreY, @coreZ, @status, @createdAt)";
        
        var parameters = new Dictionary<string, object> {
            { "@id", breedingId },
            { "@playerId", playerId },
            { "@femaleMobId", femaleMobId },
            { "@maleMobId", maleMobId },
            { "@coreX", corePosition.x },
            { "@coreY", corePosition.y },
            { "@coreZ", corePosition.z },
            { "@status", "IN_PROGRESS" },
            { "@createdAt", (long)(System.DateTime.UtcNow - new System.DateTime(1970, 1, 1)).TotalSeconds) }
        };
        
        await ExecuteNonQueryAsync(query, parameters);
    }
    
    /// <summary>
    /// âœ… Ãœreme durumunu gÃ¼ncelle (FAZ 8)
    /// </summary>
    public async Task UpdateBreedingStatusAsync(string breedingId, string status) {
        string query = @"
            UPDATE breedings 
            SET status = @status, completed_at = @completedAt 
            WHERE id = @id";
        
        var parameters = new Dictionary<string, object> {
            { "@id", breedingId },
            { "@status", status },
            { "@completedAt", status == "COMPLETED" ? (long)(System.DateTime.UtcNow - new System.DateTime(1970, 1, 1)).TotalSeconds : (object)DBNull.Value }
        };
        
        await ExecuteNonQueryAsync(query, parameters);
    }
    
    /// <summary>
    /// âœ… Market kaydet (FAZ 8)
    /// </summary>
    public async Task InsertShopAsync(string shopId, string ownerId, string shopName, Vector3 location, bool isProtected) {
        string query = @"
            INSERT INTO shops (id, owner_id, shop_name, location_x, location_y, location_z, is_protected, created_at)
            VALUES (@id, @ownerId, @shopName, @locX, @locY, @locZ, @isProtected, @createdAt)";
        
        var parameters = new Dictionary<string, object> {
            { "@id", shopId },
            { "@ownerId", ownerId },
            { "@shopName", shopName },
            { "@locX", location.x },
            { "@locY", location.y },
            { "@locZ", location.z },
            { "@isProtected", isProtected ? 1 : 0 },
            { "@createdAt", (long)(System.DateTime.UtcNow - new System.DateTime(1970, 1, 1)).TotalSeconds) }
        };
        
        await ExecuteNonQueryAsync(query, parameters);
    }
    
    /// <summary>
    /// âœ… Market item ekle (FAZ 8)
    /// </summary>
    public async Task InsertShopItemAsync(string itemId, string shopId, string itemIdDef, int quantity, string priceItemId, int priceQuantity, int stock) {
        string query = @"
            INSERT INTO shop_items (id, shop_id, item_id, quantity, price_item_id, price_quantity, stock)
            VALUES (@id, @shopId, @itemId, @quantity, @priceItemId, @priceQuantity, @stock)";
        
        var parameters = new Dictionary<string, object> {
            { "@id", itemId },
            { "@shopId", shopId },
            { "@itemId", itemIdDef },
            { "@quantity", quantity },
            { "@priceItemId", priceItemId },
            { "@priceQuantity", priceQuantity },
            { "@stock", stock }
        };
        
        await ExecuteNonQueryAsync(query, parameters);
    }
    
    /// <summary>
    /// âœ… Market item stok gÃ¼ncelle (FAZ 8)
    /// </summary>
    public async Task UpdateShopItemStockAsync(string itemId, int newStock) {
        string query = "UPDATE shop_items SET stock = @stock WHERE id = @id";
        var parameters = new Dictionary<string, object> {
            { "@id", itemId },
            { "@stock", newStock }
        };
        
        await ExecuteNonQueryAsync(query, parameters);
    }
    
    /// <summary>
    /// âœ… GÃ¶rev kaydet (FAZ 8)
    /// </summary>
    public async Task InsertMissionAsync(string missionId, string playerId, string missionType, string difficulty, int targetAmount, string rewardItemId, int rewardGold, long deadline) {
        string query = @"
            INSERT INTO missions (id, player_id, mission_type, difficulty, target_amount, progress, reward_item_id, reward_gold, status, created_at, deadline)
            VALUES (@id, @playerId, @missionType, @difficulty, @targetAmount, 0, @rewardItemId, @rewardGold, @status, @createdAt, @deadline)";
        
        var parameters = new Dictionary<string, object> {
            { "@id", missionId },
            { "@playerId", playerId },
            { "@missionType", missionType },
            { "@difficulty", difficulty },
            { "@targetAmount", targetAmount },
            { "@rewardItemId", rewardItemId ?? (object)DBNull.Value },
            { "@rewardGold", rewardGold },
            { "@status", "ACTIVE" },
            { "@createdAt", (long)(System.DateTime.UtcNow - new System.DateTime(1970, 1, 1)).TotalSeconds) },
            { "@deadline", deadline }
        };
        
        await ExecuteNonQueryAsync(query, parameters);
    }
    
    /// <summary>
    /// âœ… GÃ¶rev ilerleme gÃ¼ncelle (FAZ 8)
    /// </summary>
    public async Task UpdateMissionProgressAsync(string missionId, int progress) {
        string query = @"
            UPDATE missions 
            SET progress = @progress, status = CASE WHEN progress >= target_amount THEN 'COMPLETED' ELSE status END, 
                completed_at = CASE WHEN progress >= target_amount THEN @completedAt ELSE completed_at END
            WHERE id = @id";
        
        var parameters = new Dictionary<string, object> {
            { "@id", missionId },
            { "@progress", progress },
            { "@completedAt", (long)(System.DateTime.UtcNow - new System.DateTime(1970, 1, 1)).TotalSeconds) }
        };
        
        await ExecuteNonQueryAsync(query, parameters);
    }
    
    /// <summary>
    /// âœ… Oyuncunun aktif gÃ¶revlerini al (FAZ 8)
    /// </summary>
    public async Task<List<Dictionary<string, object>>> GetPlayerActiveMissionsAsync(string playerId) {
        string query = "SELECT * FROM missions WHERE player_id = @playerId AND status = 'ACTIVE'";
        var parameters = new Dictionary<string, object> { { "@playerId", playerId } };
        
        return await ExecuteQueryAsync(query, parameters);
    }
    
    /// <summary>
    /// âœ… Supply Drop kaydet (FAZ 8)
    /// </summary>
    public async Task InsertSupplyDropAsync(string dropId, Vector3 location) {
        string query = @"
            INSERT INTO supply_drops (id, location_x, location_y, location_z, created_at)
            VALUES (@id, @locX, @locY, @locZ, @createdAt)";
        
        var parameters = new Dictionary<string, object> {
            { "@id", dropId },
            { "@locX", location.x },
            { "@locY", location.y },
            { "@locZ", location.z },
            { "@createdAt", (long)(System.DateTime.UtcNow - new System.DateTime(1970, 1, 1)).TotalSeconds) }
        };
        
        await ExecuteNonQueryAsync(query, parameters);
    }
    
    /// <summary>
    /// âœ… Supply Drop claim et (FAZ 8)
    /// </summary>
    public async Task ClaimSupplyDropAsync(string dropId, string playerId) {
        string query = @"
            UPDATE supply_drops 
            SET claimed_by = @playerId, claimed_at = @claimedAt 
            WHERE id = @id AND claimed_by IS NULL";
        
        var parameters = new Dictionary<string, object> {
            { "@id", dropId },
            { "@playerId", playerId },
            { "@claimedAt", (long)(System.DateTime.UtcNow - new System.DateTime(1970, 1, 1)).TotalSeconds) }
        };
        
        await ExecuteNonQueryAsync(query, parameters);
    }
    
    /// <summary>
    /// âœ… Oyuncuya altÄ±n ekle (genel metod)
    /// </summary>
    public async Task AddGoldAsync(string playerId, int amount) {
        string query = "UPDATE players SET gold = gold + @amount WHERE id = @playerId";
        var parameters = new Dictionary<string, object> {
            { "@playerId", playerId },
            { "@amount", amount }
        };
        
        await ExecuteNonQueryAsync(query, parameters);
    }
}
```

**KullanÄ±m Ã–rneÄŸi:**
```csharp
// VeritabanÄ± baÅŸlat
var db = new DatabaseManager();
await db.InitializeAsync();

// Sorgu Ã§alÄ±ÅŸtÄ±r
var players = await db.ExecuteQueryAsync("SELECT * FROM players WHERE gold > @minGold", 
    new Dictionary<string, object> { { "@minGold", 1000 } });

// Non-query Ã§alÄ±ÅŸtÄ±r
await db.ExecuteNonQueryAsync("UPDATE players SET gold = @gold WHERE id = @id",
    new Dictionary<string, object> { { "@gold", 5000 }, { "@id", "player123" } });
```

---

### 2.5 ServerConfig.json

**Dosya:** `_Stratocraft/_Bootstrap/ServerConfig.json`

**AmaÃ§:** Sunucu ayarlarÄ±nÄ± JSON dosyasÄ±ndan okuma

**Kod:**

```json
{
  "server": {
    "port": 7770,
    "maxPlayers": 1000,
    "worldSeed": 12345,
    "serverName": "Stratocraft Server",
    "description": "Welcome to Stratocraft!"
  },
  "world": {
    "chunkSize": 32,
    "viewDistance": 4,
    "verticalChunks": 2,
    "enableLOD": true,
    "enableDiskCache": true
  },
  "gameplay": {
    "miningCooldown": 0.1,
    "interactionRange": 5.0,
    "digRadius": 3.0,
    "digDepth": 2.0
  }
}
```

**C# Config Reader (Opsiyonel):**

```csharp
using System;
using System.IO;
using UnityEngine;

[Serializable]
public class ServerConfig {
    public ServerSettings server;
    public WorldSettings world;
    public GameplaySettings gameplay;
    
    [Serializable]
    public class ServerSettings {
        public int port = 7770;
        public int maxPlayers = 1000;
        public int worldSeed = 12345;
        public string serverName = "Stratocraft Server";
        public string description = "Welcome to Stratocraft!";
    }
    
    [Serializable]
    public class WorldSettings {
        public int chunkSize = 32;
        public int viewDistance = 4;
        public int verticalChunks = 2;
        public bool enableLOD = true;
        public bool enableDiskCache = true;
    }
    
    [Serializable]
    public class GameplaySettings {
        public float miningCooldown = 0.1f;
        public float interactionRange = 5.0f;
        public float digRadius = 3.0f;
        public float digDepth = 2.0f;
    }
    
    /// <summary>
    /// âœ… Config dosyasÄ±nÄ± yÃ¼kle
    /// </summary>
    public static ServerConfig Load(string path = "ServerConfig.json") {
        string fullPath = Path.Combine(Application.streamingAssetsPath, path);
        
        if (!File.Exists(fullPath)) {
            Debug.LogWarning($"[ServerConfig] Config dosyasÄ± bulunamadÄ±: {fullPath}, varsayÄ±lan ayarlar kullanÄ±lÄ±yor");
            return new ServerConfig();
        }
        
        try {
            string json = File.ReadAllText(fullPath);
            return JsonUtility.FromJson<ServerConfig>(json);
        } catch (Exception e) {
            Debug.LogError($"[ServerConfig] Config yÃ¼kleme hatasÄ±: {e.Message}");
            return new ServerConfig();
        }
    }
}
```

---

## ğŸ“Š GPU vs CPU KULLANIM ANALÄ°ZÄ° VE OPTÄ°MÄ°ZASYON REHBERÄ°

### ğŸ¯ Ne Zaman GPU, Ne Zaman CPU KullanÄ±lmalÄ±?

**GPU (Compute Shader) KullanÄ±mÄ±:**
- âœ… **Paralel Ä°ÅŸlemler:** Binlerce aynÄ± iÅŸlem (density hesaplama, noise generation)
- âœ… **Grafiksel Hesaplamalar:** Mesh generation, texture processing
- âœ… **Matematiksel Hesaplamalar:** Voxel density, terrain generation
- âœ… **Veri DÃ¶nÃ¼ÅŸÃ¼mleri:** Marching Cubes, mesh building

**CPU (Job System / Multithreading) KullanÄ±mÄ±:**
- âœ… **MantÄ±ksal Ä°ÅŸlemler:** If/else, state machine, decision making
- âœ… **Seri Ä°ÅŸlemler:** SÄ±ralÄ± hesaplamalar, database queries
- âœ… **AI Ä°ÅŸlemleri:** Pathfinding, behavior trees, decision trees
- âœ… **Network Ä°ÅŸlemleri:** Packet processing, synchronization
- âœ… **Game Logic:** Combat calculations, inventory management

**Ã‡oklu Thread (Multithreading) KullanÄ±mÄ±:**
- âœ… **Unity Job System + Burst:** CPU-intensive paralel iÅŸlemler
- âœ… **C# Task/async:** I/O operations (database, file system)
- âœ… **Thread-safe Operations:** Shared data structures

### âš ï¸ Bizim Sistemimizdeki Mevcut Durum

**GPU'da Ã‡alÄ±ÅŸan Sistemler:**
1. âœ… **TerrainDensity.compute** - Density hesaplama (DOÄRU)
2. âœ… **MarchingCubesGPU** - Mesh generation (DOÄRU)
3. âœ… **WaterSim.compute** - Su simÃ¼lasyonu (DOÄRU - opsiyonel)
4. âœ… **GPU Instancing** - Vegetation rendering (DOÄRU)

**CPU'da Ã‡alÄ±ÅŸan Sistemler:**
1. âœ… **DatabaseManager** - SQLite iÅŸlemleri (DOÄRU - async Task)
2. âœ… **AI Sistemleri** - MobAI, BossAI (DOÄRU)
3. âœ… **Game Logic** - Combat, Inventory, Contracts (DOÄRU)
4. âœ… **Network Ä°ÅŸlemleri** - FishNet (DOÄRU)

**Potansiyel Sorunlar ve Ã‡Ã¶zÃ¼mler:**

**1. Chunk Generation - Åu An GPU'da, Ama Mesh Building CPU'da:**
- âœ… **Mevcut:** Density hesaplama GPU'da (DOÄRU)
- âš ï¸ **Sorun:** Mesh building CPU'da yapÄ±lÄ±yor (MarchingCubesGPU)
- âœ… **Ã‡Ã¶zÃ¼m:** Mesh building'i Unity Job System + Burst ile CPU'da paralel yap (zaten GPU'da density var, mesh building CPU'da olmalÄ±)

**2. Territory Calculation - Flood-Fill Algorithm:**
- âš ï¸ **Mevcut:** CPU'da Ã§alÄ±ÅŸÄ±yor (DOÄRU ama optimize edilebilir)
- âœ… **Ã–neri:** Unity Job System + Burst ile paralel yap (Ã§oklu thread)

**3. Pathfinding (NavMesh Baking):**
- âœ… **Mevcut:** Unity NavMesh (CPU'da, Unity optimize ediyor)
- âœ… **Durum:** DOÄRU - NavMesh Unity tarafÄ±ndan optimize edilmiÅŸ

**4. Database Ä°ÅŸlemleri:**
- âœ… **Mevcut:** Async Task (thread pool'da Ã§alÄ±ÅŸÄ±yor)
- âœ… **Durum:** DOÄRU - I/O operations iÃ§in async Task ideal

### ğŸ”§ Ã–nerilen DeÄŸiÅŸiklikler

**1. Chunk Mesh Building - Job System + Burst:**
```csharp
// âœ… Ã–NERÄ°: Mesh building'i Job System ile paralel yap
using Unity.Jobs;
using Unity.Burst;
using Unity.Collections;

[BurstCompile]
struct BuildMeshJob : IJob {
    public NativeArray<float> densityData;
    public NativeArray<Vector3> vertices;
    public NativeArray<int> triangles;
    
    public void Execute() {
        // âœ… Mesh building logic (Burst ile optimize)
    }
}
```

**2. Territory Flood-Fill - Job System:**
```csharp
// âœ… Ã–NERÄ°: Flood-fill'i paralel yap
[BurstCompile]
struct FloodFillJob : IJobParallelFor {
    public NativeArray<bool> visited;
    public NativeArray<Vector3Int> queue;
    
    public void Execute(int index) {
        // âœ… Paralel flood-fill
    }
}
```

**3. AI Pathfinding - Zaten Optimize:**
- âœ… Unity NavMesh zaten optimize edilmiÅŸ, deÄŸiÅŸiklik gerekmez

**4. Database - Zaten Async:**
- âœ… Async Task kullanÄ±lÄ±yor, deÄŸiÅŸiklik gerekmez

### ğŸ“ˆ Performans KarÅŸÄ±laÅŸtÄ±rmasÄ±

**GPU KullanÄ±mÄ±:**
- âœ… **Avantaj:** Binlerce paralel iÅŸlem (density hesaplama)
- âš ï¸ **Dezavantaj:** GPU'ya aÅŸÄ±rÄ± yÃ¼k binerse frame drop olur
- âœ… **Ã‡Ã¶zÃ¼m:** LOD sistemi, batch processing

**CPU + Multithreading:**
- âœ… **Avantaj:** MantÄ±ksal iÅŸlemler iÃ§in ideal
- âœ… **Avantaj:** Ã‡oklu thread ile paralel iÅŸlem
- âš ï¸ **Dezavantaj:** Thread synchronization overhead

**Hibrit YaklaÅŸÄ±m (Ã–nerilen):**
- âœ… **GPU:** Density hesaplama, mesh generation (paralel)
- âœ… **CPU + Job System:** Mesh building, territory calculation (paralel)
- âœ… **CPU + Async:** Database, I/O operations (non-blocking)

### ğŸ¯ SonuÃ§ ve Ã–neriler

**DeÄŸiÅŸtirilmesi Gerekenler:**
1. âœ… **Chunk Mesh Building:** Job System + Burst ile paralel yap
2. âœ… **Territory Flood-Fill:** Job System ile paralel yap
3. âœ… **LOD Sistemi:** Zaten var, aktif tut

**DeÄŸiÅŸtirilmemesi Gerekenler:**
1. âœ… **TerrainDensity.compute:** GPU'da kalmalÄ± (DOÄRU)
2. âœ… **DatabaseManager:** Async Task kullanÄ±yor (DOÄRU)
3. âœ… **AI Sistemleri:** CPU'da kalmalÄ± (DOÄRU)
4. âœ… **Network Ä°ÅŸlemleri:** FishNet optimize edilmiÅŸ (DOÄRU)

**Genel Kural:**
- **GPU:** Paralel matematiksel hesaplamalar (density, noise, mesh)
- **CPU + Job System:** Paralel mantÄ±ksal iÅŸlemler (territory, pathfinding)
- **CPU + Async:** I/O operations (database, file system)

### âš ï¸ GPU YOKSA NE OLACAK? (Fallback Sistemi)

**Sorun:** EÄŸer oyuncunun ekran kartÄ± yoksa veya Compute Shader desteklemiyorsa oyun Ã§alÄ±ÅŸmayacak mÄ±?

**Ã‡Ã¶zÃ¼m:** CPU Fallback Sistemi - GPU yoksa otomatik CPU'ya geÃ§er

**Kontrol Sistemi:**
```csharp
// âœ… GPU desteÄŸi kontrolÃ¼
bool hasGPU = SystemInfo.supportsComputeShaders && 
              SystemInfo.graphicsDeviceType != GraphicsDeviceType.Null;

if (!hasGPU) {
    Debug.LogWarning("[ChunkManager] GPU Compute Shader desteklenmiyor! CPU fallback aktif.");
    // âœ… CPU fallback moduna geÃ§
}
```

**Fallback Stratejisi:**
1. âœ… **GPU KontrolÃ¼:** SystemInfo.supportsComputeShaders kontrolÃ¼
2. âœ… **CPU Fallback:** GPU yoksa CPU'da density hesaplama (Job System + Burst)
3. âœ… **Performans UyarÄ±sÄ±:** GPU yoksa oyuncuya bilgi ver
4. âœ… **Otomatik GeÃ§iÅŸ:** GPU varsa GPU, yoksa CPU kullan

**Desteklenen GPU Tipleri:**
- âœ… **DirectX 11/12:** Compute Shader destekler â†’ GPU modu
- âœ… **Vulkan:** Compute Shader destekler â†’ GPU modu
- âœ… **Metal (macOS/iOS):** Compute Shader destekler â†’ GPU modu
- âœ… **OpenGL ES 3.0+:** Compute Shader destekler â†’ GPU modu
- âŒ **OpenGL ES 2.0:** Compute Shader desteklemez â†’ CPU fallback
- âŒ **Null Device (Test):** Compute Shader desteklemez â†’ CPU fallback

**Performans FarkÄ±:**
- âœ… **GPU Modu:** ~100-1000x daha hÄ±zlÄ± (paralel iÅŸlem, binlerce Ã§ekirdek)
- âš ï¸ **CPU Fallback:** Daha yavaÅŸ ama Ã§alÄ±ÅŸÄ±r (Job System + Burst ile optimize)
- âœ… **CPU Fallback Optimizasyonu:** Job System + Burst ile %10-50x hÄ±z artÄ±ÅŸÄ± (normal CPU'ya gÃ¶re)

**KullanÄ±cÄ± Deneyimi:**
- âœ… **GPU Varsa:** Otomatik GPU kullanÄ±lÄ±r (en iyi performans, 60+ FPS)
- âœ… **GPU Yoksa:** Otomatik CPU'ya geÃ§er (oyun Ã§alÄ±ÅŸÄ±r, 30-60 FPS arasÄ±)
- âœ… **UyarÄ± MesajÄ±:** GPU yoksa oyuncuya bilgi verilir (UI'da gÃ¶sterilebilir)
- âœ… **Ayarlar:** Oyuncu manuel olarak CPU modunu seÃ§ebilir (ayarlar menÃ¼sÃ¼)

### ğŸ”§ DetaylÄ± Kod Ã–rnekleri

**1. Chunk Mesh Building - Job System Entegrasyonu:**

```csharp
// âœ… ChunkManager.cs iÃ§ine eklenecek
using Unity.Jobs;
using Unity.Burst;
using Unity.Collections;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Mesh building Job (CPU'da paralel)
/// NOT: Scrawk'Ä±n MarchingCubesGPU'su zaten optimize edilmiÅŸ
/// Bu Ã¶rnek sadece Job System entegrasyonunu gÃ¶sterir
/// </summary>
[BurstCompile]
struct BuildMeshJob : IJob {
    [ReadOnly]
    public NativeArray<float> densityData;
    
    [WriteOnly]
    public NativeArray<Vector3> vertices;
    
    [WriteOnly]
    public NativeArray<int> triangles;
    
    public int chunkSize;
    
    public void Execute() {
        // âœ… Mesh building logic (Burst ile optimize)
        // NOT: GerÃ§ek implementasyon Scrawk'Ä±n kendi kodunu kullanÄ±r
        // Burada sadece Job System pattern'ini gÃ¶steriyoruz
    }
}

// âœ… ChunkManager iÃ§inde kullanÄ±m:
IEnumerator BuildMeshWithJobSystem(MarchingCubesGPU generator, Vector3Int coord) {
    float[] densityData = generator.GetDensityData();
    
    // âœ… NativeArray'e Ã§evir
    NativeArray<float> densityNative = new NativeArray<float>(densityData, Allocator.TempJob);
    NativeArray<Vector3> vertices = new NativeArray<Vector3>(chunkSize * chunkSize * chunkSize * 8, Allocator.TempJob);
    NativeArray<int> triangles = new NativeArray<int>(chunkSize * chunkSize * chunkSize * 15, Allocator.TempJob);
    
    // âœ… Job oluÅŸtur
    var job = new BuildMeshJob {
        densityData = densityNative,
        vertices = vertices,
        triangles = triangles,
        chunkSize = chunkSize
    };
    
    // âœ… Job'u Ã§alÄ±ÅŸtÄ±r (CPU'da paralel)
    JobHandle handle = job.Schedule();
    
    // âœ… Job bitene kadar bekle
    yield return new WaitUntil(() => handle.IsCompleted);
    handle.Complete();
    
    // âœ… SonuÃ§larÄ± al ve mesh'e uygula
    // ... mesh building logic ...
    
    // âœ… NativeArray'leri temizle
    densityNative.Dispose();
    vertices.Dispose();
    triangles.Dispose();
}
```

**2. Territory Flood-Fill - Job System Entegrasyonu:**

```csharp
// âœ… TerritoryManager.cs iÃ§ine eklenecek
using Unity.Jobs;
using Unity.Burst;
using Unity.Collections;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Flood-fill Job (CPU'da paralel)
/// </summary>
[BurstCompile]
struct FloodFillJob : IJobParallelFor {
    [ReadOnly]
    public NativeArray<Vector3Int> startNodes;
    
    [ReadOnly]
    public NativeArray<bool> passableGrid; // Voxel terrain passability
    
    [WriteOnly]
    public NativeArray<bool> visited;
    
    [WriteOnly]
    public NativeArray<Vector3Int> territoryBlocks;
    
    public int chunkSize;
    public string clanId; // Job iÃ§inde string kullanÄ±lamaz, int ID kullan
    
    public void Execute(int index) {
        Vector3Int startNode = startNodes[index];
        
        // âœ… Flood-fill algoritmasÄ± (Burst ile optimize)
        Queue<Vector3Int> queue = new Queue<Vector3Int>();
        queue.Enqueue(startNode);
        
        while (queue.Count > 0) {
            Vector3Int current = queue.Dequeue();
            
            // âœ… Ziyaret edildi mi?
            int visitIndex = current.x + current.y * chunkSize + current.z * chunkSize * chunkSize;
            if (visited[visitIndex]) continue;
            visited[visitIndex] = true;
            
            // âœ… GeÃ§ilebilir mi?
            if (!passableGrid[visitIndex]) continue;
            
            // âœ… Territory'ye ekle
            territoryBlocks[visitIndex] = current;
            
            // âœ… KomÅŸularÄ± ekle (6 yÃ¶n)
            Vector3Int[] neighbors = {
                current + Vector3Int.right,
                current + Vector3Int.left,
                current + Vector3Int.up,
                current + Vector3Int.down,
                current + Vector3Int.forward,
                current + Vector3Int.back
            };
            
            foreach (var neighbor in neighbors) {
                if (IsValidPosition(neighbor) && !visited[neighbor.x + neighbor.y * chunkSize + neighbor.z * chunkSize * chunkSize]) {
                    queue.Enqueue(neighbor);
                }
            }
        }
    }
    
    bool IsValidPosition(Vector3Int pos) {
        return pos.x >= 0 && pos.x < chunkSize &&
               pos.y >= 0 && pos.y < chunkSize &&
               pos.z >= 0 && pos.z < chunkSize;
    }
}

// âœ… TerritoryManager iÃ§inde kullanÄ±m:
IEnumerator CalculateTerritoryWithJobSystem(Vector3 startNode, string clanId) {
    // âœ… Passability grid'i oluÅŸtur (ChunkManager'dan)
    ChunkManager chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
    if (chunkManager == null) yield break;
    
    Vector3Int chunkCoord = chunkManager.GetChunkCoord(startNode);
    float[] densityData = chunkManager.GetDensityDataForChunk(chunkCoord);
    
    // âœ… Passability grid'i oluÅŸtur
    int gridSize = 32 * 32 * 32; // Chunk size
    NativeArray<bool> passableGrid = new NativeArray<bool>(gridSize, Allocator.TempJob);
    for (int i = 0; i < densityData.Length; i++) {
        passableGrid[i] = densityData[i] < 0f; // Density < 0 = passable
    }
    
    // âœ… Job oluÅŸtur
    NativeArray<Vector3Int> startNodes = new NativeArray<Vector3Int>(1, Allocator.TempJob);
    startNodes[0] = Vector3Int.FloorToInt(startNode);
    
    NativeArray<bool> visited = new NativeArray<bool>(gridSize, Allocator.TempJob);
    NativeArray<Vector3Int> territoryBlocks = new NativeArray<Vector3Int>(gridSize, Allocator.TempJob);
    
    var job = new FloodFillJob {
        startNodes = startNodes,
        passableGrid = passableGrid,
        visited = visited,
        territoryBlocks = territoryBlocks,
        chunkSize = 32
    };
    
    // âœ… Job'u Ã§alÄ±ÅŸtÄ±r (CPU'da paralel)
    JobHandle handle = job.Schedule(1, 1); // 1 start node
    
    // âœ… Job bitene kadar bekle
    yield return new WaitUntil(() => handle.IsCompleted);
    handle.Complete();
    
    // âœ… SonuÃ§larÄ± al
    List<Vector3Int> securedBlocks = new List<Vector3Int>();
    for (int i = 0; i < territoryBlocks.Length; i++) {
        if (visited[i]) {
            securedBlocks.Add(territoryBlocks[i]);
        }
    }
    
    // âœ… NativeArray'leri temizle
    startNodes.Dispose();
    passableGrid.Dispose();
    visited.Dispose();
    territoryBlocks.Dispose();
    
    // âœ… Territory'yi kaydet
    // ... territory saving logic ...
}
```

### âš ï¸ Ã–nemli Notlar

**1. GPU AÅŸÄ±rÄ± YÃ¼klenmesi:**
- âœ… **Sorun:** TÃ¼m iÅŸlemleri GPU'ya yÃ¼klemek frame drop'a neden olur
- âœ… **Ã‡Ã¶zÃ¼m:** LOD sistemi, batch processing, GPU-CPU dengesi

**2. Thread Safety:**
- âœ… **Sorun:** Ã‡oklu thread'de shared data structures
- âœ… **Ã‡Ã¶zÃ¼m:** NativeArray (Job System thread-safe), lock (DatabaseManager)

**3. Burst Compiler:**
- âœ… **Avantaj:** Job System + Burst = %10-100x hÄ±z artÄ±ÅŸÄ±
- âœ… **KÄ±sÄ±tlama:** Sadece value types, managed code yok

**4. Async vs Job System:**
- âœ… **Async Task:** I/O operations (database, file system)
- âœ… **Job System:** CPU-intensive paralel iÅŸlemler (mesh building, flood-fill)

### ğŸ“Š Performans KarÅŸÄ±laÅŸtÄ±rmasÄ±

**Mevcut Sistem (GPU AÄŸÄ±rlÄ±klÄ±):**
- âœ… TerrainDensity.compute: GPU'da (DOÄRU)
- âš ï¸ Mesh Building: CPU'da (ama optimize edilebilir)
- âš ï¸ Territory Flood-Fill: CPU'da (ama optimize edilebilir)

**Ã–nerilen Sistem (Hibrit):**
- âœ… TerrainDensity.compute: GPU'da (DEÄÄ°ÅMEZ)
- âœ… Mesh Building: CPU + Job System (OPTÄ°MÄ°ZE)
- âœ… Territory Flood-Fill: CPU + Job System (OPTÄ°MÄ°ZE)
- âœ… Database: CPU + Async Task (DEÄÄ°ÅMEZ)

**Beklenen Performans ArtÄ±ÅŸÄ±:**
- âœ… Mesh Building: %20-50 daha hÄ±zlÄ± (Job System + Burst)
- âœ… Territory Flood-Fill: %30-70 daha hÄ±zlÄ± (Job System + Burst)
- âœ… GPU YÃ¼kÃ¼: %10-20 azalma (LOD sistemi)

### ğŸ“‹ Sistemimizdeki GPU/CPU DaÄŸÄ±lÄ±mÄ± (Final)

**GPU'da Kalacak Sistemler (DEÄÄ°ÅMEZ):**
1. âœ… **TerrainDensity.compute** - Density hesaplama (paralel, binlerce voxel)
2. âœ… **MarchingCubesGPU** - Mesh generation (GPU'da density â†’ mesh)
3. âœ… **WaterSim.compute** - Su simÃ¼lasyonu (opsiyonel, paralel hesaplama)
4. âœ… **GPU Instancing** - Vegetation rendering (binlerce aÄŸaÃ§/kaya)

**CPU'da Kalacak Sistemler (DEÄÄ°ÅMEZ):**
1. âœ… **AI Sistemleri** - MobAI, BossAI (mantÄ±ksal iÅŸlemler)
2. âœ… **Game Logic** - Combat, Inventory, Contracts (if/else, state machine)
3. âœ… **Network Ä°ÅŸlemleri** - FishNet (Unity optimize edilmiÅŸ)
4. âœ… **UI Sistemleri** - Canvas, TextMeshPro (Unity optimize edilmiÅŸ)

**CPU'da Optimize Edilecek Sistemler (JOB SYSTEM EKLENECEK):**
1. âš ï¸ **Chunk Mesh Building** - Åu an CPU'da, Job System + Burst ile optimize edilecek
2. âš ï¸ **Territory Flood-Fill** - Åu an Coroutine'de, Job System + Burst ile optimize edilecek
3. âœ… **Database Ä°ÅŸlemleri** - Zaten Async Task (deÄŸiÅŸiklik gerekmez)

**GPU Fallback Sistemi (YENÄ°):**
1. âœ… **GPU KontrolÃ¼** - SystemInfo.supportsComputeShaders ile otomatik kontrol
2. âœ… **CPU Fallback** - GPU yoksa otomatik CPU'ya geÃ§er (Job System + Burst)
3. âœ… **Performans UyarÄ±sÄ±** - GPU yoksa oyuncuya bilgi verilir
4. âœ… **Otomatik GeÃ§iÅŸ** - GPU varsa GPU, yoksa CPU kullan (oyun her zaman Ã§alÄ±ÅŸÄ±r)

**Ã‡oklu Thread KullanÄ±mÄ±:**
1. âœ… **Unity Job System + Burst** - CPU-intensive paralel iÅŸlemler (mesh building, flood-fill)
2. âœ… **C# Task/async** - I/O operations (database, file system)
3. âœ… **Coroutines** - Asenkron iÅŸlemler (chunk loading, UI updates)

### ğŸ¯ Karar Verme Kriterleri

**GPU Kullan (Compute Shader):**
- âœ… Binlerce aynÄ± iÅŸlem (density hesaplama, noise generation)
- âœ… Paralel matematiksel hesaplamalar
- âœ… Grafiksel iÅŸlemler (mesh generation, texture processing)
- âš ï¸ **Dikkat:** GPU'ya aÅŸÄ±rÄ± yÃ¼k binerse frame drop olur

**CPU + Job System Kullan:**
- âœ… MantÄ±ksal iÅŸlemler (if/else, state machine)
- âœ… Paralel CPU-intensive iÅŸlemler (mesh building, flood-fill)
- âœ… Burst Compiler ile optimize edilebilir iÅŸlemler
- âœ… **Avantaj:** Ã‡oklu thread, %10-100x hÄ±z artÄ±ÅŸÄ±

**CPU + Async Task Kullan:**
- âœ… I/O operations (database, file system)
- âœ… Network iÅŸlemleri (HTTP requests)
- âœ… **Avantaj:** Non-blocking, UI donmasÄ±nÄ± Ã¶nler

**CPU + Coroutine Kullan:**
- âœ… Asenkron iÅŸlemler (chunk loading, UI updates)
- âœ… Frame bazlÄ± gÃ¼ncellemeler
- âœ… **Avantaj:** Basit, Unity native

### âš ï¸ AÅŸÄ±rÄ± YÃ¼klenme Ã–nleme

**GPU AÅŸÄ±rÄ± YÃ¼klenmesi:**
- âœ… **Sorun:** TÃ¼m iÅŸlemleri GPU'ya yÃ¼klemek frame drop'a neden olur
- âœ… **Ã‡Ã¶zÃ¼m:** 
  - LOD sistemi (uzak chunklar dÃ¼ÅŸÃ¼k detay)
  - Batch processing (aynÄ± frame'de birden fazla iÅŸlem)
  - GPU-CPU dengesi (density GPU'da, mesh building CPU'da)

**CPU AÅŸÄ±rÄ± YÃ¼klenmesi:**
- âœ… **Sorun:** Main thread'de aÄŸÄ±r iÅŸlemler UI donmasÄ±na neden olur
- âœ… **Ã‡Ã¶zÃ¼m:**
  - Job System (paralel iÅŸlemler)
  - Async Task (I/O operations)
  - Coroutines (frame bazlÄ± gÃ¼ncellemeler)

### ğŸ“Š SonuÃ§ ve Ã–neriler

**DeÄŸiÅŸtirilmesi Gerekenler:**
1. âœ… **Chunk Mesh Building:** Job System + Burst ile paralel yap (ÅŸu an CPU'da ama optimize edilebilir)
2. âœ… **Territory Flood-Fill:** Job System + Burst ile paralel yap (ÅŸu an Coroutine'de)
3. âœ… **LOD Sistemi:** Zaten var, aktif tut (GPU yÃ¼kÃ¼nÃ¼ azaltÄ±r)

**DeÄŸiÅŸtirilmemesi Gerekenler:**
1. âœ… **TerrainDensity.compute:** GPU'da kalmalÄ± (DOÄRU - paralel hesaplama)
2. âœ… **DatabaseManager:** Async Task kullanÄ±yor (DOÄRU - I/O operations)
3. âœ… **AI Sistemleri:** CPU'da kalmalÄ± (DOÄRU - mantÄ±ksal iÅŸlemler)
4. âœ… **Network Ä°ÅŸlemleri:** FishNet optimize edilmiÅŸ (DOÄRU)

**Genel Kural:**
- **GPU:** Paralel matematiksel hesaplamalar (density, noise, mesh)
- **CPU + Job System:** Paralel mantÄ±ksal iÅŸlemler (territory, pathfinding)
- **CPU + Async:** I/O operations (database, file system)
- **CPU + Coroutine:** Asenkron iÅŸlemler (chunk loading, UI updates)

**Ã‡oklu Thread Ä°liÅŸkisi:**
- âœ… **Job System:** CPU Ã§ekirdeklerini paralel kullanÄ±r (multithreading)
- âœ… **Async Task:** Thread pool'u kullanÄ±r (multithreading)
- âœ… **Coroutines:** Main thread'de Ã§alÄ±ÅŸÄ±r (single thread, frame bazlÄ±)

---

## ğŸŒ ADIM 3: GPU DÃœNYA MOTORU (SCRAWK MODÄ°FÄ°KASYONU)

### 3.1 TerrainDensity.compute (Modifiye EdilmiÅŸ)

**Dosya:** `_Stratocraft/Engine/ComputeShaders/TerrainDensity.compute`

**AmaÃ§:** GPU Ã¼zerinde zemin ÅŸekli ve madenleri hesaplama (sonsuz dÃ¼nya iÃ§in offset desteÄŸi)

**Kod:**

```hlsl
// âœ… MODÄ°FÄ°YE EDÄ°LMÄ°Å: Scrawk'Ä±n orijinal Density shader'Ä±na Offset ve Seed eklendi
#pragma kernel Density

// âœ… FastNoiseLite kÃ¼tÃ¼phanesini dahil et
#include "Includes/FastNoiseLite.compute"

RWStructuredBuffer<float> Density;
int3 Size;
float3 Offset; // âœ… YENÄ°: Chunk'Ä±n dÃ¼nyadaki konumu (sonsuzluk iÃ§in)
float Seed;    // âœ… YENÄ°: Sunucudan gelen tohum (deterministik dÃ¼nya)

[numthreads(8, 8, 8)]
void Density (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= Size.x || id.y >= Size.y || id.z >= Size.z) return;

    // âœ… GerÃ§ek DÃ¼nya Pozisyonunu Hesapla (Offset eklenmiÅŸ)
    float3 worldPos = id + Offset; 

    // âœ… FastNoise ile Biyom HesabÄ± (BasitleÅŸtirilmiÅŸ - Faz 3'te geniÅŸletilecek)
    // Seed'i kullanarak rastgelelik saÄŸla (deterministik)
    float groundNoise = GetNoise(worldPos.xz * 0.01, Seed); 
    float mountainNoise = GetNoise(worldPos.xz * 0.05, Seed + 100);
    float detailNoise = GetNoise(worldPos * 0.1, Seed + 200);

    // âœ… YÃ¼kseklik hesabÄ±: Taban + DaÄŸlar + Detay
    float terrainHeight = (groundNoise * 20) + (mountainNoise * 100) + (detailNoise * 5);
    
    // âœ… Density (YoÄŸunluk) HesabÄ±:
    // EÄŸer worldPos.y (yÃ¼kseklik) arazi yÃ¼ksekliÄŸinden azsa 1 (dolu), deÄŸilse -1 (boÅŸ)
    float densityVal = terrainHeight - worldPos.y;

    // âœ… Madenler iÃ§in ekstra gÃ¼rÃ¼ltÃ¼ (Faz 4'te eklenecek)
    // if (worldPos.y < -50 && GetNoise(worldPos, Seed + 1000) > 0.8) {
    //     densityVal = 0; // MaÄŸara veya maden
    // }

    int index = id.x + id.y * Size.x + id.z * Size.x * Size.y;
    Density[index] = densityVal;
}
```

**Ã–nemli Notlar:**
- `Offset` parametresi chunk'Ä±n dÃ¼nyadaki konumunu belirtir (sonsuzluk iÃ§in kritik)
- `Seed` parametresi deterministik dÃ¼nya oluÅŸturma iÃ§in (tÃ¼m clientlar aynÄ± dÃ¼nyayÄ± gÃ¶rÃ¼r)
- FastNoiseLite kÃ¼tÃ¼phanesi `Includes/` klasÃ¶rÃ¼nde olmalÄ±

---

### 3.2 ChunkManager.cs (YÃ¼ksek PerformanslÄ± - GPU Optimize)

**Dosya:** `_Stratocraft/Engine/Core/ChunkManager.cs`

**AmaÃ§:** Sonsuz dÃ¼nya iÃ§in chunk yÃ¶netimi (GPU hesaplama, caching, priority queue, mesh pooling)

**Kod:**

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using FishNet.Object;
using FishNet.Object.Synchronizing;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

/// <summary>
/// âœ… YÃœKSEK PERFORMANSLI: Sonsuz dÃ¼nya chunk yÃ¶neticisi
/// - GPU Compute Shader optimizasyonlarÄ±
/// - Priority Queue (yakÄ±n chunklar Ã¶nce yÃ¼klenir)
/// - Mesh Pooling (chunk mesh'lerini yeniden kullanma)
/// - LOD sistemi (uzak chunklar dÃ¼ÅŸÃ¼k detay)
/// - Asenkron chunk generation (Job System)
/// - Chunk data caching (disk'e kaydetme/yÃ¼kleme)
/// - Multi-threading support
/// </summary>
public class ChunkManager : NetworkBehaviour {
    [Header("Ayarlar")]
    public GameObject chunkPrefab; // Scrawk scripti olan kutu prefab'Ä±
    public int chunkSize = 32;     // Bir chunk 32x32x32 voxel
    public int viewDistance = 4;   // GÃ¶rÃ¼ÅŸ mesafesi (yarÄ±Ã§ap) - 4 = 8x8 chunk alanÄ±
    public int verticalChunks = 2; // Dikey chunk sayÄ±sÄ± (Y ekseni)
    
    [Header("Performans")]
    public int maxChunksPerFrame = 3; // Frame baÅŸÄ±na maksimum chunk yÃ¼kleme
    public float chunkUpdateInterval = 0.3f; // Chunk gÃ¼ncelleme aralÄ±ÄŸÄ± (saniye)
    public int maxConcurrentGenerations = 4; // AynÄ± anda oluÅŸturulabilecek chunk sayÄ±sÄ±
    
    [Header("LOD AyarlarÄ±")]
    public bool useLOD = true; // Level of Detail aktif mi?
    public int lodDistance1 = 2; // LOD 1 mesafesi (orta detay)
    public int lodDistance2 = 4; // LOD 2 mesafesi (dÃ¼ÅŸÃ¼k detay)
    
    [Header("Caching")]
    public bool enableDiskCache = true; // Disk'e chunk kaydetme
    public string cachePath = "ChunkCache/"; // Cache klasÃ¶rÃ¼

    // âœ… OPTÄ°MÄ°ZE: Dictionary kullan (O(1) lookup)
    private Dictionary<Vector3Int, ChunkData> _activeChunks = new Dictionary<Vector3Int, ChunkData>();
    
    // âœ… YENÄ°: Priority Queue (yakÄ±n chunklar Ã¶nce yÃ¼klenir)
    private SortedDictionary<float, Vector3Int> _priorityLoadQueue = new SortedDictionary<float, Vector3Int>();
    private Dictionary<Vector3Int, float> _chunkPriorities = new Dictionary<Vector3Int, float>();
    
    // âœ… OPTÄ°MÄ°ZE: Chunk silme kuyruÄŸu (performans iÃ§in)
    private Queue<Vector3Int> _chunkUnloadQueue = new Queue<Vector3Int>();
    
    // âœ… YENÄ°: Chunk state management
    private Dictionary<Vector3Int, ChunkState> _chunkStates = new Dictionary<Vector3Int, ChunkState>();
    
    // âœ… YENÄ°: Mesh Pool (chunk mesh'lerini yeniden kullanma)
    private Queue<Mesh> _meshPool = new Queue<Mesh>();
    private int _maxPoolSize = 50;
    
    // âœ… YENÄ°: GPU Compute Shader cache
    private ComputeShader _densityCompute;
    private ComputeBuffer _densityBuffer;
    
    // âœ… YENÄ°: Asenkron generation tracking
    private HashSet<Vector3Int> _generatingChunks = new HashSet<Vector3Int>();
    
    // âœ… YENÄ°: Chunk data cache (disk'ten yÃ¼kleme)
    private Dictionary<Vector3Int, ChunkCacheData> _chunkCache = new Dictionary<Vector3Int, ChunkCacheData>();
    
    private Transform _playerTransform;
    private int _worldSeed;
    private float _lastChunkUpdate;
    private int _chunksLoadedThisFrame;
    private Vector3Int _lastPlayerChunkCoord = Vector3Int.zero;

    /// <summary>
    /// âœ… Chunk durumu enum'u
    /// </summary>
    private enum ChunkState {
        Unloaded,      // YÃ¼klenmemiÅŸ
        Loading,       // YÃ¼kleniyor (GPU'da hesaplanÄ±yor)
        Generating,    // Mesh oluÅŸturuluyor
        Ready,         // HazÄ±r (oyunda gÃ¶rÃ¼nÃ¼r)
        Unloading      // Siliniyor
    }

    /// <summary>
    /// âœ… Chunk veri yapÄ±sÄ±
    /// </summary>
    private class ChunkData {
        public GameObject GameObject;
        public MarchingCubesGPU Generator;
        public Mesh ChunkMesh;
        public ChunkState State;
        public int LODLevel; // 0 = yÃ¼ksek detay, 1 = orta, 2 = dÃ¼ÅŸÃ¼k
        public float LastAccessTime; // Son eriÅŸim zamanÄ± (cache iÃ§in)
    }

    /// <summary>
    /// âœ… Chunk cache veri yapÄ±sÄ± (disk'ten yÃ¼kleme iÃ§in)
    /// </summary>
    private class ChunkCacheData {
        public float[] DensityData; // Density deÄŸerleri
        public bool IsModified; // DeÄŸiÅŸtirilmiÅŸ mi? (disk'e kaydet)
        public float LastSaveTime; // Son kayÄ±t zamanÄ±
    }

    // âœ… YENÄ°: GPU desteÄŸi kontrolÃ¼
    private bool _useGPU = true; // GPU kullanÄ±lsÄ±n mÄ±?
    private bool _gpuSupported = false; // GPU destekleniyor mu?
    
    /// <summary>
    /// âœ… GPU desteÄŸi kontrolÃ¼ ve fallback sistemi
    /// </summary>
    void CheckGPUSupport() {
        // âœ… GPU Compute Shader desteÄŸi kontrolÃ¼
        _gpuSupported = SystemInfo.supportsComputeShaders && 
                       SystemInfo.graphicsDeviceType != GraphicsDeviceType.Null &&
                       SystemInfo.graphicsDeviceType != GraphicsDeviceType.OpenGLES2; // ES2 desteklemiyor
        
        if (!_gpuSupported) {
            _useGPU = false;
            Debug.LogWarning($"[ChunkManager] âš ï¸ GPU Compute Shader desteklenmiyor! CPU fallback aktif.");
            Debug.LogWarning($"[ChunkManager] GPU Type: {SystemInfo.graphicsDeviceType}, Compute Shaders: {SystemInfo.supportsComputeShaders}");
            
            // âœ… Oyuncuya bilgi ver (UI'da gÃ¶sterilebilir)
            // TODO: UI'da "CPU modunda Ã§alÄ±ÅŸÄ±yor, performans dÃ¼ÅŸÃ¼k olabilir" mesajÄ± gÃ¶ster
        } else {
            _useGPU = true;
            Debug.Log($"[ChunkManager] âœ… GPU Compute Shader destekleniyor - GPU modu aktif.");
        }
    }
    
    /// <summary>
    /// âœ… Sunucudan Seed geldiÄŸinde burasÄ± Ã§alÄ±ÅŸÄ±r (SyncWorld.cs'den Ã§aÄŸrÄ±lÄ±r)
    /// </summary>
    public void InitializeWorld(int seed, Transform player) {
        _worldSeed = seed;
        _playerTransform = player;
        _lastChunkUpdate = Time.time;
        
        // âœ… GPU desteÄŸi kontrolÃ¼ (ilk baÅŸta)
        CheckGPUSupport();
        
        // âœ… NOT: TerrainDensity.compute shader'Ä± Scrawk'Ä±n MarchingCubesGPU'su tarafÄ±ndan yÃ¶netilir
        // ChunkManager'da ayrÄ± yÃ¼klemeye gerek yok
        // Ancak GPU yoksa CPU fallback kullanÄ±lacak
        
        // âœ… Mesh pool'u baÅŸlat
        InitializeMeshPool();
        
        // âœ… Cache klasÃ¶rÃ¼nÃ¼ oluÅŸtur
        if (enableDiskCache) {
            System.IO.Directory.CreateDirectory(cachePath);
        }
        
        string mode = _useGPU ? "GPU" : "CPU (Fallback)";
        Debug.Log($"[ChunkManager] DÃ¼nya baÅŸlatÄ±ldÄ± - Seed: {seed}, View Distance: {viewDistance}, LOD: {useLOD}, Mode: {mode}");
    }

    void Update() {
        if (_playerTransform == null) return;
        
        // âœ… OPTÄ°MÄ°ZE: Chunk gÃ¼ncellemelerini sÄ±nÄ±rla (performans)
        if (Time.time - _lastChunkUpdate < chunkUpdateInterval) return;
        
        _lastChunkUpdate = Time.time;
        _chunksLoadedThisFrame = 0;
        
        UpdateChunks();
        ProcessChunkQueues();
        UpdateLODs(); // âœ… YENÄ°: LOD gÃ¼ncelleme
        CleanupUnusedMeshes(); // âœ… YENÄ°: KullanÄ±lmayan mesh'leri temizle
    }

    /// <summary>
    /// âœ… YÃœKSEK PERFORMANSLI: Chunk'larÄ± gÃ¼ncelle (oyuncu pozisyonuna gÃ¶re)
    /// Priority Queue kullanarak yakÄ±n chunklar Ã¶nce yÃ¼klenir
    /// </summary>
    void UpdateChunks() {
        Vector3Int playerChunkCoord = GetChunkCoord(_playerTransform.position);
        
        // âœ… Oyuncu chunk deÄŸiÅŸtiyse gÃ¼ncelle
        if (playerChunkCoord != _lastPlayerChunkCoord) {
            _lastPlayerChunkCoord = playerChunkCoord;
            RecalculatePriorities(playerChunkCoord);
        }

        // âœ… 1. Yeni ChunklarÄ± Priority Queue'ya Ekle (yakÄ±n olanlar Ã¶nce)
        for (int x = -viewDistance; x <= viewDistance; x++) {
            for (int z = -viewDistance; z <= viewDistance; z++) {
                for (int y = 0; y < verticalChunks; y++) {
                    Vector3Int coord = new Vector3Int(
                        playerChunkCoord.x + x, 
                        y, 
                        playerChunkCoord.z + z
                    );
                    
                    // âœ… Chunk zaten yÃ¼klÃ¼ veya yÃ¼kleniyor mu?
                    if (_activeChunks.ContainsKey(coord) || _generatingChunks.Contains(coord)) {
                        continue;
                    }
                    
                    // âœ… Mesafe hesapla (priority iÃ§in)
                    float distance = Vector3.Distance(
                        new Vector3(coord.x, coord.y, coord.z),
                        new Vector3(playerChunkCoord.x, playerChunkCoord.y, playerChunkCoord.z)
                    );
                    
                    // âœ… Priority Queue'ya ekle (yakÄ±n olanlar Ã¶nce)
                    if (!_chunkPriorities.ContainsKey(coord)) {
                        _chunkPriorities[coord] = distance;
                        // âœ… AynÄ± distance'ta birden fazla chunk olabilir, unique key oluÅŸtur
                        float uniqueKey = distance + (coord.x * 0.001f) + (coord.z * 0.0001f);
                        _priorityLoadQueue[uniqueKey] = coord;
                    }
                }
            }
        }

        // âœ… 2. Uzaktaki ChunklarÄ± Sil (Optimizasyon)
        List<Vector3Int> chunksToRemove = new List<Vector3Int>();
        
        foreach (var kvp in _activeChunks) {
            Vector3Int coord = kvp.Key;
            float distance = Vector3.Distance(
                new Vector3(coord.x, coord.y, coord.z),
                new Vector3(playerChunkCoord.x, playerChunkCoord.y, playerChunkCoord.z)
            );
            
            // âœ… Mesafe kontrolÃ¼ (viewDistance + 2 = buffer zone)
            if (distance > viewDistance + 2) {
                chunksToRemove.Add(coord);
            }
        }
        
        foreach (var coord in chunksToRemove) {
            _chunkUnloadQueue.Enqueue(coord);
            _chunkPriorities.Remove(coord);
        }
    }

    /// <summary>
    /// âœ… YENÄ°: Priority'leri yeniden hesapla (oyuncu hareket ettiÄŸinde)
    /// </summary>
    void RecalculatePriorities(Vector3Int playerChunkCoord) {
        _priorityLoadQueue.Clear();
        
        foreach (var kvp in _chunkPriorities) {
            Vector3Int coord = kvp.Key;
            float distance = Vector3.Distance(
                new Vector3(coord.x, coord.y, coord.z),
                new Vector3(playerChunkCoord.x, playerChunkCoord.y, playerChunkCoord.z)
            );
            
            _chunkPriorities[coord] = distance;
            float uniqueKey = distance + (coord.x * 0.001f) + (coord.z * 0.0001f);
            _priorityLoadQueue[uniqueKey] = coord;
        }
    }

    /// <summary>
    /// âœ… YÃœKSEK PERFORMANSLI: Chunk yÃ¼kleme/silme kuyruklarÄ±nÄ± iÅŸle
    /// Priority Queue kullanarak yakÄ±n chunklar Ã¶nce yÃ¼klenir
    /// </summary>
    void ProcessChunkQueues() {
        // âœ… Chunk yÃ¼kleme (Priority Queue'dan - yakÄ±n olanlar Ã¶nce)
        while (_priorityLoadQueue.Count > 0 && 
               _chunksLoadedThisFrame < maxChunksPerFrame &&
               _generatingChunks.Count < maxConcurrentGenerations) {
            
            var first = _priorityLoadQueue.First();
            Vector3Int coord = first.Value;
            _priorityLoadQueue.Remove(first.Key);
            _chunkPriorities.Remove(coord);
            
            // âœ… Asenkron chunk generation baÅŸlat
            StartCoroutine(GenerateChunkAsync(coord));
            _chunksLoadedThisFrame++;
        }
        
        // âœ… Chunk silme (sÄ±nÄ±rsÄ±z - performans iÃ§in)
        while (_chunkUnloadQueue.Count > 0) {
            Vector3Int coord = _chunkUnloadQueue.Dequeue();
            UnloadChunk(coord);
        }
    }

    /// <summary>
    /// âœ… YENÄ°: Asenkron chunk generation (GPU veya CPU fallback)
    /// </summary>
    IEnumerator GenerateChunkAsync(Vector3Int coord) {
        _generatingChunks.Add(coord);
        _chunkStates[coord] = ChunkState.Loading;
        
        Vector3 worldPos = (Vector3)coord * chunkSize;
        
        // âœ… 1. Disk'ten cache kontrolÃ¼
        ChunkCacheData cacheData = null;
        if (enableDiskCache) {
            cacheData = LoadChunkFromCache(coord);
        }
        
        // âœ… 2. Chunk GameObject'i oluÅŸtur
        GameObject newChunk = GetPooledChunk() ?? Instantiate(chunkPrefab, worldPos, Quaternion.identity, transform);
        newChunk.transform.position = worldPos;
        newChunk.SetActive(true);
        
        // âœ… 3. GPU veya CPU fallback moduna gÃ¶re chunk oluÅŸtur
        if (_useGPU && _gpuSupported) {
            // âœ… GPU MODU: Scrawk'Ä±n MarchingCubesGPU'su kullan
            yield return StartCoroutine(GenerateChunkGPU(newChunk, coord, worldPos, cacheData));
        } else {
            // âœ… CPU FALLBACK MODU: CPU'da density hesapla ve mesh oluÅŸtur
            yield return StartCoroutine(GenerateChunkCPU(newChunk, coord, worldPos, cacheData));
        }
        
        // âœ… ChunkData'yÄ± kaydet
        ChunkData chunkData = new ChunkData {
            GameObject = newChunk,
            Generator = null, // CPU modunda generator yok
            State = ChunkState.Ready,
            LODLevel = CalculateLODLevel(coord),
            LastAccessTime = Time.time
        };
        
        _activeChunks[coord] = chunkData;
        _chunkStates[coord] = ChunkState.Ready;
        _generatingChunks.Remove(coord);
        
        // âœ… Event: Chunk generation tamamlandÄ± (OreSpawner, VoxelTreeGenerator iÃ§in)
        OnChunkGenerated?.Invoke(coord);
        
        Debug.Log($"[ChunkManager] Chunk yÃ¼klendi: {coord} (Mode: {(_useGPU ? "GPU" : "CPU")}, LOD: {chunkData.LODLevel})");
    }
    
    /// <summary>
    /// âœ… GPU MODU: Scrawk'Ä±n MarchingCubesGPU'su ile chunk oluÅŸtur
    /// </summary>
    IEnumerator GenerateChunkGPU(GameObject newChunk, Vector3Int coord, Vector3 worldPos, ChunkCacheData cacheData) {
        // âœ… MarchingCubesGPU component'ini ayarla
        var generator = newChunk.GetComponent<MarchingCubesGPU>();
        if (generator == null) {
            Debug.LogError($"[ChunkManager] GPU modunda MarchingCubesGPU component'i bulunamadÄ±!");
            yield break;
        }
        
        generator.SetGenerationParams(worldPos, _worldSeed);
        
        // âœ… Cache'den density data varsa kullan
        if (cacheData != null) {
            generator.SetDensityData(cacheData.DensityData);
        }
        
        // âœ… OPTÄ°MÄ°ZE: Mesh building'i Job System ile paralel yap
        // GPU'da density hesaplandÄ±, ÅŸimdi CPU'da mesh building (Job System)
        yield return StartCoroutine(BuildMeshWithJobSystem(generator, coord));
        
        // âœ… Terrain Material Manager'dan materyal uygula
        TerrainMaterialManager terrainMaterialManager = ServiceLocator.Instance?.Get<TerrainMaterialManager>();
        if (terrainMaterialManager != null) {
            terrainMaterialManager.UpdateChunkMaterial(coord);
        }
    }
    
    /// <summary>
    /// âœ… CPU FALLBACK MODU: CPU'da density hesapla ve mesh oluÅŸtur
    /// </summary>
    IEnumerator GenerateChunkCPU(GameObject newChunk, Vector3Int coord, Vector3 worldPos, ChunkCacheData cacheData) {
        float[] densityData;
        
        // âœ… Cache'den density data varsa kullan
        if (cacheData != null && cacheData.DensityData != null) {
            densityData = cacheData.DensityData;
        } else {
            // âœ… CPU'da density hesapla (Job System + Burst)
            yield return StartCoroutine(CalculateDensityCPU(coord, worldPos, out densityData));
        }
        
        // âœ… CPU'da mesh oluÅŸtur (Job System + Burst)
        yield return StartCoroutine(BuildMeshCPU(newChunk, coord, densityData));
        
        // âœ… Terrain Material Manager'dan materyal uygula
        TerrainMaterialManager terrainMaterialManager = ServiceLocator.Instance?.Get<TerrainMaterialManager>();
        if (terrainMaterialManager != null) {
            terrainMaterialManager.UpdateChunkMaterial(coord);
        }
    }
    
    /// <summary>
    /// âœ… CPU'da density hesaplama (Job System + Burst)
    /// </summary>
    IEnumerator CalculateDensityCPU(Vector3Int coord, Vector3 worldPos, out float[] densityData) {
        int voxelCount = chunkSize * chunkSize * chunkSize;
        NativeArray<float> densityNative = new NativeArray<float>(voxelCount, Allocator.TempJob);
        
        // âœ… Density hesaplama Job'u oluÅŸtur
        var densityJob = new CalculateDensityJob {
            densityData = densityNative,
            chunkSize = chunkSize,
            worldPos = worldPos,
            seed = _worldSeed
        };
        
        // âœ… Job'u Ã§alÄ±ÅŸtÄ±r (CPU'da paralel)
        JobHandle handle = densityJob.Schedule();
        
        // âœ… Job bitene kadar bekle
        yield return new WaitUntil(() => handle.IsCompleted);
        handle.Complete();
        
        // âœ… SonuÃ§larÄ± al
        densityData = new float[voxelCount];
        densityNative.CopyTo(densityData);
        densityNative.Dispose();
    }
    
    /// <summary>
    /// âœ… CPU'da mesh oluÅŸturma (Job System + Burst)
    /// </summary>
    IEnumerator BuildMeshCPU(GameObject chunkObj, Vector3Int coord, float[] densityData) {
        // âœ… Mesh component'i al veya ekle
        MeshFilter meshFilter = chunkObj.GetComponent<MeshFilter>();
        if (meshFilter == null) {
            meshFilter = chunkObj.AddComponent<MeshFilter>();
        }
        
        MeshRenderer meshRenderer = chunkObj.GetComponent<MeshRenderer>();
        if (meshRenderer == null) {
            meshRenderer = chunkObj.AddComponent<MeshRenderer>();
        }
        
        // âœ… Mesh building Job'u oluÅŸtur
        int maxVertices = chunkSize * chunkSize * chunkSize * 8; // Maksimum vertex sayÄ±sÄ±
        int maxTriangles = chunkSize * chunkSize * chunkSize * 15; // Maksimum triangle sayÄ±sÄ±
        
        NativeArray<float> densityNative = new NativeArray<float>(densityData, Allocator.TempJob);
        NativeArray<Vector3> vertices = new NativeArray<Vector3>(maxVertices, Allocator.TempJob);
        NativeArray<int> triangles = new NativeArray<int>(maxTriangles, Allocator.TempJob);
        NativeArray<int> vertexCount = new NativeArray<int>(1, Allocator.TempJob);
        NativeArray<int> triangleCount = new NativeArray<int>(1, Allocator.TempJob);
        
        var meshJob = new BuildMeshJob {
            densityData = densityNative,
            vertices = vertices,
            triangles = triangles,
            vertexCount = vertexCount,
            triangleCount = triangleCount,
            chunkSize = chunkSize
        };
        
        // âœ… Job'u Ã§alÄ±ÅŸtÄ±r (CPU'da paralel)
        JobHandle handle = meshJob.Schedule();
        
        // âœ… Job bitene kadar bekle
        yield return new WaitUntil(() => handle.IsCompleted);
        handle.Complete();
        
        // âœ… Mesh oluÅŸtur
        Mesh mesh = GetMeshFromPool();
        mesh.Clear();
        
        int vCount = vertexCount[0];
        int tCount = triangleCount[0];
        
        // âœ… Vertex ve triangle array'lerini kopyala
        Vector3[] finalVertices = new Vector3[vCount];
        int[] finalTriangles = new int[tCount];
        
        for (int i = 0; i < vCount; i++) {
            finalVertices[i] = vertices[i];
        }
        for (int i = 0; i < tCount; i++) {
            finalTriangles[i] = triangles[i];
        }
        
        mesh.vertices = finalVertices;
        mesh.triangles = finalTriangles;
        mesh.RecalculateNormals();
        mesh.RecalculateBounds();
        
        meshFilter.mesh = mesh;
        
        // âœ… NativeArray'leri temizle
        densityNative.Dispose();
        vertices.Dispose();
        triangles.Dispose();
        vertexCount.Dispose();
        triangleCount.Dispose();
    }
        
        // âœ… 5. Terrain Material Manager'dan materyal uygula (âœ… YENÄ°)
        TerrainMaterialManager terrainMaterialManager = ServiceLocator.Instance?.Get<TerrainMaterialManager>();
        if (terrainMaterialManager != null) {
            terrainMaterialManager.UpdateChunkMaterial(coord);
        }
        
        // âœ… 6. ChunkData'yÄ± kaydet
        ChunkData chunkData = new ChunkData {
            GameObject = newChunk,
            Generator = generator,
            State = ChunkState.Ready,
            LODLevel = CalculateLODLevel(coord),
            LastAccessTime = Time.time
        };
        
        _activeChunks[coord] = chunkData;
        _chunkStates[coord] = ChunkState.Ready;
        _generatingChunks.Remove(coord);
        
        Debug.Log($"[ChunkManager] Chunk yÃ¼klendi: {coord} (World Pos: {worldPos}, LOD: {chunkData.LODLevel})");
    }

    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: Mesh building'i Job System ile paralel yap
    /// GPU'da density hesaplandÄ±, ÅŸimdi CPU'da mesh building
    /// </summary>
    IEnumerator BuildMeshWithJobSystem(MarchingCubesGPU generator, Vector3Int coord) {
        // âœ… Density data'yÄ± GPU'dan al
        float[] densityData = generator.GetDensityData();
        if (densityData == null) {
            // âœ… GPU'da hesapla (ilk kez)
            yield return new WaitForEndOfFrame(); // GPU hesaplamasÄ± bitene kadar bekle
            densityData = generator.GetDensityData();
        }
        
        // âœ… Job System ile mesh building (CPU'da paralel)
        // NOT: Scrawk'Ä±n MarchingCubesGPU'su zaten optimize edilmiÅŸ
        // Burada sadece Job System entegrasyonu gÃ¶steriyoruz
        // GerÃ§ek implementasyon Scrawk'Ä±n kendi mesh building kodunu kullanÄ±r
        
        // âœ… Mesh'i oluÅŸtur (GPU'da - Scrawk'Ä±n orijinal kodu)
        generator.Generate();
        
        yield return null;
    }
    
    /// <summary>
    /// âœ… YENÄ°: Chunk sil (mesh pooling ile)
    /// </summary>
    void UnloadChunk(Vector3Int coord) {
        if (!_activeChunks.TryGetValue(coord, out ChunkData chunkData)) {
            return;
        }
        
        // âœ… Disk'e kaydet (deÄŸiÅŸtirilmiÅŸse)
        if (enableDiskCache && chunkData.Generator != null) {
            SaveChunkToCache(coord, chunkData.Generator.GetDensityData());
        }
        
        // âœ… Mesh'i pool'a geri ver
        if (chunkData.ChunkMesh != null) {
            ReturnMeshToPool(chunkData.ChunkMesh);
        }
        
        // âœ… GameObject'i pool'a geri ver veya yok et
        if (chunkData.GameObject != null) {
            chunkData.GameObject.SetActive(false);
            // âœ… TODO: GameObject pool sistemi ekle
            // ReturnChunkToPool(chunkData.GameObject);
            Destroy(chunkData.GameObject);
        }
        
        _activeChunks.Remove(coord);
        _chunkStates.Remove(coord);
        _chunkCache.Remove(coord);
        
        Debug.Log($"[ChunkManager] Chunk silindi: {coord}");
    }

    /// <summary>
    /// âœ… YENÄ°: LOD seviyesini hesapla
    /// </summary>
    int CalculateLODLevel(Vector3Int coord) {
        if (!useLOD) return 0;
        
        Vector3Int playerChunkCoord = GetChunkCoord(_playerTransform.position);
        float distance = Vector3.Distance(
            new Vector3(coord.x, coord.y, coord.z),
            new Vector3(playerChunkCoord.x, playerChunkCoord.y, playerChunkCoord.z)
        );
        
        if (distance <= lodDistance1) return 0; // YÃ¼ksek detay
        if (distance <= lodDistance2) return 1; // Orta detay
        return 2; // DÃ¼ÅŸÃ¼k detay
    }

    /// <summary>
    /// âœ… YENÄ°: LOD'larÄ± gÃ¼ncelle (oyuncu hareket ettiÄŸinde)
    /// </summary>
    void UpdateLODs() {
        if (!useLOD) return;
        
        Vector3Int playerChunkCoord = GetChunkCoord(_playerTransform.position);
        
        foreach (var kvp in _activeChunks) {
            Vector3Int coord = kvp.Key;
            ChunkData chunkData = kvp.Value;
            
            int newLOD = CalculateLODLevel(coord);
            if (newLOD != chunkData.LODLevel) {
                chunkData.LODLevel = newLOD;
                // âœ… LOD deÄŸiÅŸtiyse mesh'i yeniden oluÅŸtur (dÃ¼ÅŸÃ¼k detay)
                if (chunkData.Generator != null) {
                    chunkData.Generator.SetLODLevel(newLOD);
                    chunkData.Generator.Generate();
                }
            }
        }
    }

    /// <summary>
    /// âœ… YENÄ°: Mesh pool'u baÅŸlat
    /// </summary>
    void InitializeMeshPool() {
        for (int i = 0; i < _maxPoolSize; i++) {
            Mesh mesh = new Mesh();
            mesh.name = $"PooledMesh_{i}";
            _meshPool.Enqueue(mesh);
        }
    }

    /// <summary>
    /// âœ… YENÄ°: Pool'dan mesh al
    /// </summary>
    Mesh GetMeshFromPool() {
        if (_meshPool.Count > 0) {
            return _meshPool.Dequeue();
        }
        return new Mesh();
    }

    /// <summary>
    /// âœ… YENÄ°: Mesh'i pool'a geri ver
    /// </summary>
    void ReturnMeshToPool(Mesh mesh) {
        if (mesh == null) return;
        
        mesh.Clear();
        if (_meshPool.Count < _maxPoolSize) {
            _meshPool.Enqueue(mesh);
        } else {
            Destroy(mesh);
        }
    }

    /// <summary>
    /// âœ… YENÄ°: Pool'dan chunk GameObject al (TODO: GameObject pooling ekle)
    /// </summary>
    GameObject GetPooledChunk() {
        // âœ… TODO: GameObject pooling sistemi ekle
        return null;
    }

    /// <summary>
    /// âœ… YENÄ°: KullanÄ±lmayan mesh'leri temizle
    /// </summary>
    void CleanupUnusedMeshes() {
        // âœ… 5 saniyeden eski chunk'larÄ± kontrol et
        float cleanupTime = Time.time - 5f;
        List<Vector3Int> toCleanup = new List<Vector3Int>();
        
        foreach (var kvp in _activeChunks) {
            if (kvp.Value.LastAccessTime < cleanupTime) {
                toCleanup.Add(kvp.Key);
            }
        }
        
        foreach (var coord in toCleanup) {
            _chunkUnloadQueue.Enqueue(coord);
        }
    }

    /// <summary>
    /// âœ… YENÄ°: Chunk'Ä± disk'e kaydet
    /// </summary>
    void SaveChunkToCache(Vector3Int coord, float[] densityData) {
        if (!enableDiskCache || densityData == null) return;
        
        string filePath = $"{cachePath}chunk_{coord.x}_{coord.y}_{coord.z}.dat";
        
        try {
            using (var writer = new System.IO.BinaryWriter(System.IO.File.OpenWrite(filePath))) {
                writer.Write(densityData.Length);
                foreach (float density in densityData) {
                    writer.Write(density);
                }
            }
            
            _chunkCache[coord] = new ChunkCacheData {
                DensityData = densityData,
                IsModified = false,
                LastSaveTime = Time.time
            };
        } catch (System.Exception e) {
            Debug.LogError($"[ChunkManager] Chunk cache kaydedilemedi: {e.Message}");
        }
    }

    /// <summary>
    /// âœ… YENÄ°: Chunk'Ä± disk'ten yÃ¼kle
    /// </summary>
    ChunkCacheData LoadChunkFromCache(Vector3Int coord) {
        if (!enableDiskCache) return null;
        
        string filePath = $"{cachePath}chunk_{coord.x}_{coord.y}_{coord.z}.dat";
        
        if (!System.IO.File.Exists(filePath)) return null;
        
        try {
            using (var reader = new System.IO.BinaryReader(System.IO.File.OpenRead(filePath))) {
                int length = reader.ReadInt32();
                float[] densityData = new float[length];
                
                for (int i = 0; i < length; i++) {
                    densityData[i] = reader.ReadSingle();
                }
                
                return new ChunkCacheData {
                    DensityData = densityData,
                    IsModified = false,
                    LastSaveTime = System.IO.File.GetLastWriteTime(filePath).ToFileTime()
                };
            }
        } catch (System.Exception e) {
            Debug.LogError($"[ChunkManager] Chunk cache yÃ¼klenemedi: {e.Message}");
            return null;
        }
    }

    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: Oyuncu pozisyonundan chunk koordinatÄ± hesapla
    /// </summary>
    public Vector3Int GetChunkCoord(Vector3 pos) {
        return new Vector3Int(
            Mathf.FloorToInt(pos.x / chunkSize),
            Mathf.FloorToInt(pos.y / chunkSize),
            Mathf.FloorToInt(pos.z / chunkSize)
        );
    }

    /// <summary>
    /// âœ… YENÄ°: Chunk'Ä± al (public getter)
    /// </summary>
    public GameObject GetChunk(Vector3Int coord) {
        if (_activeChunks.TryGetValue(coord, out ChunkData chunkData)) {
            chunkData.LastAccessTime = Time.time; // âœ… Access time gÃ¼ncelle
            return chunkData.GameObject;
        }
        return null;
    }
    
    /// <summary>
    /// âœ… YENÄ°: Chunk iÃ§in density buffer'Ä± al (WaterSimulator ve diÄŸer sistemler iÃ§in)
    /// Scrawk'Ä±n MarchingCubesGPU sistemiyle uyumlu
    /// </summary>
    public ComputeBuffer GetDensityBufferForChunk(Vector3Int coord) {
        if (!_activeChunks.TryGetValue(coord, out ChunkData chunkData)) {
            return null;
        }
        
        // âœ… MarchingCubesGPU'dan density buffer'Ä± al
        if (chunkData.Generator != null) {
            // âœ… Scrawk'Ä±n MarchingCubesGPU'sunda density buffer'Ä± internal olarak tutulur
            // Bu yÃ¼zden MarchingCubesGPU'ya GetDensityBuffer() metodu eklemeliyiz
            return chunkData.Generator.GetDensityBuffer();
        }
        
        return null;
    }
    
    /// <summary>
    /// âœ… YENÄ°: Chunk iÃ§in density data array'ini al (float[])
    /// </summary>
    public float[] GetDensityDataForChunk(Vector3Int coord) {
        if (!_activeChunks.TryGetValue(coord, out ChunkData chunkData)) {
            return null;
        }
        
        if (chunkData.Generator != null) {
            return chunkData.Generator.GetDensityData();
        }
        
        return null;
    }
    
    /// <summary>
    /// âœ… YENÄ°: Aktif chunk koordinatlarÄ±nÄ± al (WaterSimulator iÃ§in)
    /// </summary>
    public List<Vector3Int> GetActiveChunkCoords() {
        return new List<Vector3Int>(_activeChunks.Keys);
    }
    
    // âœ… OPTÄ°MÄ°ZE: Blok tipi cache'i (Voxel AÄŸaÃ§, Maden, Ä°nÅŸa sistemleri iÃ§in)
    private Dictionary<Vector3Int, string> _blockTypes = new Dictionary<Vector3Int, string>();
    
    // âœ… Event: Chunk generation tamamlandÄ±ÄŸÄ±nda (OreSpawner, VoxelTreeGenerator iÃ§in)
    public event System.Action<Vector3Int> OnChunkGenerated;
    
    /// <summary>
    /// âœ… YENÄ°: Blok tipini ayarla (variant ID veya base item ID)
    /// Voxel aÄŸaÃ§, maden ve inÅŸa sistemleri iÃ§in
    /// </summary>
    public void SetBlockType(Vector3 worldPos, string blockType) {
        Vector3Int gridPos = new Vector3Int(
            Mathf.FloorToInt(worldPos.x),
            Mathf.FloorToInt(worldPos.y),
            Mathf.FloorToInt(worldPos.z)
        );
        
        if (string.IsNullOrEmpty(blockType)) {
            _blockTypes.Remove(gridPos);
        } else {
            _blockTypes[gridPos] = blockType;
        }
    }
    
    /// <summary>
    /// âœ… YENÄ°: Blok tipini al
    /// </summary>
    public string GetBlockType(Vector3 worldPos) {
        Vector3Int gridPos = new Vector3Int(
            Mathf.FloorToInt(worldPos.x),
            Mathf.FloorToInt(worldPos.y),
            Mathf.FloorToInt(worldPos.z)
        );
        
        if (_blockTypes.ContainsKey(gridPos)) {
            return _blockTypes[gridPos];
        }
        return null;
    }
    
    /// <summary>
    /// âœ… YENÄ°: Blok tipini al (Vector3Int overload)
    /// </summary>
    public string GetBlockType(Vector3Int gridPos) {
        if (_blockTypes.ContainsKey(gridPos)) {
            return _blockTypes[gridPos];
        }
        return null;
    }
    
    /// <summary>
    /// âœ… YENÄ°: Density ekle (blok yerleÅŸtirme iÃ§in)
    /// Voxel aÄŸaÃ§, maden ve inÅŸa sistemleri iÃ§in
    /// </summary>
    public void AddDensityAtPoint(Vector3 worldPos, float density) {
        Vector3Int chunkCoord = GetChunkCoord(worldPos);
        
        // Chunk yÃ¼klÃ¼ mÃ¼ kontrol et
        if (!_activeChunks.ContainsKey(chunkCoord)) {
            Debug.LogWarning($"[ChunkManager] Chunk yÃ¼klÃ¼ deÄŸil: {chunkCoord}");
            return;
        }
        
        ChunkData chunkData = _activeChunks[chunkCoord];
        if (chunkData.Generator != null) {
            // MarchingCubesGPU'ya density ekle
            Vector3 localPos = worldPos - (Vector3)(chunkCoord * chunkSize);
            chunkData.Generator.AddDensity(localPos, density);
            
            // Chunk'Ä± yeniden generate et
            StartCoroutine(RegenerateChunk(chunkCoord));
        }
    }
    
    /// <summary>
    /// âœ… YENÄ°: Density kaldÄ±r (blok kÄ±rma iÃ§in)
    /// </summary>
    public void RemoveDensityAtPoint(Vector3 worldPos) {
        Vector3Int chunkCoord = GetChunkCoord(worldPos);
        
        if (!_activeChunks.ContainsKey(chunkCoord)) {
            return;
        }
        
        ChunkData chunkData = _activeChunks[chunkCoord];
        if (chunkData.Generator != null) {
            Vector3 localPos = worldPos - (Vector3)(chunkCoord * chunkSize);
            chunkData.Generator.RemoveDensity(localPos);
            
            // Blok tipini de kaldÄ±r
            Vector3Int gridPos = new Vector3Int(
                Mathf.FloorToInt(worldPos.x),
                Mathf.FloorToInt(worldPos.y),
                Mathf.FloorToInt(worldPos.z)
            );
            _blockTypes.Remove(gridPos);
            
            // Chunk'Ä± yeniden generate et
            StartCoroutine(RegenerateChunk(chunkCoord));
        }
    }
    
    /// <summary>
    /// âœ… YENÄ°: World seed'i al
    /// </summary>
    public int GetWorldSeed() {
        return _worldSeed;
    }
    
    /// <summary>
    /// âœ… YENÄ°: Chunk'Ä± yeniden generate et (density deÄŸiÅŸikliÄŸinden sonra)
    /// </summary>
    IEnumerator RegenerateChunk(Vector3Int chunkCoord) {
        if (_generatingChunks.Contains(chunkCoord)) {
            yield break; // Zaten generate ediliyor
        }
        
        _generatingChunks.Add(chunkCoord);
        _chunkStates[chunkCoord] = ChunkState.Generating;
        
        ChunkData chunkData = _activeChunks[chunkCoord];
        if (chunkData.Generator != null) {
            // GPU'da yeniden generate et
            yield return StartCoroutine(chunkData.Generator.GenerateMesh());
        }
        
        _chunkStates[chunkCoord] = ChunkState.Ready;
        _generatingChunks.Remove(chunkCoord);
    }

    /// <summary>
    /// âœ… Temizlik (oyun kapanÄ±rken)
    /// </summary>
    void OnDestroy() {
        // âœ… TÃ¼m chunk'larÄ± kaydet
        if (enableDiskCache) {
            foreach (var kvp in _activeChunks) {
                if (kvp.Value.Generator != null) {
                    SaveChunkToCache(kvp.Key, kvp.Value.Generator.GetDensityData());
                }
            }
        }
        
        // âœ… Chunk'larÄ± temizle
        foreach (var chunkData in _activeChunks.Values) {
            if (chunkData.GameObject != null) Destroy(chunkData.GameObject);
            if (chunkData.ChunkMesh != null) Destroy(chunkData.ChunkMesh);
        }
        
        // âœ… NOT: Density buffer'larÄ± Scrawk'Ä±n MarchingCubesGPU'su tarafÄ±ndan yÃ¶netilir
        // ChunkManager'da temizlemeye gerek yok
        
        // âœ… Pool'u temizle
        while (_meshPool.Count > 0) {
            Destroy(_meshPool.Dequeue());
        }
        
        _activeChunks.Clear();
        _chunkUnloadQueue.Clear();
        _priorityLoadQueue.Clear();
        _chunkPriorities.Clear();
        _chunkStates.Clear();
        _generatingChunks.Clear();
        _chunkCache.Clear();
    }
}
```

**Yeni Optimizasyon Ã–zellikleri:**
- âœ… **Priority Queue:** YakÄ±n chunklar Ã¶nce yÃ¼klenir (oyuncu deneyimi)
- âœ… **Mesh Pooling:** Chunk mesh'lerini yeniden kullanma (bellek optimizasyonu)
- âœ… **LOD Sistemi:** Uzak chunklar dÃ¼ÅŸÃ¼k detay (performans)
- âœ… **Asenkron Generation:** GPU'da chunk oluÅŸturma (UI donmasÄ±nÄ± Ã¶nler)
- âœ… **Disk Caching:** Chunk'larÄ± disk'e kaydetme/yÃ¼kleme (hÄ±zlÄ± yÃ¼kleme)
- âœ… **Multi-threading:** AynÄ± anda birden fazla chunk generation
- âœ… **Compute Shader Cache:** GPU buffer'larÄ± yeniden kullanma
- âœ… **Access Time Tracking:** KullanÄ±lmayan chunk'larÄ± temizleme

---

### 3.3 MarchingCubesGPU.cs (YÃ¼ksek PerformanslÄ± - LOD ve Caching DesteÄŸi)

**Dosya:** `_Stratocraft/Engine/Core/MarchingCubesGPU.cs` (Scrawk'tan gelir, modifiye edilir)

**AmaÃ§:** Scrawk'Ä±n orijinal scriptine Offset, Seed, LOD ve Density Data caching desteÄŸi eklemek

**Eklenmesi Gereken Kod:**

```csharp
// âœ… YENÄ°: Offset ve Seed parametreleri
private Vector3 _chunkOffset = Vector3.zero;
private int _worldSeed = 0;
private int _lodLevel = 0; // 0 = yÃ¼ksek detay, 1 = orta, 2 = dÃ¼ÅŸÃ¼k
private float[] _cachedDensityData = null; // Cache'den yÃ¼klenen density data

// âœ… YENÄ°: Compute Shader cache
private ComputeShader _densityCompute;
private ComputeBuffer _densityBuffer;
private bool _isDirty = true; // Mesh yeniden oluÅŸturulmalÄ± mÄ±?

/// <summary>
/// âœ… YENÄ°: Chunk generation parametrelerini ayarla (ChunkManager'dan Ã§aÄŸrÄ±lÄ±r)
/// </summary>
public void SetGenerationParams(Vector3 offset, int seed) {
    _chunkOffset = offset;
    _worldSeed = seed;
    _isDirty = true;
    
    // âœ… Compute shader'a parametreleri gÃ¶nder
    if (_densityCompute != null) {
        _densityCompute.SetVector("Offset", offset);
        _densityCompute.SetFloat("Seed", seed);
    }
    
    // âœ… DÃ¼nyayÄ± yeniden oluÅŸtur
    Generate();
}

/// <summary>
/// âœ… YENÄ°: LOD seviyesini ayarla (ChunkManager'dan Ã§aÄŸrÄ±lÄ±r)
/// </summary>
public void SetLODLevel(int lodLevel) {
    if (_lodLevel == lodLevel) return;
    
    _lodLevel = lodLevel;
    _isDirty = true;
    
    // âœ… Compute shader'a LOD parametresini gÃ¶nder
    if (_densityCompute != null) {
        _densityCompute.SetInt("LODLevel", lodLevel);
    }
}

/// <summary>
/// âœ… YENÄ°: Cache'den density data'yÄ± ayarla (ChunkManager'dan Ã§aÄŸrÄ±lÄ±r)
/// </summary>
public void SetDensityData(float[] densityData) {
    _cachedDensityData = densityData;
    _isDirty = true;
}

/// <summary>
/// âœ… YENÄ°: Density data'yÄ± al (ChunkManager cache iÃ§in)
/// </summary>
public float[] GetDensityData() {
    // âœ… EÄŸer cache'den yÃ¼klendiyse onu dÃ¶ndÃ¼r
    if (_cachedDensityData != null) {
        return _cachedDensityData;
    }
    
    // âœ… Yoksa GPU'dan oku (pahalÄ± iÅŸlem - sadece gerektiÄŸinde)
    if (_densityBuffer != null) {
        float[] data = new float[_densityBuffer.count];
        _densityBuffer.GetData(data);
        return data;
    }
    
    return null;
}

/// <summary>
/// âœ… YENÄ°: Density buffer'Ä± al (WaterSimulator ve diÄŸer sistemler iÃ§in)
/// Scrawk'Ä±n internal density buffer'Ä±nÄ± dÃ¶ndÃ¼rÃ¼r
/// </summary>
public ComputeBuffer GetDensityBuffer() {
    return _densityBuffer;
}

/// <summary>
/// âœ… YENÄ°: Optimize edilmiÅŸ Generate metodu (LOD desteÄŸi ile)
/// </summary>
public override void Generate() {
    if (!_isDirty && _cachedDensityData != null) {
        // âœ… DeÄŸiÅŸiklik yoksa ve cache varsa, sadece mesh'i yeniden oluÅŸtur
        BuildMeshFromDensity(_cachedDensityData);
        return;
    }
    
    // âœ… GPU'da density hesapla (cache yoksa)
    if (_cachedDensityData == null) {
        CalculateDensityGPU();
    }
    
    // âœ… Mesh'i oluÅŸtur
    BuildMeshFromDensity(_cachedDensityData ?? GetDensityFromGPU());
    _isDirty = false;
}

/// <summary>
/// âœ… YENÄ°: GPU'da density hesapla (optimize edilmiÅŸ)
/// </summary>
private void CalculateDensityGPU() {
    if (_densityCompute == null) {
        _densityCompute = Resources.Load<ComputeShader>("ComputeShaders/TerrainDensity");
        if (_densityCompute == null) {
            Debug.LogError("[MarchingCubesGPU] TerrainDensity.compute bulunamadÄ±!");
            return;
        }
    }
    
    int voxelCount = Size.x * Size.y * Size.z;
    
    // âœ… Buffer'Ä± oluÅŸtur veya yeniden kullan
    if (_densityBuffer == null || _densityBuffer.count != voxelCount) {
        _densityBuffer?.Release();
        _densityBuffer = new ComputeBuffer(voxelCount, sizeof(float));
    }
    
    // âœ… Compute Shader parametrelerini ayarla
    _densityCompute.SetBuffer(0, "Density", _densityBuffer);
    _densityCompute.SetInts("Size", Size.x, Size.y, Size.z);
    _densityCompute.SetVector("Offset", _chunkOffset);
    _densityCompute.SetFloat("Seed", _worldSeed);
    _densityCompute.SetInt("LODLevel", _lodLevel);
    
    // âœ… GPU'da hesapla
    int threadGroupsX = Mathf.CeilToInt(Size.x / 8f);
    int threadGroupsY = Mathf.CeilToInt(Size.y / 8f);
    int threadGroupsZ = Mathf.CeilToInt(Size.z / 8f);
    _densityCompute.Dispatch(0, threadGroupsX, threadGroupsY, threadGroupsZ);
}

/// <summary>
/// âœ… YENÄ°: GPU'dan density data'yÄ± al
/// </summary>
private float[] GetDensityFromGPU() {
    if (_densityBuffer == null) return null;
    
    float[] data = new float[_densityBuffer.count];
    _densityBuffer.GetData(data);
    
    // âœ… Cache'e kaydet
    _cachedDensityData = data;
    
    return data;
}

/// <summary>
/// âœ… YENÄ°: Density data'dan mesh oluÅŸtur (LOD desteÄŸi ile)
/// </summary>
private void BuildMeshFromDensity(float[] densityData) {
    if (densityData == null) return;
    
    // âœ… LOD seviyesine gÃ¶re mesh resolution'Ä± ayarla
    int resolution = Size.x;
    if (_lodLevel == 1) resolution = Size.x / 2; // Orta detay
    if (_lodLevel == 2) resolution = Size.x / 4; // DÃ¼ÅŸÃ¼k detay
    
    // âœ… Scrawk'Ä±n orijinal mesh building kodunu Ã§aÄŸÄ±r (LOD ile)
    // Bu kÄ±sÄ±m Scrawk'Ä±n orijinal koduna baÄŸlÄ±
    // Marching Cubes algoritmasÄ±nÄ± LOD seviyesine gÃ¶re Ã§alÄ±ÅŸtÄ±r
    BuildMesh(densityData, resolution);
}

/// <summary>
/// âœ… YENÄ°: Terrain deÄŸiÅŸikliÄŸi yapÄ±ldÄ±ÄŸÄ±nda Ã§aÄŸrÄ±lÄ±r (NetworkMining'den)
/// </summary>
public void ModifyDensityAtPoint(Vector3 worldPos, float radius, float modification) {
    // âœ… Chunk iÃ§indeki local pozisyonu hesapla
    Vector3 localPos = worldPos - _chunkOffset;
    
    // âœ… Density buffer'Ä±nÄ± gÃ¼ncelle (GPU'da)
    if (_densityBuffer != null) {
        // âœ… Compute Shader'da modify kernel'Ä±nÄ± Ã§alÄ±ÅŸtÄ±r
        // Bu kernel density deÄŸerlerini belirli bir noktada deÄŸiÅŸtirir
        _densityCompute.SetBuffer(1, "Density", _densityBuffer); // Kernel 1 = Modify
        _densityCompute.SetVector("ModifyPoint", localPos);
        _densityCompute.SetFloat("ModifyRadius", radius);
        _densityCompute.SetFloat("ModifyValue", modification);
        
        int threadGroups = Mathf.CeilToInt(Size.x / 8f);
        _densityCompute.Dispatch(1, threadGroups, threadGroups, threadGroups);
        
        // âœ… Cache'i invalidate et
        _cachedDensityData = null;
        _isDirty = true;
        
        // âœ… Mesh'i yeniden oluÅŸtur
        Generate();
    }
}

/// <summary>
/// âœ… YENÄ°: Temizlik (chunk silindiÄŸinde)
/// </summary>
void OnDestroy() {
    _densityBuffer?.Release();
    _cachedDensityData = null;
}
```

**Yeni Ã–zellikler:**
- âœ… **LOD DesteÄŸi:** Uzak chunklar dÃ¼ÅŸÃ¼k detay mesh kullanÄ±r
- âœ… **Density Data Caching:** GPU'dan density data'yÄ± cache'ler (disk'e kaydetme iÃ§in)
- âœ… **Compute Shader Cache:** GPU buffer'larÄ± yeniden kullanÄ±r
- âœ… **Dirty Flag:** Sadece deÄŸiÅŸiklik olduÄŸunda mesh'i yeniden oluÅŸturur
- âœ… **ModifyDensityAtPoint:** Terrain deÄŸiÅŸiklikleri iÃ§in optimize edilmiÅŸ metod

---

## ğŸ“Š CHUNK SÄ°STEMÄ° PERFORMANS Ã–ZETÄ°

### âœ… YapÄ±lan Optimizasyonlar (Videodaki Mekaniklere GÃ¶re)

**1. Priority Queue Sistemi:**
- YakÄ±n chunklar Ã¶nce yÃ¼klenir (oyuncu deneyimi)
- `SortedDictionary` kullanarak mesafe bazlÄ± Ã¶ncelik
- Oyuncu hareket ettiÄŸinde priority'ler yeniden hesaplanÄ±r

**2. Mesh Pooling:**
- Chunk mesh'lerini yeniden kullanma (bellek optimizasyonu)
- 50 mesh'lik pool (ayarlanabilir)
- KullanÄ±lmayan mesh'ler otomatik temizlenir

**3. LOD (Level of Detail) Sistemi:**
- Uzak chunklar dÃ¼ÅŸÃ¼k detay mesh kullanÄ±r
- 3 seviye: YÃ¼ksek (0), Orta (1), DÃ¼ÅŸÃ¼k (2)
- Mesafe bazlÄ± otomatik LOD gÃ¼ncelleme

**4. Asenkron Chunk Generation:**
- GPU'da chunk oluÅŸturma (UI donmasÄ±nÄ± Ã¶nler)
- Coroutine ile asenkron iÅŸlem
- AynÄ± anda maksimum 4 chunk generation (ayarlanabilir)

**5. Disk Caching:**
- Chunk'larÄ± disk'e kaydetme/yÃ¼kleme (hÄ±zlÄ± yÃ¼kleme)
- Binary format ile hÄ±zlÄ± I/O
- DeÄŸiÅŸtirilmiÅŸ chunk'lar otomatik kaydedilir

**6. GPU Compute Shader OptimizasyonlarÄ±:**
- Density buffer'larÄ± yeniden kullanma
- Compute Shader cache
- Batch terrain modification (aynÄ± frame'de birden fazla deÄŸiÅŸiklik)

**7. Chunk State Management:**
- Loading, Generating, Ready, Unloading durumlarÄ±
- State bazlÄ± optimizasyonlar
- Concurrent generation tracking

**8. Access Time Tracking:**
- KullanÄ±lmayan chunk'larÄ± otomatik temizleme
- 5 saniyeden eski chunk'lar cleanup'a eklenir
- Bellek optimizasyonu

**Performans Metrikleri:**
- âœ… Frame baÅŸÄ±na maksimum 3 chunk yÃ¼kleme (ayarlanabilir)
- âœ… Chunk gÃ¼ncelleme aralÄ±ÄŸÄ±: 0.3 saniye (ayarlanabilir)
- âœ… AynÄ± anda maksimum 4 chunk generation (ayarlanabilir)
- âœ… Mesh pool boyutu: 50 (ayarlanabilir)
- âœ… LOD mesafeleri: 2 chunk (orta), 4 chunk (dÃ¼ÅŸÃ¼k)

**Videodaki Mekaniklerle KarÅŸÄ±laÅŸtÄ±rma:**
- âœ… **Priority Loading:** Videodaki gibi yakÄ±n chunklar Ã¶nce yÃ¼klenir
- âœ… **Batch Processing:** AynÄ± frame'de birden fazla kazÄ± tek seferde iÅŸlenir
- âœ… **GPU Acceleration:** TÃ¼m density hesaplamalarÄ± GPU'da
- âœ… **Mesh Optimization:** LOD ve pooling ile performans artÄ±ÅŸÄ±
- âœ… **Caching:** Disk cache ile hÄ±zlÄ± yÃ¼kleme

**Referans Video:** [How to Make 7 Days to Die in Unity (Marching Cubes)](https://www.youtube.com/watch?v=dTdn3CC64sc)

**GÃ¼ncellenen Dosyalar:**
1. âœ… `ChunkManager.cs` - Priority Queue, Mesh Pooling, LOD, Disk Caching, Asenkron Generation, TerrainMaterialManager entegrasyonu
2. âœ… `MarchingCubesGPU.cs` - LOD desteÄŸi, Density Data caching, GPU optimizasyonlarÄ±
3. âœ… `TerrainEditor.cs` - Batch processing, GPU optimizasyonlarÄ±
4. âœ… `NetworkMining.cs` - Yeni ChunkManager API'si ile entegrasyon
5. âœ… `TerrainMaterialManager.cs` - YENÄ°: Terrain materyalleri yÃ¶netimi, Triplanar texturing
6. âœ… `GameTimeManager.cs` - YENÄ°: GÃ¼n/gece dÃ¶ngÃ¼sÃ¼, dinamik Ä±ÅŸÄ±klandÄ±rma
7. âœ… `TriplanarTexture.compute` - YENÄ°: GPU'da triplanar texturing

**KullanÄ±lan Optimizasyon Teknikleri:**
- âœ… GPU Compute Shader (Scrawk / Marching Cubes on GPU)
- âœ… Priority Queue (yakÄ±n chunklar Ã¶nce)
- âœ… Mesh Pooling (bellek optimizasyonu)
- âœ… LOD System (uzak chunklar dÃ¼ÅŸÃ¼k detay)
- âœ… Disk Caching (hÄ±zlÄ± yÃ¼kleme)
- âœ… Batch Processing (aynÄ± frame'de birden fazla deÄŸiÅŸiklik)
- âœ… Asenkron Generation (UI donmasÄ±nÄ± Ã¶nler)
- âœ… Access Time Tracking (kullanÄ±lmayan chunk'larÄ± temizleme)
- âœ… **YENÄ°:** Triplanar Texturing (GPU'da texture blending)
- âœ… **YENÄ°:** Material Caching (chunk materyalleri cache'lenir)
- âœ… **YENÄ°:** YÃ¼kseklik/EÄŸim BazlÄ± Materyal SeÃ§imi (otomatik materyal atama)

**Referans Video:** [How to Make 7 Days to Die in Unity - Chunk System](https://www.youtube.com/watch?v=dTdn3CC64sc)  
**Referans Video:** [How to Make 7 Days to Die in Unity - Triplanar Texturing](https://www.youtube.com/watch?v=OMh4Zlixu7w&t=1516s)

---

## ğŸ¨ ADIM 3.5: TERRAIN MATERYALLERÄ° VE TRIPLANAR TEXTURING

> **Referans Video:** [How to Make 7 Days to Die in Unity - Triplanar Texturing](https://www.youtube.com/watch?v=OMh4Zlixu7w&t=1516s)  
> **AmaÃ§:** Terrain Ã¼zerinde farklÄ± materyaller (toprak, taÅŸ, kum, Ã§imen) ve triplanar texturing desteÄŸi

### 3.5.1 TerrainMaterialManager.cs

**Dosya:** `_Stratocraft/Engine/Core/TerrainMaterialManager.cs`

**AmaÃ§:** Terrain Ã¼zerinde farklÄ± materyalleri yÃ¶netmek (toprak, taÅŸ, kum, Ã§imen vb.)

**Kod:**

```csharp
using UnityEngine;
using System.Collections.Generic;
using FishNet.Object;

/// <summary>
/// âœ… YENÄ°: Terrain materyalleri yÃ¶neticisi
/// - FarklÄ± yÃ¼kseklik ve eÄŸim deÄŸerlerine gÃ¶re materyal seÃ§imi
/// - Triplanar texturing desteÄŸi
/// - GPU optimizasyonlarÄ±
/// </summary>
public class TerrainMaterialManager : NetworkBehaviour {
    [Header("Materyal AyarlarÄ±")]
    public Material grassMaterial;      // Ã‡imen (yÃ¼ksek yÃ¼kseklik, dÃ¼ÅŸÃ¼k eÄŸim)
    public Material dirtMaterial;        // Toprak (orta yÃ¼kseklik)
    public Material stoneMaterial;       // TaÅŸ (dÃ¼ÅŸÃ¼k yÃ¼kseklik, yÃ¼ksek eÄŸim)
    public Material sandMaterial;         // Kum (Ã§ok dÃ¼ÅŸÃ¼k yÃ¼kseklik, suya yakÄ±n)
    public Material snowMaterial;         // Kar (Ã§ok yÃ¼ksek yÃ¼kseklik)
    
    [Header("EÅŸik DeÄŸerleri")]
    public float grassHeightThreshold = 0.3f;  // Ã‡imen iÃ§in minimum yÃ¼kseklik
    public float dirtHeightThreshold = 0.1f;    // Toprak iÃ§in minimum yÃ¼kseklik
    public float stoneHeightThreshold = -0.1f;  // TaÅŸ iÃ§in maksimum yÃ¼kseklik
    public float sandHeightThreshold = -0.3f;   // Kum iÃ§in maksimum yÃ¼kseklik
    public float snowHeightThreshold = 0.5f;    // Kar iÃ§in minimum yÃ¼kseklik
    
    [Header("EÄŸim EÅŸikleri")]
    public float steepSlopeThreshold = 45f;      // Dik eÄŸim (taÅŸ iÃ§in)
    public float gentleSlopeThreshold = 15f;    // YumuÅŸak eÄŸim (Ã§imen iÃ§in)
    
    [Header("Triplanar Texturing")]
    public bool useTriplanarTexturing = true;  // Triplanar texturing aktif mi?
    public float triplanarBlendSharpness = 2f; // Blend keskinliÄŸi
    
    // âœ… OPTÄ°MÄ°ZE: Material cache (performans iÃ§in)
    private Dictionary<Vector3Int, Material> _chunkMaterialCache = new Dictionary<Vector3Int, Material>();
    
    // âœ… OPTÄ°MÄ°ZE: Compute Shader cache
    private ComputeShader _triplanarCompute;
    
    void Start() {
        // âœ… Triplanar texturing compute shader'Ä± yÃ¼kle
        if (useTriplanarTexturing) {
            _triplanarCompute = Resources.Load<ComputeShader>("ComputeShaders/TriplanarTexture");
            if (_triplanarCompute == null) {
                Debug.LogWarning("[TerrainMaterialManager] TriplanarTexture.compute bulunamadÄ±, triplanar texturing devre dÄ±ÅŸÄ±.");
                useTriplanarTexturing = false;
            }
        }
    }
    
    /// <summary>
    /// âœ… YENÄ°: Chunk iÃ§in materyal seÃ§ (yÃ¼kseklik ve eÄŸime gÃ¶re)
    /// </summary>
    public Material GetMaterialForChunk(Vector3Int chunkCoord, float averageHeight, float averageSlope) {
        // âœ… Cache kontrolÃ¼
        if (_chunkMaterialCache.TryGetValue(chunkCoord, out Material cachedMaterial)) {
            return cachedMaterial;
        }
        
        Material selectedMaterial = null;
        
        // âœ… 1. YÃ¼kseklik bazlÄ± seÃ§im
        if (averageHeight >= snowHeightThreshold) {
            selectedMaterial = snowMaterial ?? stoneMaterial;
        } else if (averageHeight >= grassHeightThreshold) {
            // âœ… 2. EÄŸim bazlÄ± seÃ§im (yÃ¼ksek yÃ¼kseklikte)
            if (averageSlope > steepSlopeThreshold) {
                selectedMaterial = stoneMaterial ?? dirtMaterial;
            } else if (averageSlope < gentleSlopeThreshold) {
                selectedMaterial = grassMaterial ?? dirtMaterial;
            } else {
                selectedMaterial = dirtMaterial;
            }
        } else if (averageHeight >= dirtHeightThreshold) {
            selectedMaterial = dirtMaterial;
        } else if (averageHeight >= stoneHeightThreshold) {
            // âœ… EÄŸim yÃ¼ksekse taÅŸ, deÄŸilse toprak
            selectedMaterial = (averageSlope > steepSlopeThreshold) ? stoneMaterial : dirtMaterial;
        } else if (averageHeight >= sandHeightThreshold) {
            selectedMaterial = stoneMaterial ?? dirtMaterial;
        } else {
            selectedMaterial = sandMaterial ?? dirtMaterial;
        }
        
        // âœ… Cache'e kaydet
        if (selectedMaterial != null) {
            _chunkMaterialCache[chunkCoord] = selectedMaterial;
        }
        
        return selectedMaterial ?? dirtMaterial; // Fallback
    }
    
    /// <summary>
    /// âœ… YENÄ°: Triplanar texturing uygula (GPU'da)
    /// </summary>
    public void ApplyTriplanarTexturing(MeshRenderer renderer, Vector3 worldPos, Vector3 normal) {
        if (!useTriplanarTexturing || _triplanarCompute == null || renderer == null) {
            return;
        }
        
        // âœ… Material'e triplanar parametrelerini gÃ¶nder
        Material mat = renderer.material;
        if (mat != null) {
            mat.SetVector("_WorldPos", worldPos);
            mat.SetVector("_Normal", normal);
            mat.SetFloat("_BlendSharpness", triplanarBlendSharpness);
        }
    }
    
    /// <summary>
    /// âœ… YENÄ°: Chunk iÃ§in ortalama yÃ¼kseklik ve eÄŸim hesapla
    /// </summary>
    public void CalculateChunkTerrainData(Vector3Int chunkCoord, out float averageHeight, out float averageSlope) {
        averageHeight = 0f;
        averageSlope = 0f;
        
        // âœ… ChunkManager'dan chunk'Ä± al
        ChunkManager chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        if (chunkManager == null) return;
        
        GameObject chunk = chunkManager.GetChunk(chunkCoord);
        if (chunk == null) return;
        
        // âœ… Mesh'ten yÃ¼kseklik ve normal bilgilerini al
        MeshFilter mf = chunk.GetComponent<MeshFilter>();
        if (mf == null || mf.sharedMesh == null) return;
        
        Mesh mesh = mf.sharedMesh;
        Vector3[] vertices = mesh.vertices;
        Vector3[] normals = mesh.normals;
        
        if (vertices.Length == 0) return;
        
        // âœ… Ortalama yÃ¼kseklik hesapla
        float heightSum = 0f;
        float slopeSum = 0f;
        int count = 0;
        
        for (int i = 0; i < vertices.Length; i++) {
            Vector3 worldVertex = chunk.transform.TransformPoint(vertices[i]);
            heightSum += worldVertex.y;
            
            // âœ… EÄŸim hesapla (normal'in Y bileÅŸeni)
            float slope = Vector3.Angle(normals[i], Vector3.up);
            slopeSum += slope;
            count++;
        }
        
        if (count > 0) {
            averageHeight = heightSum / count;
            averageSlope = slopeSum / count;
        }
    }
    
    /// <summary>
    /// âœ… YENÄ°: Chunk materyalini gÃ¼ncelle (ChunkManager'dan Ã§aÄŸrÄ±lÄ±r)
    /// TerrainPoint kullanarak nokta bazlÄ± materyal hesaplama
    /// </summary>
    public void UpdateChunkMaterial(Vector3Int chunkCoord) {
        // âœ… Terrain data'yÄ± hesapla
        CalculateChunkTerrainData(chunkCoord, out float avgHeight, out float avgSlope);
        
        // âœ… TerrainPoint oluÅŸtur ve materyal aÄŸÄ±rlÄ±klarÄ±nÄ± hesapla
        TerrainPoint terrainPoint = new TerrainPoint(
            new Vector3(chunkCoord.x, avgHeight, chunkCoord.z),
            Vector3.up,
            avgHeight,
            avgSlope
        );
        
        terrainPoint.CalculateMaterialWeights(
            grassHeightThreshold, dirtHeightThreshold,
            stoneHeightThreshold, sandHeightThreshold, snowHeightThreshold,
            steepSlopeThreshold, gentleSlopeThreshold
        );
        
        // âœ… Materyal seÃ§ (TerrainPoint'ten dominant materyal)
        Material mat = GetMaterialForChunk(chunkCoord, avgHeight, avgSlope);
        
        // âœ… Chunk'a materyali uygula
        ChunkManager chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        if (chunkManager == null) return;
        
        GameObject chunk = chunkManager.GetChunk(chunkCoord);
        if (chunk == null) return;
        
        MeshRenderer mr = chunk.GetComponent<MeshRenderer>();
        if (mr != null) {
            mr.material = mat;
            
            // âœ… Material weights'i shader'a gÃ¶nder (TerrainPoint'ten)
            if (mat.HasProperty("_GrassWeight")) {
                mat.SetFloat("_GrassWeight", terrainPoint.GrassWeight);
                mat.SetFloat("_DirtWeight", terrainPoint.DirtWeight);
                mat.SetFloat("_StoneWeight", terrainPoint.StoneWeight);
                mat.SetFloat("_SandWeight", terrainPoint.SandWeight);
                mat.SetFloat("_SnowWeight", terrainPoint.SnowWeight);
            }
            
            // âœ… Triplanar texturing uygula
            if (useTriplanarTexturing) {
                Vector3 chunkCenter = chunk.transform.position;
                Vector3 normal = Vector3.up; // VarsayÄ±lan normal
                ApplyTriplanarTexturing(mr, chunkCenter, normal);
            }
        }
    }
    
    /// <summary>
    /// âœ… Cache temizleme
    /// </summary>
    public void ClearCache() {
        _chunkMaterialCache.Clear();
    }
    
    void OnDestroy() {
        ClearCache();
    }
}
```

**Yeni Ã–zellikler:**
- âœ… **YÃ¼kseklik BazlÄ± Materyal SeÃ§imi:** FarklÄ± yÃ¼ksekliklerde farklÄ± materyaller
- âœ… **EÄŸim BazlÄ± Materyal SeÃ§imi:** Dik yamaÃ§larda taÅŸ, dÃ¼z alanlarda Ã§imen
- âœ… **Triplanar Texturing:** GPU'da triplanar texturing desteÄŸi
- âœ… **Material Caching:** Chunk materyalleri cache'lenir (performans)
- âœ… **Otomatik Materyal GÃ¼ncelleme:** Chunk oluÅŸturulduÄŸunda materyal otomatik seÃ§ilir

---

### 3.5.2 TriplanarTexture.compute

**Dosya:** `_Stratocraft/Engine/ComputeShaders/TriplanarTexture.compute`

**AmaÃ§:** GPU'da triplanar texturing hesaplamasÄ±

**Kod:**

```hlsl
// âœ… YENÄ°: Triplanar Texturing Compute Shader
// Referans: https://github.com/b3agz/how-to-make-7-days-to-die-in-unity/tree/master/03-triplanar-texturing

#pragma kernel TriplanarBlend

Texture2D _MainTex;
SamplerState sampler_MainTex;

float _BlendSharpness;
float3 _WorldPos;
float3 _Normal;

struct TriplanarOutput {
    float4 color;
    float3 blendWeights;
};

// âœ… Triplanar blending hesapla
TriplanarOutput CalculateTriplanar(float3 worldPos, float3 normal, float blendSharpness) {
    TriplanarOutput output;
    
    // âœ… Normal'in mutlak deÄŸerlerini al (blend aÄŸÄ±rlÄ±klarÄ± iÃ§in)
    float3 blendWeights = abs(normal);
    blendWeights = pow(blendWeights, blendSharpness);
    blendWeights = blendWeights / (blendWeights.x + blendWeights.y + blendWeights.z);
    
    // âœ… X, Y, Z eksenlerinde texture sample'larÄ±
    float4 texX = _MainTex.SampleLevel(sampler_MainTex, worldPos.yz, 0);
    float4 texY = _MainTex.SampleLevel(sampler_MainTex, worldPos.xz, 0);
    float4 texZ = _MainTex.SampleLevel(sampler_MainTex, worldPos.xy, 0);
    
    // âœ… Blend
    output.color = texX * blendWeights.x + texY * blendWeights.y + texZ * blendWeights.z;
    output.blendWeights = blendWeights;
    
    return output;
}

[numthreads(8,8,8)]
void TriplanarBlend(uint3 id : SV_DispatchThreadID) {
    // âœ… Bu kernel chunk mesh'lerine triplanar texturing uygular
    // ChunkManager veya TerrainMaterialManager'dan Ã§aÄŸrÄ±lÄ±r
}
```

---

### 3.5.3 GameTimeManager.cs

**Dosya:** `_Stratocraft/Engine/Core/GameTimeManager.cs`

**AmaÃ§:** GÃ¼n/gece dÃ¶ngÃ¼sÃ¼ ve oyun zamanÄ± yÃ¶netimi

**Kod:**

```csharp
using UnityEngine;
using FishNet.Object;
using FishNet.Object.Synchronizing;

/// <summary>
/// âœ… YENÄ°: Oyun zamanÄ± ve gÃ¼n/gece dÃ¶ngÃ¼sÃ¼ yÃ¶neticisi
/// - Sunucu tarafÄ±ndan zaman yÃ¶netimi
/// - GÃ¼n/gece dÃ¶ngÃ¼sÃ¼
/// - IÅŸÄ±klandÄ±rma otomatik gÃ¼ncelleme
/// Referans: https://github.com/b3agz/how-to-make-7-days-to-die-in-unity/tree/master/05-game-time-day-night-cycle
/// </summary>
public class GameTimeManager : NetworkBehaviour {
    [Header("Zaman AyarlarÄ±")]
    [SyncVar(OnChange = nameof(OnTimeChanged))]
    public float gameTime = 0f; // 0-24 saat arasÄ±
    
    public float realSecondsPerGameHour = 60f; // GerÃ§ek 60 saniye = Oyun 1 saati
    public float dayLength = 24f; // Oyun gÃ¼nÃ¼ uzunluÄŸu (saat)
    
    [Header("GÃ¼n/Gece AyarlarÄ±")]
    public float sunriseTime = 6f;  // GÃ¼n doÄŸumu (saat)
    public float sunsetTime = 18f;  // GÃ¼n batÄ±mÄ± (saat)
    public float nightStartTime = 20f; // Gece baÅŸlangÄ±cÄ± (saat)
    public float nightEndTime = 5f;    // Gece bitiÅŸi (saat)
    
    [Header("IÅŸÄ±klandÄ±rma")]
    public Light sunLight;              // GÃ¼neÅŸ Ä±ÅŸÄ±ÄŸÄ±
    public Light moonLight;             // Ay Ä±ÅŸÄ±ÄŸÄ±
    public Color dayColor = new Color(1f, 0.95f, 0.8f);      // GÃ¼ndÃ¼z renk
    public Color nightColor = new Color(0.1f, 0.1f, 0.2f);   // Gece renk
    public Color sunriseColor = new Color(1f, 0.7f, 0.5f);   // GÃ¼n doÄŸumu renk
    public Color sunsetColor = new Color(1f, 0.5f, 0.3f);    // GÃ¼n batÄ±mÄ± renk
    
    [Header("GÃ¼neÅŸ Hareketi")]
    public float sunRotationSpeed = 15f; // GÃ¼neÅŸ dÃ¶nÃ¼ÅŸ hÄ±zÄ±
    public Vector3 sunRotationAxis = Vector3.right;
    
    private float _lastUpdateTime;
    
    public override void OnStartServer() {
        base.OnStartServer();
        gameTime = 6f; // GÃ¼n doÄŸumu ile baÅŸla
        _lastUpdateTime = Time.time;
    }
    
    void Update() {
        if (!IsServer) return;
        
        // âœ… Sunucu tarafÄ±nda zamanÄ± gÃ¼ncelle
        float deltaTime = Time.time - _lastUpdateTime;
        _lastUpdateTime = Time.time;
        
        // âœ… Oyun zamanÄ±nÄ± gÃ¼ncelle
        float gameHoursPassed = deltaTime / realSecondsPerGameHour;
        gameTime += gameHoursPassed;
        
        // âœ… 24 saat dÃ¶ngÃ¼sÃ¼
        if (gameTime >= dayLength) {
            gameTime -= dayLength;
        }
        
        // âœ… Clientlara senkronize et (SyncVar otomatik yapar)
    }
    
    /// <summary>
    /// âœ… YENÄ°: Zaman deÄŸiÅŸtiÄŸinde Ã§aÄŸrÄ±lÄ±r (SyncVar OnChange)
    /// </summary>
    void OnTimeChanged(float oldTime, float newTime, bool asServer) {
        if (asServer) return; // Sadece clientlarda Ã§alÄ±ÅŸÄ±r
        
        UpdateLighting();
        UpdateSunRotation();
    }
    
    /// <summary>
    /// âœ… YENÄ°: IÅŸÄ±klandÄ±rmayÄ± gÃ¼ncelle (gÃ¼n/gece dÃ¶ngÃ¼sÃ¼ne gÃ¶re)
    /// </summary>
    void UpdateLighting() {
        if (sunLight == null) return;
        
        Color currentColor = dayColor;
        float intensity = 1f;
        
        // âœ… GÃ¼n/gece durumuna gÃ¶re renk ve yoÄŸunluk ayarla
        if (IsNightTime()) {
            currentColor = nightColor;
            intensity = 0.2f;
            
            // âœ… Ay Ä±ÅŸÄ±ÄŸÄ±nÄ± aktif et
            if (moonLight != null) {
                moonLight.enabled = true;
                moonLight.intensity = 0.3f;
            }
        } else if (IsSunriseTime()) {
            currentColor = Color.Lerp(nightColor, sunriseColor, GetSunriseProgress());
            intensity = Mathf.Lerp(0.2f, 1f, GetSunriseProgress());
        } else if (IsSunsetTime()) {
            currentColor = Color.Lerp(dayColor, sunsetColor, GetSunsetProgress());
            intensity = Mathf.Lerp(1f, 0.2f, GetSunsetProgress());
        } else {
            // âœ… GÃ¼ndÃ¼z
            currentColor = dayColor;
            intensity = 1f;
            
            // âœ… Ay Ä±ÅŸÄ±ÄŸÄ±nÄ± kapat
            if (moonLight != null) {
                moonLight.enabled = false;
            }
        }
        
        sunLight.color = currentColor;
        sunLight.intensity = intensity;
        
        // âœ… Ambient light'i gÃ¼ncelle
        RenderSettings.ambientLight = currentColor * 0.5f;
    }
    
    /// <summary>
    /// âœ… YENÄ°: GÃ¼neÅŸ rotasyonunu gÃ¼ncelle
    /// </summary>
    void UpdateSunRotation() {
        if (sunLight == null) return;
        
        // âœ… Zaman bazlÄ± gÃ¼neÅŸ aÃ§Ä±sÄ± (0-360 derece)
        float sunAngle = (gameTime / dayLength) * 360f;
        sunLight.transform.rotation = Quaternion.Euler(sunAngle - 90f, 0f, 0f);
    }
    
    /// <summary>
    /// âœ… YENÄ°: Gece zamanÄ± mÄ±?
    /// </summary>
    public bool IsNightTime() {
        return gameTime >= nightStartTime || gameTime <= nightEndTime;
    }
    
    /// <summary>
    /// âœ… YENÄ°: GÃ¼n doÄŸumu zamanÄ± mÄ±?
    /// </summary>
    public bool IsSunriseTime() {
        return gameTime >= nightEndTime && gameTime <= sunriseTime + 1f;
    }
    
    /// <summary>
    /// âœ… YENÄ°: GÃ¼n batÄ±mÄ± zamanÄ± mÄ±?
    /// </summary>
    public bool IsSunsetTime() {
        return gameTime >= sunsetTime - 1f && gameTime <= nightStartTime;
    }
    
    /// <summary>
    /// âœ… YENÄ°: GÃ¼n doÄŸumu ilerlemesi (0-1)
    /// </summary>
    float GetSunriseProgress() {
        if (!IsSunriseTime()) return 0f;
        float startTime = nightEndTime;
        float endTime = sunriseTime;
        return Mathf.InverseLerp(startTime, endTime, gameTime);
    }
    
    /// <summary>
    /// âœ… YENÄ°: GÃ¼n batÄ±mÄ± ilerlemesi (0-1)
    /// </summary>
    float GetSunsetProgress() {
        if (!IsSunsetTime()) return 0f;
        float startTime = sunsetTime;
        float endTime = nightStartTime;
        return Mathf.InverseLerp(startTime, endTime, gameTime);
    }
    
    /// <summary>
    /// âœ… YENÄ°: Oyun zamanÄ±nÄ± string olarak al (UI iÃ§in)
    /// </summary>
    public string GetTimeString() {
        int hours = Mathf.FloorToInt(gameTime);
        int minutes = Mathf.FloorToInt((gameTime - hours) * 60f);
        return $"{hours:00}:{minutes:00}";
    }
}
```

**Yeni Ã–zellikler:**
- âœ… **Sunucu TarafÄ± Zaman YÃ¶netimi:** TÃ¼m clientlar aynÄ± zamanÄ± gÃ¶rÃ¼r
- âœ… **GÃ¼n/Gece DÃ¶ngÃ¼sÃ¼:** Otomatik gÃ¼n doÄŸumu, gÃ¼n batÄ±mÄ±, gece
- âœ… **Dinamik IÅŸÄ±klandÄ±rma:** Zaman bazlÄ± renk ve yoÄŸunluk deÄŸiÅŸimi
- âœ… **GÃ¼neÅŸ Hareketi:** GÃ¼neÅŸ zaman bazlÄ± dÃ¶ner
- âœ… **Ay IÅŸÄ±ÄŸÄ±:** Gece zamanÄ± ay Ä±ÅŸÄ±ÄŸÄ± aktif olur

---

### 3.6 TerrainPoint.cs

**Dosya:** `_Stratocraft/Engine/Core/TerrainPoint.cs`

**AmaÃ§:** Terrain noktasÄ± veri yapÄ±sÄ± (materyal blending iÃ§in)

**Kod:**

```csharp
using UnityEngine;

/// <summary>
/// âœ… YENÄ°: Terrain noktasÄ± veri yapÄ±sÄ±
/// Referans: https://github.com/b3agz/how-to-make-7-days-to-die-in-unity/tree/master/07-terrain-materials
/// Materyal blending hesaplamalarÄ± iÃ§in kullanÄ±lÄ±r
/// </summary>
[System.Serializable]
public class TerrainPoint {
    public Vector3 Position { get; set; }
    public Vector3 Normal { get; set; }
    public float Height { get; set; }
    public float Slope { get; set; }
    
    // âœ… Materyal aÄŸÄ±rlÄ±klarÄ± (0-1 arasÄ±)
    public float GrassWeight { get; set; }
    public float DirtWeight { get; set; }
    public float StoneWeight { get; set; }
    public float SandWeight { get; set; }
    public float SnowWeight { get; set; }
    
    // âœ… Density deÄŸeri (Marching Cubes iÃ§in)
    public float Density { get; set; }
    
    public TerrainPoint(Vector3 position, Vector3 normal, float height, float slope) {
        Position = position;
        Normal = normal;
        Height = height;
        Slope = slope;
        
        // âœ… BaÅŸlangÄ±Ã§ aÄŸÄ±rlÄ±klarÄ±
        GrassWeight = 0f;
        DirtWeight = 0f;
        StoneWeight = 0f;
        SandWeight = 0f;
        SnowWeight = 0f;
        Density = 0f;
    }
    
    /// <summary>
    /// âœ… Materyal aÄŸÄ±rlÄ±klarÄ±nÄ± hesapla (yÃ¼kseklik ve eÄŸime gÃ¶re)
    /// </summary>
    public void CalculateMaterialWeights(
        float grassHeightThreshold, float dirtHeightThreshold,
        float stoneHeightThreshold, float sandHeightThreshold, float snowHeightThreshold,
        float steepSlopeThreshold, float gentleSlopeThreshold) {
        
        // âœ… TÃ¼m aÄŸÄ±rlÄ±klarÄ± sÄ±fÄ±rla
        GrassWeight = 0f;
        DirtWeight = 0f;
        StoneWeight = 0f;
        SandWeight = 0f;
        SnowWeight = 0f;
        
        // âœ… 1. YÃ¼kseklik bazlÄ± aÄŸÄ±rlÄ±k hesaplama
        if (Height >= snowHeightThreshold) {
            SnowWeight = 1f;
        } else if (Height >= grassHeightThreshold) {
            // âœ… YÃ¼ksek yÃ¼kseklik: EÄŸime gÃ¶re Ã§imen veya taÅŸ
            if (Slope > steepSlopeThreshold) {
                StoneWeight = 1f;
            } else if (Slope < gentleSlopeThreshold) {
                GrassWeight = 1f;
            } else {
                // âœ… Orta eÄŸim: Ã‡imen ve toprak karÄ±ÅŸÄ±mÄ±
                float blendFactor = (Slope - gentleSlopeThreshold) / (steepSlopeThreshold - gentleSlopeThreshold);
                GrassWeight = 1f - blendFactor;
                DirtWeight = blendFactor;
            }
        } else if (Height >= dirtHeightThreshold) {
            DirtWeight = 1f;
        } else if (Height >= stoneHeightThreshold) {
            // âœ… DÃ¼ÅŸÃ¼k yÃ¼kseklik: EÄŸime gÃ¶re taÅŸ veya toprak
            if (Slope > steepSlopeThreshold) {
                StoneWeight = 1f;
            } else {
                DirtWeight = 1f;
            }
        } else if (Height >= sandHeightThreshold) {
            StoneWeight = 0.5f;
            DirtWeight = 0.5f;
        } else {
            SandWeight = 1f;
        }
        
        // âœ… AÄŸÄ±rlÄ±klarÄ± normalize et (toplam 1 olmalÄ±)
        float totalWeight = GrassWeight + DirtWeight + StoneWeight + SandWeight + SnowWeight;
        if (totalWeight > 0f) {
            GrassWeight /= totalWeight;
            DirtWeight /= totalWeight;
            StoneWeight /= totalWeight;
            SandWeight /= totalWeight;
            SnowWeight /= totalWeight;
        } else {
            // âœ… Fallback: Toprak
            DirtWeight = 1f;
        }
    }
    
    /// <summary>
    /// âœ… Dominant materyali al (en yÃ¼ksek aÄŸÄ±rlÄ±ÄŸa sahip)
    /// </summary>
    public MaterialType GetDominantMaterial() {
        float maxWeight = Mathf.Max(GrassWeight, DirtWeight, StoneWeight, SandWeight, SnowWeight);
        
        if (maxWeight == GrassWeight) return MaterialType.Grass;
        if (maxWeight == DirtWeight) return MaterialType.Dirt;
        if (maxWeight == StoneWeight) return MaterialType.Stone;
        if (maxWeight == SandWeight) return MaterialType.Sand;
        if (maxWeight == SnowWeight) return MaterialType.Snow;
        
        return MaterialType.Dirt; // Fallback
    }
    
    /// <summary>
    /// âœ… Materyal tipi enum'u
    /// </summary>
    public enum MaterialType {
        Grass,
        Dirt,
        Stone,
        Sand,
        Snow
    }
}
```

**KullanÄ±m:**
- `TerrainMaterialManager` bu class'Ä± kullanarak chunk'lardaki noktalar iÃ§in materyal aÄŸÄ±rlÄ±klarÄ±nÄ± hesaplar
- Shader'a materyal aÄŸÄ±rlÄ±klarÄ± gÃ¶nderilir
- Triplanar texturing ile pÃ¼rÃ¼zsÃ¼z materyal blending yapÄ±lÄ±r

### 3.7 TerrainShader.shader

**Dosya:** `_Stratocraft/Engine/Shaders/TerrainShader.shader`

**AmaÃ§:** Terrain iÃ§in triplanar texturing ve materyal blending shader'Ä±

**Kod:**

```hlsl
// âœ… YENÄ°: Terrain Shader (Triplanar Texturing + Material Blending)
// Referans: https://github.com/b3agz/how-to-make-7-days-to-die-in-unity/tree/master/04-chunks
Shader "Stratocraft/TerrainShader" {
    Properties {
        _MainTex ("Albedo (RGB)", 2D) = "white" {}
        _NormalMap ("Normal Map", 2D) = "bump" {}
        _Metallic ("Metallic", Range(0,1)) = 0.0
        _Smoothness ("Smoothness", Range(0,1)) = 0.5
        
        // âœ… Triplanar Texturing
        _BlendSharpness ("Blend Sharpness", Range(1, 10)) = 2.0
        
        // âœ… Material Blending (Ã‡imen, Toprak, TaÅŸ, Kum, Kar)
        _GrassTex ("Grass Texture", 2D) = "white" {}
        _DirtTex ("Dirt Texture", 2D) = "white" {}
        _StoneTex ("Stone Texture", 2D) = "white" {}
        _SandTex ("Sand Texture", 2D) = "white" {}
        _SnowTex ("Snow Texture", 2D) = "white" {}
        
        // âœ… Material Weights (YÃ¼kseklik ve eÄŸime gÃ¶re)
        _GrassWeight ("Grass Weight", Range(0,1)) = 0.0
        _DirtWeight ("Dirt Weight", Range(0,1)) = 0.0
        _StoneWeight ("Stone Weight", Range(0,1)) = 0.0
        _SandWeight ("Sand Weight", Range(0,1)) = 0.0
        _SnowWeight ("Snow Weight", Range(0,1)) = 0.0
    }
    
    SubShader {
        Tags { "RenderType"="Opaque" }
        LOD 200
        
        CGPROGRAM
        #pragma surface surf Standard fullforwardshadows
        #pragma target 3.0
        
        sampler2D _MainTex;
        sampler2D _NormalMap;
        sampler2D _GrassTex;
        sampler2D _DirtTex;
        sampler2D _StoneTex;
        sampler2D _SandTex;
        sampler2D _SnowTex;
        
        float _Metallic;
        float _Smoothness;
        float _BlendSharpness;
        float _GrassWeight;
        float _DirtWeight;
        float _StoneWeight;
        float _SandWeight;
        float _SnowWeight;
        
        struct Input {
            float2 uv_MainTex;
            float3 worldPos;
            float3 worldNormal;
        };
        
        // âœ… Triplanar Texturing Hesaplama
        float3 TriplanarSample(sampler2D tex, float3 worldPos, float3 worldNormal, float blendSharpness) {
            // âœ… Normal'in mutlak deÄŸerlerini al (blend aÄŸÄ±rlÄ±klarÄ± iÃ§in)
            float3 blendWeights = abs(worldNormal);
            blendWeights = pow(blendWeights, blendSharpness);
            blendWeights = blendWeights / (blendWeights.x + blendWeights.y + blendWeights.z);
            
            // âœ… X, Y, Z eksenlerinde texture sample'larÄ±
            float3 texX = tex2D(tex, worldPos.yz).rgb;
            float3 texY = tex2D(tex, worldPos.xz).rgb;
            float3 texZ = tex2D(tex, worldPos.xy).rgb;
            
            // âœ… Blend
            return texX * blendWeights.x + texY * blendWeights.y + texZ * blendWeights.z;
        }
        
        void surf(Input IN, inout SurfaceOutputStandard o) {
            // âœ… Material blending (yÃ¼kseklik ve eÄŸime gÃ¶re)
            float3 grassColor = TriplanarSample(_GrassTex, IN.worldPos, IN.worldNormal, _BlendSharpness);
            float3 dirtColor = TriplanarSample(_DirtTex, IN.worldPos, IN.worldNormal, _BlendSharpness);
            float3 stoneColor = TriplanarSample(_StoneTex, IN.worldPos, IN.worldNormal, _BlendSharpness);
            float3 sandColor = TriplanarSample(_SandTex, IN.worldPos, IN.worldNormal, _BlendSharpness);
            float3 snowColor = TriplanarSample(_SnowTex, IN.worldPos, IN.worldNormal, _BlendSharpness);
            
            // âœ… Material weights ile blend
            float3 finalColor = grassColor * _GrassWeight +
                               dirtColor * _DirtWeight +
                               stoneColor * _StoneWeight +
                               sandColor * _SandWeight +
                               snowColor * _SnowWeight;
            
            // âœ… Normalize (toplam 1 olmalÄ±)
            float totalWeight = _GrassWeight + _DirtWeight + _StoneWeight + _SandWeight + _SnowWeight;
            if (totalWeight > 0) {
                finalColor /= totalWeight;
            }
            
            o.Albedo = finalColor;
            o.Metallic = _Metallic;
            o.Smoothness = _Smoothness;
            o.Normal = UnpackNormal(tex2D(_NormalMap, IN.uv_MainTex));
        }
        ENDCG
    }
    FallBack "Diffuse"
}
```

**KullanÄ±m:**
- `TerrainMaterialManager.cs` bu shader'Ä± kullanarak chunk'lara materyal atar
- Material weights (Ã§imen, toprak, taÅŸ, kum, kar) yÃ¼kseklik ve eÄŸime gÃ¶re hesaplanÄ±r
- Triplanar texturing ile pÃ¼rÃ¼zsÃ¼z materyal blending yapÄ±lÄ±r

---

### 3.8 VoxelGrid.cs

**Dosya:** `_Stratocraft/Engine/Core/VoxelGrid.cs`

**AmaÃ§:** Voxel veri yapÄ±sÄ± (chunk density data'sÄ±nÄ± tutmak iÃ§in)

**Kod:**

```csharp
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Voxel grid veri yapÄ±sÄ±
/// Referans: Scrawk / Marching Cubes on GPU
/// NOT: Scrawk kendi density buffer sistemini kullanÄ±r (ComputeBuffer)
/// Bu class opsiyonel - Scrawk'Ä±n internal sistemi yerine kullanÄ±labilir
/// Veya Scrawk'Ä±n density buffer'Ä±nÄ± wrap etmek iÃ§in kullanÄ±labilir
/// </summary>
public class VoxelGrid {
    private int _sizeX, _sizeY, _sizeZ;
    private float[] _densityData;
    
    // âœ… OPTÄ°MÄ°ZE: Dictionary cache (sparse voxel data iÃ§in)
    private Dictionary<Vector3Int, float> _sparseData;
    private bool _useSparseStorage = false;
    
    /// <summary>
    /// âœ… Voxel grid oluÅŸtur
    /// </summary>
    public VoxelGrid(int sizeX, int sizeY, int sizeZ, bool useSparseStorage = false) {
        _sizeX = sizeX;
        _sizeY = sizeY;
        _sizeZ = sizeZ;
        _useSparseStorage = useSparseStorage;
        
        if (useSparseStorage) {
            _sparseData = new Dictionary<Vector3Int, float>();
        } else {
            _densityData = new float[sizeX * sizeY * sizeZ];
        }
    }
    
    /// <summary>
    /// âœ… Density deÄŸerini al
    /// </summary>
    public float GetDensity(int x, int y, int z) {
        if (x < 0 || x >= _sizeX || y < 0 || y >= _sizeY || z < 0 || z >= _sizeZ) {
            return 0f; // SÄ±nÄ±r dÄ±ÅŸÄ±
        }
        
        if (_useSparseStorage) {
            Vector3Int key = new Vector3Int(x, y, z);
            return _sparseData.TryGetValue(key, out float value) ? value : 0f;
        } else {
            int index = x + y * _sizeX + z * _sizeX * _sizeY;
            return _densityData[index];
        }
    }
    
    /// <summary>
    /// âœ… Density deÄŸerini ayarla
    /// </summary>
    public void SetDensity(int x, int y, int z, float density) {
        if (x < 0 || x >= _sizeX || y < 0 || y >= _sizeY || z < 0 || z >= _sizeZ) {
            return; // SÄ±nÄ±r dÄ±ÅŸÄ±
        }
        
        if (_useSparseStorage) {
            Vector3Int key = new Vector3Int(x, y, z);
            if (density != 0f) {
                _sparseData[key] = density;
            } else {
                _sparseData.Remove(key);
            }
        } else {
            int index = x + y * _sizeX + z * _sizeX * _sizeY;
            _densityData[index] = density;
        }
    }
    
    /// <summary>
    /// âœ… TÃ¼m density data'sÄ±nÄ± al (GPU buffer iÃ§in)
    /// </summary>
    public float[] GetDensityArray() {
        if (_useSparseStorage) {
            // âœ… Sparse data'yÄ± dense array'e dÃ¶nÃ¼ÅŸtÃ¼r
            float[] denseArray = new float[_sizeX * _sizeY * _sizeZ];
            foreach (var kvp in _sparseData) {
                Vector3Int pos = kvp.Key;
                int index = pos.x + pos.y * _sizeX + pos.z * _sizeX * _sizeY;
                denseArray[index] = kvp.Value;
            }
            return denseArray;
        } else {
            return _densityData;
        }
    }
    
    /// <summary>
    /// âœ… Density data'sÄ±nÄ± yÃ¼kle (GPU'dan veya cache'den)
    /// </summary>
    public void LoadDensityData(float[] data) {
        if (data == null || data.Length != _sizeX * _sizeY * _sizeZ) {
            Debug.LogError("[VoxelGrid] GeÃ§ersiz density data boyutu");
            return;
        }
        
        if (_useSparseStorage) {
            _sparseData.Clear();
            for (int i = 0; i < data.Length; i++) {
                if (data[i] != 0f) {
                    int x = i % _sizeX;
                    int y = (i / _sizeX) % _sizeY;
                    int z = i / (_sizeX * _sizeY);
                    _sparseData[new Vector3Int(x, y, z)] = data[i];
                }
            }
        } else {
            _densityData = data;
        }
    }
    
    /// <summary>
    /// âœ… Grid boyutlarÄ±nÄ± al
    /// </summary>
    public Vector3Int GetSize() {
        return new Vector3Int(_sizeX, _sizeY, _sizeZ);
    }
    
    /// <summary>
    /// âœ… Grid'i temizle
    /// </summary>
    public void Clear() {
        if (_useSparseStorage) {
            _sparseData?.Clear();
        } else {
            System.Array.Clear(_densityData, 0, _densityData.Length);
        }
    }
}
```

---

### 3.9 MeshBuilder.cs

**Dosya:** `_Stratocraft/Engine/Core/MeshBuilder.cs`

**AmaÃ§:** Marching Cubes algoritmasÄ± iÃ§in mesh oluÅŸturma yardÄ±mcÄ±larÄ±

**Kod:**

```csharp
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Mesh oluÅŸturma yardÄ±mcÄ± sÄ±nÄ±fÄ±
/// Referans: Scrawk / Marching Cubes on GPU
/// GPU'dan gelen vertex ve triangle data'sÄ±nÄ± Unity Mesh'e dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r
/// </summary>
public static class MeshBuilder {
    /// <summary>
    /// âœ… Vertex ve triangle listesinden mesh oluÅŸtur
    /// </summary>
    public static Mesh BuildMesh(List<Vector3> vertices, List<int> triangles, List<Vector3> normals = null, List<Vector2> uvs = null) {
        if (vertices == null || vertices.Count == 0) {
            return null;
        }
        
        Mesh mesh = new Mesh();
        mesh.name = "ChunkMesh";
        
        // âœ… Vertex'leri ayarla
        mesh.vertices = vertices.ToArray();
        
        // âœ… Triangle'leri ayarla
        if (triangles != null && triangles.Count > 0) {
            mesh.triangles = triangles.ToArray();
        }
        
        // âœ… Normal'leri ayarla (yoksa otomatik hesapla)
        if (normals != null && normals.Count == vertices.Count) {
            mesh.normals = normals.ToArray();
        } else {
            mesh.RecalculateNormals();
        }
        
        // âœ… UV'leri ayarla (yoksa otomatik oluÅŸtur)
        if (uvs != null && uvs.Count == vertices.Count) {
            mesh.uv = uvs.ToArray();
        } else {
            // âœ… Basit UV mapping (world position bazlÄ±)
            Vector2[] autoUVs = new Vector2[vertices.Count];
            for (int i = 0; i < vertices.Count; i++) {
                autoUVs[i] = new Vector2(vertices[i].x, vertices[i].z);
            }
            mesh.uv = autoUVs;
        }
        
        // âœ… Tangent'leri hesapla (normal mapping iÃ§in)
        mesh.RecalculateTangents();
        
        // âœ… Bounds'u hesapla (culling iÃ§in)
        mesh.RecalculateBounds();
        
        return mesh;
    }
    
    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: GPU'dan gelen buffer data'sÄ±nÄ± mesh'e dÃ¶nÃ¼ÅŸtÃ¼r
    /// </summary>
    public static Mesh BuildMeshFromGPU(ComputeBuffer vertexBuffer, ComputeBuffer triangleBuffer, int vertexCount, int triangleCount) {
        if (vertexBuffer == null || triangleBuffer == null || vertexCount == 0) {
            return null;
        }
        
        // âœ… GPU buffer'larÄ±ndan data oku
        Vector3[] vertices = new Vector3[vertexCount];
        int[] triangles = new int[triangleCount];
        
        vertexBuffer.GetData(vertices);
        triangleBuffer.GetData(triangles);
        
        // âœ… Mesh oluÅŸtur
        Mesh mesh = new Mesh();
        mesh.name = "ChunkMesh_GPU";
        mesh.vertices = vertices;
        mesh.triangles = triangles;
        mesh.RecalculateNormals();
        mesh.RecalculateBounds();
        
        return mesh;
    }
    
    /// <summary>
    /// âœ… Mesh'i optimize et (vertex welding, triangle reduction)
    /// </summary>
    public static Mesh OptimizeMesh(Mesh mesh) {
        if (mesh == null) return null;
        
        // âœ… Unity'nin built-in optimize fonksiyonunu kullan
        mesh.Optimize();
        
        // âœ… Bounds'u yeniden hesapla
        mesh.RecalculateBounds();
        
        return mesh;
    }
    
    /// <summary>
    /// âœ… Mesh'i birleÅŸtir (birden fazla mesh'i tek mesh'e)
    /// </summary>
    public static Mesh CombineMeshes(List<Mesh> meshes, List<Matrix4x4> transforms = null) {
        if (meshes == null || meshes.Count == 0) {
            return null;
        }
        
        CombineInstance[] combine = new CombineInstance[meshes.Count];
        
        for (int i = 0; i < meshes.Count; i++) {
            combine[i].mesh = meshes[i];
            combine[i].transform = transforms != null && i < transforms.Count ? transforms[i] : Matrix4x4.identity;
        }
        
        Mesh combinedMesh = new Mesh();
        combinedMesh.name = "CombinedMesh";
        combinedMesh.CombineMeshes(combine);
        combinedMesh.RecalculateBounds();
        
        return combinedMesh;
    }
}
```

---

## â›ï¸ ADIM 4: KAZI VE AÄ SENKRONÄ°ZASYONU

> **âœ… GÃœNCELLEME NOTU:** Bu bÃ¶lÃ¼mdeki chunk sistemleri yÃ¼ksek performanslÄ± versiyonlarla gÃ¼ncellenmiÅŸtir.  
> **Referans Video:** [How to Make 7 Days to Die in Unity (Marching Cubes)](https://www.youtube.com/watch?v=dTdn3CC64sc)  
> **Yeni Ã–zellikler:** Priority Queue, Mesh Pooling, LOD, Disk Caching, GPU OptimizasyonlarÄ±

### 4.1 NetworkMining.cs (Minecraft Benzeri - DetaylÄ± Sistem)

**Dosya:** `_Stratocraft/Scripts/Systems/Mining/NetworkMining.cs`

**AmaÃ§:** Minecraft benzeri kÄ±rma/yerleÅŸtirme sistemi - BasÄ±lÄ± tutunca sÃ¼rekli kÄ±rma, hardness sistemi, break progress, item pickup

**Ã–zellikler:**
- âœ… **Hold to Break:** BasÄ±lÄ± tutunca sÃ¼rekli kÄ±rma (Minecraft gibi)
- âœ… **Block Hardness:** Her materyal tipinin farklÄ± kÄ±rma sÃ¼resi
- âœ… **Tool Efficiency:** Tool'a gÃ¶re kÄ±rma hÄ±zÄ± deÄŸiÅŸir
- âœ… **Break Progress:** KÄ±rma ilerlemesi gÃ¶sterilir (crack texture/UI)
- âœ… **Item Pickup:** Fiziksel item'lar teklenebilir (Minecraft gibi)
- âœ… **Block Placement:** SaÄŸ tÄ±k ile blok yerleÅŸtirme

**SÄ±k Sorulan Sorular ve CevaplarÄ±:**

**1. Item'lar Minecraft'taki gibi mi geliyor? Teklenebiliyor mu?**
- âœ… Evet! Item'lar `PhysicalItem` component'i ile fiziksel olarak dÃ¼ÅŸer
- âœ… Rigidbody kullanÄ±r, yere dÃ¼ÅŸer ve yerde durur
- âœ… E tuÅŸu ile toplanabilir (NetworkMining.HandleItemPickup)
- âœ… Otomatik despawn sÃ¼resi var (5 dakika varsayÄ±lan)

**2. Yere basÄ±lÄ± tutunca sÃ¼rekli kÄ±rmaya devam mÄ± ediyor?**
- âœ… Evet! `GetMouseButton(0)` kullanarak basÄ±lÄ± tutunca sÃ¼rekli kÄ±rma
- âœ… AynÄ± noktaya bakÄ±yorsan progress artmaya devam eder
- âœ… FarklÄ± noktaya geÃ§ersen yeni kÄ±rma baÅŸlar

**3. Bir basÄ±ÅŸ bir kÄ±rÄ±ÅŸ mÄ±?**
- âŒ HayÄ±r! BasÄ±lÄ± tutunca sÃ¼rekli kÄ±rma (Minecraft gibi)
- âœ… Her materyal tipinin farklÄ± kÄ±rma sÃ¼resi var (hardness)
- âœ… Progress 0'dan 1'e kadar artar, %100 olduÄŸunda kÄ±rÄ±lÄ±r

**4. BasÄ±lÄ± tutarak her zeminin bir kÄ±rma sÃ¼resi mi var?**
- âœ… Evet! Her materyal tipinin farklÄ± `blockHardness` deÄŸeri var:
  - Ã‡imen: 0.6 saniye
  - Toprak: 0.5 saniye
  - TaÅŸ: 1.5 saniye
  - Derin taÅŸ: 2.0 saniye
  - Madenler: 3.0 saniye
- âœ… Tool kullanÄ±lÄ±rsa kÄ±rma sÃ¼resi azalÄ±r (efficiency Ã§arpanÄ±)

**5. Voxel terrain'de nasÄ±l Ã§alÄ±ÅŸÄ±yor?**
- âœ… Minecraft'ta kÃ¼p kÃ¼p bloklar var, bizde pÃ¼rÃ¼zsÃ¼z voxel terrain
- âœ… KÄ±rma: GPU'da density deÄŸiÅŸtirilir â†’ Mesh yeniden oluÅŸturulur
- âœ… YerleÅŸtirme: GPU'da density eklenir â†’ Mesh yeniden oluÅŸturulur
- âœ… ÃœÃ§genlerle mesh oluÅŸturuluyor (Marching Cubes algoritmasÄ±)

**Kod:**

```csharp
using FishNet.Object;
using FishNet.Object.Synchronizing;
using UnityEngine;
using System.Collections;

/// <summary>
/// âœ… MINECRAFT BENZERÄ°: DetaylÄ± kÄ±rma/yerleÅŸtirme sistemi
/// - BasÄ±lÄ± tutunca sÃ¼rekli kÄ±rma
/// - Her materyal tipinin farklÄ± hardness deÄŸeri
/// - Tool efficiency sistemi
/// - Break progress indicator
/// - Item pickup sistemi
/// - Block placement sistemi
/// </summary>
public class NetworkMining : NetworkBehaviour {
    [Header("Ayarlar")]
    [Tooltip("EtkileÅŸim mesafesi (blok kÄ±rma/yerleÅŸtirme)")]
    public float interactionRange = 5f;
    
    [Tooltip("KÄ±rma yarÄ±Ã§apÄ± (voxel terrain iÃ§in)")]
    public float digRadius = 0.5f;
    
    [Tooltip("KÄ±rma derinliÄŸi (voxel terrain iÃ§in)")]
    public float digDepth = 0.5f;
    
    [Header("KÄ±rma Sistemi")]
    [Tooltip("KÄ±rma progress gÃ¼ncelleme sÄ±klÄ±ÄŸÄ± (saniye)")]
    [Range(0.01f, 0.1f)]
    public float breakProgressUpdateInterval = 0.05f;
    
    [Header("UI")]
    [Tooltip("Break progress UI (crack texture veya progress bar)")]
    public GameObject breakProgressUI;
    
    // âœ… MINECRAFT BENZERÄ°: KÄ±rma sistemi
    private Vector3 _currentBreakPoint = Vector3.zero;
    private float _breakProgress = 0f; // 0-1 arasÄ±
    private float _breakStartTime = 0f;
    private bool _isBreaking = false;
    private string _currentMaterialType = "";
    private float _currentBlockHardness = 1f;
    private Coroutine _breakCoroutine;
    
    // âœ… Referanslar
    private ChunkManager _chunkManager;
    private ItemDatabase _itemDatabase;
    private ItemSpawner _itemSpawner;
    private PlayerInventory _playerInventory; // TODO: PlayerInventory sistemi eklenecek
    
    // âœ… Tool sistemi
    private ItemDefinition _currentTool = null;
    private float _toolEfficiency = 1f;
    
    void Start() {
        // âœ… ServiceLocator'dan referanslarÄ± al
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        _itemDatabase = ServiceLocator.Instance?.Get<ItemDatabase>();
        _itemSpawner = ServiceLocator.Instance?.Get<ItemSpawner>();
        
        if (_chunkManager == null) {
            Debug.LogWarning("[NetworkMining] ChunkManager bulunamadÄ±!");
        }
    }

    void Update() {
        // âœ… Sadece kendi karakterim iÃ§in Ã§alÄ±ÅŸ
        if (!IsOwner) return;
        
        // âœ… Sol tÄ±k: KÄ±rma (basÄ±lÄ± tutunca sÃ¼rekli kÄ±rma)
        HandleBreaking();
        
        // âœ… SaÄŸ tÄ±k: Blok yerleÅŸtirme
        HandleBlockPlacement();
        
        // âœ… Item pickup (E tuÅŸu)
        HandleItemPickup();
    }
    
    /// <summary>
    /// âœ… MINECRAFT BENZERÄ°: BasÄ±lÄ± tutunca sÃ¼rekli kÄ±rma
    /// </summary>
    void HandleBreaking() {
        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
        RaycastHit hit;
        
        if (Physics.Raycast(ray, out hit, interactionRange)) {
            // âœ… Voxel terrain'e mi Ã§arptÄ±?
            if (hit.collider.GetComponent<MarchingCubesGPU>() != null) {
                Vector3 breakPoint = hit.point;
                
                // âœ… Sol tÄ±k basÄ±ldÄ± mÄ±?
                if (Input.GetMouseButtonDown(0)) {
                    StartBreaking(breakPoint);
                }
                // âœ… Sol tÄ±k basÄ±lÄ± tutuluyor mu?
                else if (Input.GetMouseButton(0)) {
                    // âœ… AynÄ± noktaya mÄ± bakÄ±yoruz?
                    if (Vector3.Distance(breakPoint, _currentBreakPoint) < 0.1f) {
                        // âœ… Zaten kÄ±rÄ±yoruz, devam et
                        UpdateBreakProgress();
                    } else {
                        // âœ… FarklÄ± noktaya geÃ§tik, yeni kÄ±rma baÅŸlat
                        StopBreaking();
                        StartBreaking(breakPoint);
                    }
                }
                // âœ… Sol tÄ±k bÄ±rakÄ±ldÄ± mÄ±?
                else if (Input.GetMouseButtonUp(0)) {
                    StopBreaking();
                }
            } else {
                // âœ… Voxel terrain'e Ã§arpmadÄ±, kÄ±rma durdur
                StopBreaking();
            }
        } else {
            // âœ… HiÃ§bir ÅŸeye Ã§arpmadÄ±, kÄ±rma durdur
            StopBreaking();
        }
    }
    
    /// <summary>
    /// âœ… KÄ±rma baÅŸlat
    /// </summary>
    void StartBreaking(Vector3 point) {
        if (_isBreaking) return;
        
        _currentBreakPoint = point;
        _isBreaking = true;
        _breakProgress = 0f;
        _breakStartTime = Time.time;
        
        // âœ… Materyal tipini belirle
        _currentMaterialType = DetermineMaterialType(point.y);
        
        // âœ… Block hardness deÄŸerini al (ItemDefinition'dan)
        _currentBlockHardness = GetBlockHardness(_currentMaterialType);
        
        // âœ… Tool efficiency'yi hesapla
        CalculateToolEfficiency();
        
        // âœ… KÄ±rma coroutine'ini baÅŸlat
        if (_breakCoroutine != null) {
            StopCoroutine(_breakCoroutine);
        }
        _breakCoroutine = StartCoroutine(BreakProgressCoroutine());
        
        // âœ… Sunucuya bildir (break start)
        CmdStartBreaking(point);
    }
    
    /// <summary>
    /// âœ… KÄ±rma durdur
    /// </summary>
    void StopBreaking() {
        if (!_isBreaking) return;
        
        _isBreaking = false;
        _breakProgress = 0f;
        
        if (_breakCoroutine != null) {
            StopCoroutine(_breakCoroutine);
            _breakCoroutine = null;
        }
        
        // âœ… UI'Ä± gizle
        if (breakProgressUI != null) {
            breakProgressUI.SetActive(false);
        }
        
        // âœ… Sunucuya bildir (break stop)
        CmdStopBreaking();
    }
    
    /// <summary>
    /// âœ… KÄ±rma progress gÃ¼ncelle
    /// </summary>
    void UpdateBreakProgress() {
        if (!_isBreaking) return;
        
        // âœ… Tool efficiency ile kÄ±rma sÃ¼resini hesapla
        float breakTime = _currentBlockHardness / _toolEfficiency;
        
        // âœ… Progress hesapla (0-1 arasÄ±)
        float elapsed = Time.time - _breakStartTime;
        _breakProgress = Mathf.Clamp01(elapsed / breakTime);
        
        // âœ… UI'Ä± gÃ¼ncelle
        UpdateBreakProgressUI();
        
        // âœ… %100 oldu mu?
        if (_breakProgress >= 1f) {
            // âœ… BloÄŸu kÄ±r
            BreakBlock();
            StopBreaking();
        }
    }
    
    /// <summary>
    /// âœ… KÄ±rma progress coroutine
    /// </summary>
    IEnumerator BreakProgressCoroutine() {
        while (_isBreaking) {
            UpdateBreakProgress();
            yield return new WaitForSeconds(breakProgressUpdateInterval);
        }
    }
    
    /// <summary>
    /// âœ… BloÄŸu kÄ±r (progress %100 olduÄŸunda)
    /// </summary>
    void BreakBlock() {
        // âœ… Sunucuya bildir
        CmdBreakBlock(_currentBreakPoint);
    }
    
    /// <summary>
    /// âœ… Tool efficiency hesapla
    /// </summary>
    void CalculateToolEfficiency() {
        _toolEfficiency = 1f; // VarsayÄ±lan (el ile kÄ±rma)
        
        // âœ… TODO: PlayerInventory'den aktif tool'u al
        // Åimdilik varsayÄ±lan deÄŸer
        if (_currentTool != null && _currentTool.isTool) {
            _toolEfficiency = _currentTool.toolEfficiency;
            
            // âœ… Tool bu materyal tipine etkili mi?
            MaterialType matType = GetMaterialTypeEnum(_currentMaterialType);
            if (_currentTool.IsEffectiveAgainst(matType)) {
                _toolEfficiency *= 1.5f; // %50 daha hÄ±zlÄ±
            }
        }
    }

    // ========== SERVER RPC METODLARI ==========
    
    /// <summary>
    /// âœ… ServerRpc: KÄ±rma baÅŸlat
    /// </summary>
    [ServerRpc]
    void CmdStartBreaking(Vector3 point) {
        // âœ… Hile kontrolÃ¼: Mesafe
        float distance = Vector3.Distance(transform.position, point);
        if (distance > interactionRange + 2f) {
            Debug.LogWarning($"[NetworkMining] ÅÃ¼pheli kÄ±rma mesafesi: {distance}m");
            return;
        }
        
        // âœ… TÃ¼m clientlara bildir
        RpcStartBreaking(point);
    }
    
    /// <summary>
    /// âœ… ServerRpc: KÄ±rma durdur
    /// </summary>
    [ServerRpc]
    void CmdStopBreaking() {
        RpcStopBreaking();
    }
    
    /// <summary>
    /// âœ… ServerRpc: BloÄŸu kÄ±r
    /// </summary>
    [ServerRpc]
    void CmdBreakBlock(Vector3 point) {
        // âœ… Hile kontrolÃ¼: Mesafe
        float distance = Vector3.Distance(transform.position, point);
        if (distance > interactionRange + 2f) {
            Debug.LogWarning($"[NetworkMining] ÅÃ¼pheli kÄ±rma mesafesi: {distance}m");
            return;
        }
        
        // âœ… Terrain'i deÄŸiÅŸtir
        ModifyTerrainAtPoint(point, digRadius, -digDepth);
        
        // âœ… Item drop et
        SpawnMinedItems(point, digRadius, digDepth);
        
        // âœ… TÃ¼m clientlara bildir
        RpcBreakBlock(point);
    }
    
    /// <summary>
    /// âœ… ServerRpc: Blok yerleÅŸtir
    /// </summary>
    [ServerRpc]
    void CmdPlaceBlock(Vector3 point, Vector3 normal, string itemId) {
        // âœ… Hile kontrolÃ¼: Mesafe
        float distance = Vector3.Distance(transform.position, point);
        if (distance > interactionRange + 2f) {
            Debug.LogWarning($"[NetworkMining] ÅÃ¼pheli yerleÅŸtirme mesafesi: {distance}m");
            return;
        }
        
        // âœ… ItemDefinition'Ä± al
        var itemDef = _itemDatabase?.GetItem(itemId);
        if (itemDef == null || !itemDef.isPlaceable) {
            Debug.LogWarning($"[NetworkMining] YerleÅŸtirilemez item: {itemId}");
            return;
        }
        
        // âœ… TODO: PlayerInventory'den item'Ä± kontrol et ve Ã§Ä±kar
        
        // âœ… Blok yerleÅŸtir
        PlaceBlockAtPoint(point, normal, itemDef);
        
        // âœ… TÃ¼m clientlara bildir
        RpcPlaceBlock(point, normal, itemId);
    }
    
    // ========== OBSERVERS RPC METODLARI ==========
    
    /// <summary>
    /// âœ… ObserversRpc: KÄ±rma baÅŸlat (tÃ¼m clientlara)
    /// </summary>
    [ObserversRpc]
    void RpcStartBreaking(Vector3 point) {
        // âœ… Sadece diÄŸer clientlarda Ã§alÄ±ÅŸ (owner zaten baÅŸlattÄ±)
        if (IsOwner) return;
        
        // âœ… KÄ±rma animasyonu/efekti gÃ¶ster
        // TODO: Crack texture veya particle effect
    }
    
    /// <summary>
    /// âœ… ObserversRpc: KÄ±rma durdur (tÃ¼m clientlara)
    /// </summary>
    [ObserversRpc]
    void RpcStopBreaking() {
        if (IsOwner) return;
        
        // âœ… KÄ±rma animasyonunu durdur
    }
    
    /// <summary>
    /// âœ… ObserversRpc: BloÄŸu kÄ±r (tÃ¼m clientlara)
    /// </summary>
    [ObserversRpc]
    void RpcBreakBlock(Vector3 point) {
        // âœ… Terrain'i deÄŸiÅŸtir (tÃ¼m clientlarda)
        ModifyTerrainAtPoint(point, digRadius, -digDepth);
        
        // âœ… KÄ±rma efekti gÃ¶ster
        // TODO: Particle effect, sound
    }
    
    /// <summary>
    /// âœ… ObserversRpc: Blok yerleÅŸtir (tÃ¼m clientlara)
    /// </summary>
    [ObserversRpc]
    void RpcPlaceBlock(Vector3 point, Vector3 normal, string itemId) {
        var itemDef = _itemDatabase?.GetItem(itemId);
        if (itemDef == null) return;
        
        // âœ… Blok yerleÅŸtir (tÃ¼m clientlarda)
        PlaceBlockAtPoint(point, normal, itemDef);
    }

    // ========== YARDIMCI METODLAR ==========
    
    /// <summary>
    /// âœ… Blok yerleÅŸtirme (saÄŸ tÄ±k)
    /// </summary>
    void HandleBlockPlacement() {
        if (!Input.GetMouseButtonDown(1)) return; // SaÄŸ tÄ±k
        
        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
        RaycastHit hit;
        
        if (Physics.Raycast(ray, out hit, interactionRange)) {
            // âœ… Voxel terrain'e mi Ã§arptÄ±?
            if (hit.collider.GetComponent<MarchingCubesGPU>() != null) {
                // âœ… TODO: PlayerInventory'den aktif item'Ä± al
                string activeItemId = "dirt"; // VarsayÄ±lan
                
                // âœ… Blok yerleÅŸtir
                Vector3 placePoint = hit.point + hit.normal * 0.1f; // Normal yÃ¶nÃ¼nde biraz ileri
                CmdPlaceBlock(placePoint, hit.normal, activeItemId);
            }
        }
    }
    
    /// <summary>
    /// âœ… Item pickup (E tuÅŸu)
    /// </summary>
    void HandleItemPickup() {
        if (!Input.GetKeyDown(KeyCode.E)) return;
        
        // âœ… YakÄ±ndaki item'larÄ± bul
        Collider[] nearbyItems = Physics.OverlapSphere(transform.position, 2f);
        
        foreach (var collider in nearbyItems) {
            var physicalItem = collider.GetComponent<PhysicalItem>();
            if (physicalItem != null) {
                // âœ… TODO: PlayerInventory'e ekle
                // Åimdilik sadece item'Ä± yok et
                CmdPickupItem(physicalItem.GetComponent<NetworkObject>());
                break; // Ä°lk item'Ä± al
            }
        }
    }
    
    /// <summary>
    /// âœ… ServerRpc: Item pickup
    /// </summary>
    [ServerRpc]
    void CmdPickupItem(NetworkObject itemNet) {
        if (itemNet == null) return;
        
        var physicalItem = itemNet.GetComponent<PhysicalItem>();
        if (physicalItem == null) return;
        
        // âœ… TODO: PlayerInventory'e ekle
        // Åimdilik sadece item'Ä± yok et
        Despawn(itemNet);
    }
    
    /// <summary>
    /// âœ… Break progress UI gÃ¼ncelle
    /// </summary>
    void UpdateBreakProgressUI() {
        if (breakProgressUI == null) return;
        
        breakProgressUI.SetActive(true);
        
        // âœ… Progress bar gÃ¼ncelle (varsa)
        // TODO: UI component'ine progress deÄŸerini gÃ¶nder
    }
    
    /// <summary>
    /// âœ… Block hardness deÄŸerini al
    /// </summary>
    float GetBlockHardness(string materialType) {
        // âœ… ItemDefinition'dan hardness al
        string itemId = GetItemIdForMaterial(materialType);
        var itemDef = _itemDatabase?.GetItem(itemId);
        
        if (itemDef != null && itemDef.isPlaceable) {
            return itemDef.blockHardness;
        }
        
        // âœ… VarsayÄ±lan hardness deÄŸerleri (Minecraft benzeri)
        switch (materialType) {
            case "GRASS": return 0.6f;
            case "DIRT": return 0.5f;
            case "STONE": return 1.5f;
            case "DEEP_STONE": return 2.0f;
            case "IRON_ORE": return 3.0f;
            case "COAL_ORE": return 3.0f;
            case "COPPER_ORE": return 3.0f;
            case "GOLD_ORE": return 3.0f;
            case "DIAMOND_ORE": return 3.0f;
            case "EMERALD_ORE": return 3.0f;
            default: return 1.0f;
        }
    }
    
    /// <summary>
    /// âœ… Materyal tipini enum'a Ã§evir
    /// </summary>
    MaterialType GetMaterialTypeEnum(string materialType) {
        switch (materialType) {
            case "GRASS": return MaterialType.GRASS;
            case "DIRT": return MaterialType.DIRT;
            case "STONE": return MaterialType.STONE;
            case "DEEP_STONE": return MaterialType.DEEP_STONE;
            case "IRON_ORE": return MaterialType.IRON_ORE;
            case "COAL_ORE": return MaterialType.COAL_ORE;
            case "COPPER_ORE": return MaterialType.COPPER_ORE;
            case "GOLD_ORE": return MaterialType.GOLD_ORE;
            case "DIAMOND_ORE": return MaterialType.DIAMOND_ORE;
            case "EMERALD_ORE": return MaterialType.EMERALD_ORE;
            default: return MaterialType.DIRT;
        }
    }
    
    /// <summary>
    /// âœ… Blok yerleÅŸtir (voxel terrain'e density ekle)
    /// </summary>
    void PlaceBlockAtPoint(Vector3 point, Vector3 normal, ItemDefinition itemDef) {
        if (itemDef == null || itemDef.blockPrefab == null) return;
        
        // âœ… Voxel terrain'e density ekle (ters kÄ±rma)
        ModifyTerrainAtPoint(point, digRadius, digDepth);
        
        // âœ… Blok prefab'Ä±nÄ± spawn et (gÃ¶rsel iÃ§in)
        // TODO: Blok prefab'Ä±nÄ± voxel terrain Ã¼zerine yerleÅŸtir
        // GameObject block = Instantiate(itemDef.blockPrefab, point, Quaternion.LookRotation(normal));
    }
    
    /// <summary>
    /// âœ… Materyal tipini belirle (overload - sadece yÃ¼kseklik)
    /// </summary>
    string DetermineMaterialType(float yPosition) {
        return DetermineMaterialType(yPosition, 0f);
    }

    /// <summary>
    /// âœ… YÃœKSEK PERFORMANSLI: Terrain'i belirli bir noktada deÄŸiÅŸtir (GPU Ã¼zerinde)
    /// Yeni ChunkManager API'sini kullanÄ±r
    /// </summary>
    void ModifyTerrainAtPoint(Vector3 point, float radius, float depth) {
        // âœ… ChunkManager'dan ilgili chunk'Ä± bul
        if (_chunkManager == null) return;
        
        // âœ… Chunk koordinatÄ±nÄ± hesapla
        Vector3Int chunkCoord = _chunkManager.GetChunkCoord(point);
        
        // âœ… Chunk'Ä± al (yeni API)
        GameObject chunk = _chunkManager.GetChunk(chunkCoord);
        if (chunk == null) {
            Debug.LogWarning($"[NetworkMining] Chunk bulunamadÄ±: {chunkCoord}");
            return;
        }
        
        // âœ… MarchingCubesGPU component'ini al
        var generator = chunk.GetComponent<MarchingCubesGPU>();
        if (generator == null) {
            Debug.LogWarning("[NetworkMining] MarchingCubesGPU component'i bulunamadÄ±!");
            return;
        }
        
        // âœ… GPU Ã¼zerinde density deÄŸiÅŸtir (optimize edilmiÅŸ metod)
        generator.ModifyDensityAtPoint(point, radius, depth);
        
        // âœ… YENÄ°: KazÄ±lan materyal tipini belirle ve item drop et
        if (IsServer) {
            SpawnMinedItems(point, radius, depth);
        }
        
        Debug.Log($"[NetworkMining] KazÄ± yapÄ±lÄ±yor: {point} (Chunk: {chunkCoord}, Radius: {radius}, Depth: {depth})");
    }
    
    /// <summary>
    /// âœ… YENÄ°: KazÄ±lan materyalleri item olarak drop et
    /// Voxel terrain'de density deÄŸerine gÃ¶re materyal tipi belirlenir
    /// </summary>
    void SpawnMinedItems(Vector3 point, float radius, float depth) {
        // âœ… ItemSpawner'Ä± al
        var itemSpawner = ServiceLocator.Instance?.Get<ItemSpawner>();
        if (itemSpawner == null) {
            Debug.LogWarning("[NetworkMining] ItemSpawner bulunamadÄ±!");
            return;
        }
        
        // âœ… Materyal tipini belirle (yÃ¼ksekliÄŸe ve density'ye gÃ¶re)
        // Ã–rnek: YÃ¼zey = toprak, derinlik = taÅŸ, Ã§ok derin = maden
        string materialType = DetermineMaterialType(point.y, depth);
        
        // âœ… ItemDefinition'Ä± al (ItemDatabase'den)
        var itemDatabase = ServiceLocator.Instance?.Get<ItemDatabase>();
        if (itemDatabase == null) {
            Debug.LogWarning("[NetworkMining] ItemDatabase bulunamadÄ±!");
            return;
        }
        
        // âœ… Materyal tipine gÃ¶re item ID'si belirle
        string itemId = GetItemIdForMaterial(materialType);
        if (string.IsNullOrEmpty(itemId)) {
            return; // Bu materyal iÃ§in item yok
        }
        
        // âœ… ItemDefinition'Ä± al
        var itemDef = itemDatabase.GetItem(itemId);
        if (itemDef == null) {
            Debug.LogWarning($"[NetworkMining] Item bulunamadÄ±: {itemId}");
            return;
        }
        
        // âœ… Drop miktarÄ±nÄ± hesapla (radius ve depth'e gÃ¶re)
        int dropAmount = CalculateDropAmount(radius, depth);
        
        // âœ… Item'Ä± spawn et (ItemSpawner kullanarak)
        Vector3 spawnPos = point + Vector3.up * 0.5f; // KazÄ±lan noktanÄ±n Ã¼stÃ¼ne
        itemSpawner.SpawnItem(itemId, spawnPos, dropAmount);
        
        Debug.Log($"[NetworkMining] {dropAmount}x {itemDef.displayName} drop edildi: {spawnPos}");
    }
    
    /// <summary>
    /// âœ… Materyal tipini belirle (yÃ¼kseklik ve derinliÄŸe gÃ¶re)
    /// </summary>
    string DetermineMaterialType(float yPosition, float depth) {
        // âœ… YÃ¼kseklik bazlÄ± materyal belirleme
        if (yPosition > 50f) {
            return "GRASS"; // Ã‡imen (yÃ¼ksek yerler)
        } else if (yPosition > 20f) {
            return "DIRT"; // Toprak (orta yÃ¼kseklik)
        } else if (yPosition > 0f) {
            return "STONE"; // TaÅŸ (yÃ¼zey altÄ±)
        } else if (yPosition > -20f) {
            return "DEEP_STONE"; // Derin taÅŸ
        } else if (yPosition > -50f) {
            // âœ… Rastgele maden ÅŸansÄ± (derinlikte)
            if (Random.Range(0f, 1f) < 0.1f) { // %10 ÅŸans
                string[] ores = { "IRON_ORE", "COAL_ORE", "COPPER_ORE" };
                return ores[Random.Range(0, ores.Length)];
            }
            return "DEEP_STONE";
        } else {
            // âœ… Ã‡ok derin = nadir madenler
            if (Random.Range(0f, 1f) < 0.05f) { // %5 ÅŸans
                string[] rareOres = { "GOLD_ORE", "DIAMOND_ORE", "EMERALD_ORE" };
                return rareOres[Random.Range(0, rareOres.Length)];
            }
            return "DEEP_STONE";
        }
    }
    
    /// <summary>
    /// âœ… Materyal tipine gÃ¶re item ID'si dÃ¶ndÃ¼r
    /// </summary>
    string GetItemIdForMaterial(string materialType) {
        switch (materialType) {
            case "GRASS": return "grass_block";
            case "DIRT": return "dirt";
            case "STONE": return "stone";
            case "DEEP_STONE": return "deepslate";
            case "IRON_ORE": return "iron_ore";
            case "COAL_ORE": return "coal_ore";
            case "COPPER_ORE": return "copper_ore";
            case "GOLD_ORE": return "gold_ore";
            case "DIAMOND_ORE": return "diamond_ore";
            case "EMERALD_ORE": return "emerald_ore";
            default: return "dirt"; // VarsayÄ±lan
        }
    }
    
    /// <summary>
    /// âœ… Drop miktarÄ±nÄ± hesapla (radius ve depth'e gÃ¶re)
    /// </summary>
    int CalculateDropAmount(float radius, float depth) {
        // âœ… Hacim hesapla (kÃ¼re hacmi yaklaÅŸÄ±mÄ±)
        float volume = (4f / 3f) * Mathf.PI * radius * radius * radius;
        
        // âœ… Derinlik Ã§arpanÄ± (daha derin = daha fazla materyal)
        float depthMultiplier = 1f + (depth * 0.1f);
        
        // âœ… Drop miktarÄ± (hacim ve derinlik Ã§arpanÄ±na gÃ¶re)
        int amount = Mathf.RoundToInt(volume * depthMultiplier * 0.1f); // 0.1 = drop rate
        
        // âœ… Minimum ve maksimum sÄ±nÄ±rlar
        return Mathf.Clamp(amount, 1, 64); // En az 1, en fazla 64
    }
}
```

**GÃ¼venlik NotlarÄ±:**
- `ServerRpc` kullanÄ±mÄ±: TÃ¼m kÄ±rma/yerleÅŸtirme iÅŸlemleri sunucuda onaylanÄ±r
- Mesafe kontrolÃ¼: Hile Ã¶nleme (teleport exploit)
- Server-authoritative: TÃ¼m iÅŸlemler sunucuda doÄŸrulanÄ±r

**Minecraft Benzeri Ã–zellikler:**
- âœ… **Hold to Break:** BasÄ±lÄ± tutunca sÃ¼rekli kÄ±rma (GetMouseButton)
- âœ… **Block Hardness:** Her materyal tipinin farklÄ± kÄ±rma sÃ¼resi
- âœ… **Tool Efficiency:** Tool'a gÃ¶re kÄ±rma hÄ±zÄ± deÄŸiÅŸir
- âœ… **Break Progress:** KÄ±rma ilerlemesi gÃ¶sterilir (0-1 arasÄ±)
- âœ… **Item Drop:** KÄ±rÄ±lan bloklar item olarak dÃ¼ÅŸer
- âœ… **Item Pickup:** Fiziksel item'lar teklenebilir (E tuÅŸu)
- âœ… **Block Placement:** SaÄŸ tÄ±k ile blok yerleÅŸtirme

**NasÄ±l Ã‡alÄ±ÅŸÄ±yor?**
1. **KÄ±rma:** Sol tÄ±k basÄ±lÄ± tutunca sÃ¼rekli kÄ±rma baÅŸlar
   - Her materyal tipinin farklÄ± hardness deÄŸeri var (0.5-3.0 saniye)
   - Tool kullanÄ±lÄ±rsa kÄ±rma hÄ±zÄ± artar (efficiency Ã§arpanÄ±)
   - Progress 0'dan 1'e kadar artar, %100 olduÄŸunda blok kÄ±rÄ±lÄ±r
   - KÄ±rÄ±lan blok item olarak dÃ¼ÅŸer (PhysicalItem)

2. **YerleÅŸtirme:** SaÄŸ tÄ±k ile blok yerleÅŸtirme
   - Inventory'den aktif item alÄ±nÄ±r
   - Item'Ä±n `isPlaceable` Ã¶zelliÄŸi kontrol edilir
   - Voxel terrain'e density eklenir (ters kÄ±rma)
   - Blok prefab'Ä± spawn edilir (gÃ¶rsel)

3. **Item Pickup:** E tuÅŸu ile item toplama
   - YakÄ±ndaki PhysicalItem'lar tespit edilir (OverlapSphere)
   - Ä°lk item alÄ±nÄ±r ve inventory'ye eklenir
   - Item despawn edilir

**Item'lar Teklenebilir mi?**
- âœ… Evet! `PhysicalItem` component'i Rigidbody kullanÄ±r
- âœ… Item'lar fiziksel olarak dÃ¼ÅŸer ve yerde durur
- âœ… Oyuncu yaklaÅŸÄ±nca E tuÅŸu ile toplanabilir
- âœ… Otomatik despawn sÃ¼resi var (5 dakika varsayÄ±lan)

**KÄ±rma SÃ¼resi NasÄ±l HesaplanÄ±yor?**
```
KÄ±rma SÃ¼resi = Block Hardness / Tool Efficiency

Ã–rnek:
- Toprak (hardness: 0.5s) + El (efficiency: 1.0) = 0.5 saniye
- TaÅŸ (hardness: 1.5s) + El (efficiency: 1.0) = 1.5 saniye
- TaÅŸ (hardness: 1.5s) + Kazma (efficiency: 2.0) = 0.75 saniye
- Elmas (hardness: 3.0s) + Elmas Kazma (efficiency: 4.0) = 0.75 saniye
```

**Voxel Terrain FarkÄ±:**
- Minecraft'ta kÃ¼p kÃ¼p bloklar var, bizde pÃ¼rÃ¼zsÃ¼z voxel terrain
- KÄ±rma iÅŸlemi GPU'da density deÄŸiÅŸtirerek yapÄ±lÄ±yor
- Mesh otomatik yeniden oluÅŸturuluyor (Marching Cubes)
- Blok yerleÅŸtirme de aynÄ± ÅŸekilde density ekleyerek yapÄ±lÄ±yor

---

### 4.2 SyncWorld.cs

**Dosya:** `_Stratocraft/Scripts/Network/SyncWorld.cs`

**AmaÃ§:** DÃ¼nya seed'ini sunucudan clientlara senkronize etme

**Kod:**

```csharp
using FishNet.Object;
using FishNet.Object.Synchronizing;
using UnityEngine;

/// <summary>
/// âœ… DÃ¼nya seed senkronizasyonu (Sunucu â†’ Client)
/// </summary>
public class SyncWorld : NetworkBehaviour {
    // âœ… SyncVar: Sunucudan clientlara otomatik senkronize edilir
    [SyncVar(OnChange = nameof(OnSeedChanged))]
    private int _worldSeed = 0;
    
    private ChunkManager _chunkManager;
    private bool _seedReceived = false;

    public override void OnStartServer() {
        // âœ… Sunucu baÅŸladÄ±ÄŸÄ±nda rastgele seed seÃ§
        _worldSeed = Random.Range(1000, 999999);
        Debug.Log($"[SyncWorld] Sunucu seed'i seÃ§ildi: {_worldSeed}");
    }

    public override void OnStartClient() {
        // âœ… Client baÅŸladÄ±ÄŸÄ±nda ChunkManager'Ä± bekle
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        
        if (_chunkManager == null) {
            Debug.LogWarning("[SyncWorld] ChunkManager bulunamadÄ±, seed bekleniyor...");
        }
    }

    /// <summary>
    /// âœ… SyncVar deÄŸiÅŸtiÄŸinde Ã§aÄŸrÄ±lÄ±r (client tarafÄ±nda)
    /// </summary>
    void OnSeedChanged(int oldSeed, int newSeed, bool asServer) {
        if (asServer) return; // Sunucuda Ã§alÄ±ÅŸtÄ±rma
        
        _worldSeed = newSeed;
        _seedReceived = true;
        
        Debug.Log($"[SyncWorld] Client seed aldÄ±: {_worldSeed}");
        
        // âœ… ChunkManager'a seed'i gÃ¶nder
        if (_chunkManager != null) {
            // âœ… Player transform'u bul (NetworkPlayer'dan)
            Transform playerTransform = GetPlayerTransform();
            _chunkManager.InitializeWorld(_worldSeed, playerTransform);
        }
    }

    /// <summary>
    /// âœ… Oyuncu transform'unu bul (NetworkPlayer'dan)
    /// </summary>
    Transform GetPlayerTransform() {
        // âœ… TODO: NetworkPlayer component'inden player transform'unu al
        // Åimdilik null dÃ¶ndÃ¼r (Faz 3'te NetworkPlayer eklenecek)
        return null;
    }

    /// <summary>
    /// âœ… Seed'i al (public getter)
    /// </summary>
    public int GetWorldSeed() {
        return _worldSeed;
    }
}
```

---

## âœ… FAZ 1 & 2 SONUÃ‡ RAPORU

### ğŸ“Š Tamamlanan Ã–zellikler

**1. AltyapÄ± Kurulumu:**
- âœ… ServiceLocator sistemi (merkezi yÃ¶netici)
- âœ… GameEntry (oyun baÅŸlangÄ±Ã§ noktasÄ±)
- âœ… NetworkBootstrap (FishNet yapÄ±landÄ±rmasÄ±)
- âœ… DatabaseManager temel yapÄ±sÄ± (SQLite hazÄ±r)

**2. GPU DÃ¼nya Motoru:**
- âœ… Scrawk entegrasyonu (Marching Cubes on GPU)
- âœ… TerrainDensity.compute modifikasyonu (Offset + Seed desteÄŸi)
- âœ… ChunkManager (sonsuz dÃ¼nya sistemi)
- âœ… Optimize chunk yÃ¼kleme/silme (cache, queue, frame limit)

**3. AÄŸ Senkronizasyonu:**
- âœ… SyncWorld (seed senkronizasyonu)
- âœ… NetworkMining (kazÄ± sistemi, server-authoritative)
- âœ… Hile Ã¶nleme (mesafe kontrolÃ¼, cooldown)

**4. Performans OptimizasyonlarÄ±:**
- âœ… Dictionary cache (O(1) lookup)
- âœ… Queue sistemi (async chunk yÃ¼kleme)
- âœ… Frame limit (lag Ã¶nleme)
- âœ… Cooldown sistemi (spam Ã¶nleme)

### ğŸ¯ AmaÃ§ ve SonuÃ§

**AmaÃ§:** 1000 kiÅŸinin baÄŸlanabileceÄŸi bir aÄŸ altyapÄ±sÄ± kurmak ve GPU Ã¼zerinde Ã§alÄ±ÅŸan, kazÄ±labilir, sonsuz bir dÃ¼nya yaratmak.

**SonuÃ§:** 
- âœ… Ã‡alÄ±ÅŸan bir sonsuz dÃ¼nya sistemi (GPU hÄ±zlandÄ±rmalÄ±)
- âœ… AÄŸ altyapÄ±sÄ± hazÄ±r (FishNet)
- âœ… KazÄ±labilir dÃ¼nya (server-authoritative)
- âœ… Optimize edilmiÅŸ chunk yÃ¶netimi

### ğŸ“‚ Mevcut Dosya YapÄ±sÄ± (Faz 1 & 2 SonrasÄ±)

```
Assets/_Stratocraft/
â”œâ”€â”€ _Bootstrap/
â”‚   â”œâ”€â”€ GameEntry.cs                    âœ… YENÄ°
â”‚   â”œâ”€â”€ NetworkBootstrap.cs             âœ… YENÄ°
â”‚   â””â”€â”€ ServerConfig.json               (Manuel oluÅŸtur)
â”‚
â”œâ”€â”€ Engine/
â”‚   â”œâ”€â”€ ComputeShaders/
â”‚   â”‚   â”œâ”€â”€ TerrainDensity.compute      âœ… MODÄ°FÄ°YE EDÄ°LDÄ° (Offset + Seed)
â”‚   â”‚   â””â”€â”€ Includes/
â”‚   â”‚       â””â”€â”€ FastNoiseLite.compute   (FastNoiseLite'den kopyala)
â”‚   â”‚
â”‚   â””â”€â”€ Core/
â”‚       â”œâ”€â”€ ChunkManager.cs              âœ… YENÄ° (Optimize)
â”‚       â”œâ”€â”€ MarchingCubesGPU.cs         (Scrawk'tan - MODÄ°FÄ°YE EDÄ°LECEK)
â”‚       â”œâ”€â”€ VoxelGrid.cs                 (Scrawk'tan)
â”‚       â””â”€â”€ MeshBuilder.cs               (Scrawk'tan)
â”‚
â”œâ”€â”€ Scripts/
â”‚   â”œâ”€â”€ Core/
â”‚   â”‚   â””â”€â”€ ServiceLocator.cs           âœ… YENÄ°
â”‚   â”‚
â”‚   â”œâ”€â”€ Systems/
â”‚   â”‚   â””â”€â”€ Mining/
â”‚   â”‚       â””â”€â”€ NetworkMining.cs        âœ… YENÄ°
â”‚   â”‚
â”‚   â””â”€â”€ Network/
â”‚       â””â”€â”€ SyncWorld.cs                 âœ… YENÄ°
â”‚
â””â”€â”€ Art/
    â””â”€â”€ _External/
        â”œâ”€â”€ FishNet/                     (Asset Store'dan)
        â””â”€â”€ Scrawk/                      (GitHub'dan)
```

### ğŸ”® Gelecek Fazlarda Bu Ã–zelliklere Eklenecekler

**Faz 3 (DoÄŸa & Su):**
- `TerrainDensity.compute` iÃ§ine **FastNoiseLite** ile Biyom (Ã‡Ã¶l, Orman, Volkanik) mantÄ±ÄŸÄ± eklenecek
- Y=0 seviyesine **Okyanus** eklenecek (Crest Ocean veya basit mavi Plane)
- `ObjectSpawner.cs` yazÄ±larak, zeminin Ã¼st koordinatlarÄ±na **AÄŸaÃ§ Prefab'larÄ±** ekilecek
- `WaterSim.compute` eklenecek (su akÄ±ÅŸ fiziÄŸi)

**Faz 4 (Oyun Mekanikleri):**
- `ItemDefinition` (ScriptableObject) sistemi kurulacak
- Madenler GPU shader'Ä±nda tanÄ±mlanacak (-50'de elmas, -100'de titanyum)
- `DatabaseManager` tamamlanacak (SQLite iÅŸlemleri)
- `RitualManager.cs` kodlanacak (batarya sistemi)

**Faz 5+ (Ä°leri Ã–zellikler):**
- Klan sistemi (`TerritoryManager.cs`)
- YapÄ± sistemi (`StructureManager.cs`)
- Tuzak sistemi (`TrapSystem.cs`)
- Kontrat sistemi (`ContractManager.cs`)

---

# ğŸŒ FAZ 3: DOÄA, SU VE BÄ°YOMLAR

**AmaÃ§:** DÃ¼nyayÄ± tek dÃ¼ze taÅŸtan kurtarÄ±p; Ã‡Ã¶l, Orman, Buzul gibi bÃ¶lgelere ayÄ±rmak. Y=0 seviyesine sonsuz bir okyanus eklemek. Binlerce aÄŸacÄ± ve kayayÄ± **kasmadan** (GPU Instancing ile) yerleÅŸtirmek. Scrawk'Ä±n zeminine "Minecraft tarzÄ±" akÄ±ÅŸkan su mantÄ±ÄŸÄ±nÄ± entegre etmek.

**SÃ¼re Tahmini:** 2-3 hafta  
**Zorluk:** â­â­â­â­ (GPU Instancing ve Su SimÃ¼lasyonu)

**Motto:** **"GPU Instancing"** ve **"Data-Driven Biomes"**

---

## ğŸ› ï¸ ADIM 1: VERÄ° ODAKLI BÄ°YOM SÄ°STEMÄ° (ScriptableObjects)

### 1.1 BiomeDefinition.cs

**Dosya:** `_Stratocraft/Scripts/Core/Definitions/BiomeDefinition.cs`

**AmaÃ§:** Kod yazmadan biyom oluÅŸturabileceÄŸimiz yapÄ± (Data-Driven Design)

**Kod:**

```csharp
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// âœ… Data-Driven Biome System - ScriptableObject tabanlÄ± biyom tanÄ±mlarÄ±
/// Unity Editor'de biyom oluÅŸturmak iÃ§in kullanÄ±lÄ±r
/// </summary>
[CreateAssetMenu(fileName = "New Biome", menuName = "Stratocraft/Data/Biome", order = 1)]
public class BiomeDefinition : ScriptableObject {
    [Header("Kimlik")]
    [Tooltip("Biyom adÄ± (Ã¶rn: Desert, Forest, Mountain)")]
    public string biomeName = "Unknown";
    
    [Tooltip("Mini haritada gÃ¶rÃ¼necek renk")]
    public Color mapColor = Color.white;

    [Header("Zemin AyarlarÄ±")]
    [Tooltip("DaÄŸlÄ±k mÄ±? (1=DÃ¼z, 5=Alp DaÄŸlarÄ±)")]
    [Range(0.1f, 10f)]
    public float terrainHeightMultiplier = 1f;
    
    [Tooltip("GÃ¼rÃ¼ltÃ¼ sÄ±klÄ±ÄŸÄ± (dÃ¼ÅŸÃ¼k = geniÅŸ tepeler, yÃ¼ksek = sivri kayalar)")]
    [Range(0.001f, 0.1f)]
    public float smoothness = 0.01f;
    
    [Tooltip("Biyom geÃ§iÅŸ yumuÅŸaklÄ±ÄŸÄ± (0=keskin, 1=yumuÅŸak)")]
    [Range(0f, 1f)]
    public float transitionSmoothness = 0.5f;

    [Header("DoÄŸa Objeleri (GPU Instancing Ä°Ã§in)")]
    [Tooltip("Bu biyomda hangi aÄŸaÃ§lar Ã§Ä±kar?")]
    public List<GameObject> treePrefabs = new List<GameObject>();
    
    [Tooltip("Ne sÄ±klÄ±kla aÄŸaÃ§ Ã§Ä±kar? (0=hiÃ§, 1=Ã§ok sÄ±k)")]
    [Range(0f, 1f)]
    public float treeDensity = 0.1f;
    
    [Tooltip("AÄŸaÃ§lar arasÄ± minimum mesafe (blok)")]
    [Range(1f, 10f)]
    public float treeMinDistance = 3f;
    
    [Tooltip("Kayalar ve diÄŸer objeler")]
    public List<GameObject> rockPrefabs = new List<GameObject>();
    
    [Tooltip("Kaya yoÄŸunluÄŸu")]
    [Range(0f, 1f)]
    public float rockDensity = 0.05f;

    [Header("Maden KurallarÄ±")]
    [Tooltip("Bu biyomda Ã¶zel maden var mÄ±? (Ã–rn: Volkanik -> Obsidyen)")]
    public List<GameObject> specialOres = new List<GameObject>();
    
    [Tooltip("Maden spawn derinliÄŸi (negatif deÄŸer)")]
    public float oreDepth = -50f;
    
    [Tooltip("Maden spawn olasÄ±lÄ±ÄŸÄ± (0-1)")]
    [Range(0f, 1f)]
    public float oreSpawnChance = 0.1f;

    [Header("Ä°klim AyarlarÄ± (FastNoiseLite iÃ§in)")]
    [Tooltip("SÄ±caklÄ±k deÄŸeri (0=soÄŸuk, 1=sÄ±cak)")]
    [Range(0f, 1f)]
    public float temperature = 0.5f;
    
    [Tooltip("Nem deÄŸeri (0=kuru, 1=nemli)")]
    [Range(0f, 1f)]
    public float humidity = 0.5f;
    
    [Tooltip("Biyom spawn koÅŸulu (sÄ±caklÄ±k ve nem aralÄ±ÄŸÄ±)")]
    public Vector2 temperatureRange = new Vector2(0f, 1f);
    public Vector2 humidityRange = new Vector2(0f, 1f);

    /// <summary>
    /// âœ… Bu biyomun verilen sÄ±caklÄ±k ve nem deÄŸerlerine uygun olup olmadÄ±ÄŸÄ±nÄ± kontrol et
    /// </summary>
    public bool MatchesClimate(float temp, float hum) {
        return temp >= temperatureRange.x && temp <= temperatureRange.y &&
               hum >= humidityRange.x && hum <= humidityRange.y;
    }
}
```

**KullanÄ±m:**
1. Unity'de `Assets/_Stratocraft/Data/Biomes/` klasÃ¶rÃ¼ne saÄŸ tÄ±kla
2. `Create` â†’ `Stratocraft/Data/Biome`
3. **Desert (Ã‡Ã¶l):** Height: 0.5, Smoothness: 0.005, Temperature: 0.7-1.0, Humidity: 0.0-0.3
4. **Forest (Orman):** Height: 1.0, Smoothness: 0.01, Temperature: 0.3-0.7, Humidity: 0.4-0.8
5. **Mountain (DaÄŸ):** Height: 4.0, Smoothness: 0.02, Temperature: 0.0-0.5, Humidity: 0.5-1.0

---

### 1.2 BiomeManager.cs

**Dosya:** `_Stratocraft/Scripts/Systems/Biomes/BiomeManager.cs`

**AmaÃ§:** Biyom tanÄ±mlarÄ±nÄ± yÃ¶netme ve biyom seÃ§imi

**Kod:**

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Biyom yÃ¶neticisi - TÃ¼m biyom tanÄ±mlarÄ±nÄ± yÃ¶netir
/// </summary>
public class BiomeManager : MonoBehaviour {
    [Header("Biyom TanÄ±mlarÄ±")]
    [Tooltip("TÃ¼m biyom ScriptableObject'leri")]
    public List<BiomeDefinition> allBiomes = new List<BiomeDefinition>();
    
    [Header("VarsayÄ±lan Biyom")]
    [Tooltip("Biyom bulunamazsa kullanÄ±lacak varsayÄ±lan biyom")]
    public BiomeDefinition defaultBiome;

    // âœ… OPTÄ°MÄ°ZE: Cache - Biyom seÃ§im sonuÃ§larÄ±
    private Dictionary<Vector2Int, BiomeDefinition> _biomeCache = new Dictionary<Vector2Int, BiomeDefinition>();
    private const int CACHE_GRID_SIZE = 16; // 16x16 blok grid'de cache

    private static BiomeManager _instance;
    public static BiomeManager Instance {
        get {
            if (_instance == null) {
                _instance = FindObjectOfType<BiomeManager>();
            }
            return _instance;
        }
    }

    void Awake() {
        if (_instance == null) {
            _instance = this;
            DontDestroyOnLoad(gameObject);
        } else if (_instance != this) {
            Destroy(gameObject);
        }
        
        // âœ… ServiceLocator'a kaydet
        ServiceLocator.Instance?.Register<BiomeManager>(this);
    }

    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: Verilen pozisyon iÃ§in biyom seÃ§ (cache kullan)
    /// </summary>
    public BiomeDefinition GetBiomeForPosition(Vector3 worldPos, float temperature, float humidity) {
        // âœ… Cache key oluÅŸtur (grid bazlÄ±)
        Vector2Int cacheKey = new Vector2Int(
            Mathf.FloorToInt(worldPos.x / CACHE_GRID_SIZE),
            Mathf.FloorToInt(worldPos.z / CACHE_GRID_SIZE)
        );
        
        // âœ… Cache'den kontrol et
        if (_biomeCache.TryGetValue(cacheKey, out BiomeDefinition cachedBiome)) {
            return cachedBiome;
        }
        
        // âœ… Cache miss - Biyom seÃ§
        BiomeDefinition selectedBiome = SelectBiome(temperature, humidity);
        
        // âœ… Cache'e ekle
        _biomeCache[cacheKey] = selectedBiome;
        
        return selectedBiome;
    }

    /// <summary>
    /// âœ… SÄ±caklÄ±k ve nem deÄŸerlerine gÃ¶re biyom seÃ§
    /// </summary>
    private BiomeDefinition SelectBiome(float temperature, float humidity) {
        // âœ… Ä°lk eÅŸleÅŸen biyomu bul
        foreach (var biome in allBiomes) {
            if (biome.MatchesClimate(temperature, humidity)) {
                return biome;
            }
        }
        
        // âœ… EÅŸleÅŸme yoksa varsayÄ±lan biyomu dÃ¶ndÃ¼r
        return defaultBiome != null ? defaultBiome : allBiomes.FirstOrDefault();
    }

    /// <summary>
    /// âœ… Cache temizle (dÃ¼nya deÄŸiÅŸtiÄŸinde)
    /// </summary>
    public void ClearCache() {
        _biomeCache.Clear();
    }
}
```

---

## ğŸ¨ ADIM 2: GPU BÄ°YOM MATEMATÄ°ÄÄ° (Compute Shader)

### 2.1 TerrainDensity.compute (GÃ¼ncellenmiÅŸ - Biyomlu)

**Dosya:** `_Stratocraft/Engine/ComputeShaders/TerrainDensity.compute`

**AmaÃ§:** FastNoiseLite kullanarak biyomlarÄ± karÄ±ÅŸtÄ±rma (GPU Ã¼zerinde)

**Kod:**

```hlsl
// âœ… MODÄ°FÄ°YE EDÄ°LMÄ°Å: Biyom desteÄŸi eklenmiÅŸ TerrainDensity.compute
#pragma kernel Density

// âœ… FastNoiseLite kÃ¼tÃ¼phanesini dahil et
#include "Includes/FastNoiseLite.compute"

RWStructuredBuffer<float> Density;
int3 Size;
float3 Offset; // Chunk'Ä±n dÃ¼nyadaki konumu
float Seed;   // Sunucudan gelen tohum

// âœ… YENÄ°: Biyom parametreleri (Unity'den gÃ¶nderilecek)
// Not: HLSL'de array boyutu sabit olmalÄ±, bu yÃ¼zden maksimum biyom sayÄ±sÄ± 8
float BiomeHeights[8];      // Her biyomun yÃ¼kseklik Ã§arpanÄ±
float BiomeSmoothness[8];   // Her biyomun pÃ¼rÃ¼zsÃ¼zlÃ¼k deÄŸeri
int BiomeCount;             // Aktif biyom sayÄ±sÄ±

// âœ… YENÄ°: Ä°klim haritasÄ± parametreleri
float ClimateNoiseScale = 0.002f; // Ä°klim haritasÄ± Ã¶lÃ§eÄŸi (geniÅŸ dalgalar)

[numthreads(8, 8, 8)]
void Density (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= Size.x || id.y >= Size.y || id.z >= Size.z) return;

    // âœ… GerÃ§ek DÃ¼nya Pozisyonunu Hesapla
    float3 worldPos = id + Offset;

    // âœ… 1. Ä°KLÄ°M HARÄ°TASI (Hangi biyomdayÄ±z?)
    // Ã‡ok geniÅŸ dalgalar (0.002 frekans) - biyomlar yavaÅŸ deÄŸiÅŸir
    float temperature = GetNoise(worldPos.xz * ClimateNoiseScale, Seed);
    float humidity = GetNoise(worldPos.xz * ClimateNoiseScale, Seed + 500);
    
    // âœ… Normalize et (0-1 aralÄ±ÄŸÄ±na)
    temperature = (temperature + 1.0) * 0.5;
    humidity = (humidity + 1.0) * 0.5;

    // âœ… 2. BÄ°YOM SEÃ‡Ä°MÄ° VE YÃœKSEKLÄ°K KARIÅIMI
    float targetHeight = 0.0;
    float smoothness = 0.01;
    
    // âœ… Basit biyom seÃ§imi (ileride daha karmaÅŸÄ±k olabilir)
    if (temperature > 0.5) {
        // SÄ±cak bÃ¶lgeler
        if (humidity < 0.3) {
            // Ã‡Ã–L (AlÃ§ak, geniÅŸ tepeler)
            smoothness = 0.005;
            targetHeight = GetNoise(worldPos.xz * smoothness, Seed) * 20.0;
        } else if (humidity < 0.6) {
            // SAVANA (Orta yÃ¼kseklik)
            smoothness = 0.01;
            targetHeight = GetNoise(worldPos.xz * smoothness, Seed + 100) * 40.0;
        } else {
            // TROPÄ°KAL ORMAN (YÃ¼ksek, yoÄŸun)
            smoothness = 0.015;
            targetHeight = GetNoise(worldPos.xz * smoothness, Seed + 200) * 80.0;
        }
    } else {
        // SoÄŸuk bÃ¶lgeler
        if (humidity < 0.3) {
            // BUZUL (DÃ¼z, soÄŸuk)
            smoothness = 0.003;
            targetHeight = GetNoise(worldPos.xz * smoothness, Seed + 300) * 10.0;
        } else if (humidity < 0.6) {
            // ORMAN (Orta yÃ¼kseklik, aÄŸaÃ§lÄ±)
            smoothness = 0.01;
            targetHeight = GetNoise(worldPos.xz * smoothness, Seed + 400) * 60.0;
        } else {
            // DAÄ (YÃ¼ksek, sivri)
            smoothness = 0.02;
            targetHeight = GetNoise(worldPos.xz * smoothness, Seed + 500) * 120.0;
        }
    }

    // âœ… 3. DETAY NOISE (YÃ¼zey detaylarÄ± iÃ§in)
    float detailNoise = GetNoise(worldPos * 0.1, Seed + 1000) * 5.0;
    targetHeight += detailNoise;

    // âœ… 4. YOÄUNLUK HESABI (Marching Cubes iÃ§in)
    // YÃ¼kseklik pos.y'den bÃ¼yÃ¼kse orasÄ± doludur (1), yoksa boÅŸtur (-1)
    float density = targetHeight - worldPos.y;
    
    // âœ… 5. MAÄARA SÄ°STEMÄ° (3D Noise)
    // EÄŸer yerin altÄ±ndaysak ve 3D gÃ¼rÃ¼ltÃ¼ boÅŸluk diyorsa orayÄ± boÅŸalt
    if (worldPos.y < -10.0) {
        float caveNoise = GetNoise3D(worldPos * 0.05, Seed + 2000);
        if (caveNoise > 0.6) {
            density = -1.0; // MaÄŸara boÅŸluÄŸu
        }
    }

    // âœ… 6. OKYANUS SEVÄ°YESÄ° (Y=0 altÄ± su)
    if (worldPos.y < 0.0 && density > -1.0) {
        // Okyanus tabanÄ± (daha yumuÅŸak geÃ§iÅŸ)
        density = -0.5;
    }

    int index = id.x + id.y * Size.x + id.z * Size.x * Size.y;
    Density[index] = density;
}
```

**Ã–nemli Notlar:**
- `FastNoiseLite.compute` dosyasÄ± `Includes/` klasÃ¶rÃ¼nde olmalÄ±
- `GetNoise3D()` fonksiyonu FastNoiseLite'da mevcut olmalÄ±
- Biyom seÃ§imi ÅŸimdilik basit (ileride BiomeManager'dan gelen verilerle geniÅŸletilebilir)

---

## ğŸŒ² ADIM 3: BÄ°NLERCE AÄAÃ‡ DÄ°KMEK (GPU Instancing)

### 3.1 VegetationSpawner.cs (Optimize EdilmiÅŸ)

**Dosya:** `_Stratocraft/Engine/Core/VegetationSpawner.cs`

**AmaÃ§:** Chunk oluÅŸtuÄŸu an, yÃ¼zey noktalarÄ±nÄ± bulup oraya aÄŸaÃ§ koymak (GPU Instancing ile)

**Kod:**

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Collections;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Vegetation spawner - GPU Instancing ve Object Pooling ile
/// 1000+ aÄŸaÃ§ performans sorunu yaratmadan spawn eder
/// </summary>
public class VegetationSpawner : MonoBehaviour {
    [Header("Ayarlar")]
    [Tooltip("Åimdilik tek biyom test edelim (ileride BiomeManager'dan alÄ±nacak)")]
    public BiomeDefinition currentBiome;
    
    [Tooltip("Zemin layer mask (raycast iÃ§in)")]
    public LayerMask groundLayer = 1; // Default layer
    
    [Header("Performans")]
    [Tooltip("Chunk baÅŸÄ±na maksimum aÄŸaÃ§ sayÄ±sÄ±")]
    public int maxTreesPerChunk = 50;
    
    [Tooltip("Chunk baÅŸÄ±na maksimum kaya sayÄ±sÄ±")]
    public int maxRocksPerChunk = 20;
    
    [Tooltip("AÄŸaÃ§ spawn mesafesi (oyuncudan uzakta spawn etme)")]
    public float spawnDistance = 100f;
    
    [Tooltip("GPU Instancing kullan (performans iÃ§in)")]
    public bool useGPUInstancing = true;

    // âœ… OPTÄ°MÄ°ZE: Object Pooling iÃ§in
    private Dictionary<GameObject, Queue<GameObject>> _objectPools = new Dictionary<GameObject, Queue<GameObject>>();
    private Dictionary<GameObject, List<GameObject>> _activeObjects = new Dictionary<GameObject, List<GameObject>>();
    
    // âœ… OPTÄ°MÄ°ZE: GPU Instancing iÃ§in
    private Dictionary<GameObject, List<Matrix4x4>> _instancingMatrices = new Dictionary<GameObject, List<Matrix4x4>>();
    private Dictionary<GameObject, Mesh> _instancingMeshes = new Dictionary<GameObject, Mesh>();
    private Dictionary<GameObject, Material> _instancingMaterials = new Dictionary<GameObject, Material>();
    
    // âœ… OPTÄ°MÄ°ZE: Chunk bazlÄ± cache (aynÄ± chunk'Ä± tekrar spawn etme)
    private HashSet<Vector3Int> _spawnedChunks = new HashSet<Vector3Int>();

    void Start() {
        // âœ… ServiceLocator'a kaydet
        ServiceLocator.Instance?.Register<VegetationSpawner>(this);
    }

    /// <summary>
    /// âœ… ChunkManager bu fonksiyonu Ã§aÄŸÄ±racak
    /// </summary>
    public void SpawnVegetationForChunk(GameObject chunk, Vector3 chunkPos) {
        if (currentBiome == null) {
            Debug.LogWarning("[VegetationSpawner] Biyom tanÄ±mÄ± yok!");
            return;
        }
        
        // âœ… Cache kontrolÃ¼ (aynÄ± chunk'Ä± tekrar spawn etme)
        Vector3Int chunkCoord = new Vector3Int(
            Mathf.FloorToInt(chunkPos.x / 32),
            0,
            Mathf.FloorToInt(chunkPos.z / 32)
        );
        
        if (_spawnedChunks.Contains(chunkCoord)) {
            return; // Zaten spawn edilmiÅŸ
        }
        
        _spawnedChunks.Add(chunkCoord);
        
        // âœ… Rastgelelik iÃ§in Seed kullan (deterministik)
        int seed = (int)(chunkPos.x * 1000 + chunkPos.z);
        Random.InitState(seed);

        // âœ… AÄŸaÃ§ spawn et
        if (currentBiome.treePrefabs != null && currentBiome.treePrefabs.Count > 0) {
            SpawnTrees(chunk, chunkPos);
        }
        
        // âœ… Kaya spawn et
        if (currentBiome.rockPrefabs != null && currentBiome.rockPrefabs.Count > 0) {
            SpawnRocks(chunk, chunkPos);
        }
    }

    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: AÄŸaÃ§ spawn et (GPU Instancing veya Object Pooling ile)
    /// </summary>
    void SpawnTrees(GameObject chunk, Vector3 chunkPos) {
        int treeCount = Mathf.Min(
            (int)(currentBiome.treeDensity * maxTreesPerChunk),
            maxTreesPerChunk
        );
        
        List<Vector3> treePositions = new List<Vector3>();
        
        // âœ… AÄŸaÃ§ pozisyonlarÄ±nÄ± hesapla
        for (int i = 0; i < treeCount; i++) {
            // Chunk iÃ§inde rastgele x,z seÃ§
            float x = Random.Range(0f, 32f) + chunkPos.x;
            float z = Random.Range(0f, 32f) + chunkPos.z;
            
            // âœ… Minimum mesafe kontrolÃ¼ (aÄŸaÃ§lar Ã§ok yakÄ±n olmasÄ±n)
            bool tooClose = false;
            foreach (var existingPos in treePositions) {
                float distance = Vector3.Distance(new Vector3(x, 0, z), existingPos);
                if (distance < currentBiome.treeMinDistance) {
                    tooClose = true;
                    break;
                }
            }
            if (tooClose) continue;
            
            // âœ… YukarÄ±dan aÅŸaÄŸÄ± Ä±ÅŸÄ±n at (YÃ¼zeyi bulmak iÃ§in)
            RaycastHit hit;
            Vector3 rayStart = new Vector3(x, 200, z);
            
            if (Physics.Raycast(rayStart, Vector3.down, out hit, 300f, groundLayer)) {
                // âœ… Deniz seviyesinin altÄ±ndaysa aÄŸaÃ§ dikme
                if (hit.point.y < 2f) continue;
                
                // âœ… EÄŸim kontrolÃ¼ (Ã§ok dik yerlere aÄŸaÃ§ dikme)
                float slope = Vector3.Angle(hit.normal, Vector3.up);
                if (slope > 45f) continue; // 45 dereceden dik yerlere aÄŸaÃ§ dikme
                
                treePositions.Add(hit.point);
            }
        }
        
        // âœ… AÄŸaÃ§larÄ± spawn et
        foreach (var pos in treePositions) {
            GameObject treePrefab = currentBiome.treePrefabs[Random.Range(0, currentBiome.treePrefabs.Count)];
            PlaceVegetation(treePrefab, pos, chunk.transform);
        }
    }

    /// <summary>
    /// âœ… Kaya spawn et
    /// </summary>
    void SpawnRocks(GameObject chunk, Vector3 chunkPos) {
        int rockCount = Mathf.Min(
            (int)(currentBiome.rockDensity * maxRocksPerChunk),
            maxRocksPerChunk
        );
        
        for (int i = 0; i < rockCount; i++) {
            float x = Random.Range(0f, 32f) + chunkPos.x;
            float z = Random.Range(0f, 32f) + chunkPos.z;
            
            RaycastHit hit;
            Vector3 rayStart = new Vector3(x, 200, z);
            
            if (Physics.Raycast(rayStart, Vector3.down, out hit, 300f, groundLayer)) {
                if (hit.point.y < 2f) continue;
                
                GameObject rockPrefab = currentBiome.rockPrefabs[Random.Range(0, currentBiome.rockPrefabs.Count)];
                PlaceVegetation(rockPrefab, hit.point, chunk.transform);
            }
        }
    }

    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: Vegetation yerleÅŸtir (GPU Instancing veya Object Pooling)
    /// </summary>
    void PlaceVegetation(GameObject prefab, Vector3 pos, Transform parent) {
        if (prefab == null) return;
        
        if (useGPUInstancing) {
            // âœ… GPU Instancing kullan (1000+ obje iÃ§in)
            AddToInstancingBatch(prefab, pos);
        } else {
            // âœ… Object Pooling kullan (daha az obje iÃ§in)
            GameObject obj = GetPooledObject(prefab);
            obj.transform.position = pos;
            obj.transform.rotation = Quaternion.Euler(0, Random.Range(0f, 360f), 0);
            obj.transform.localScale = Vector3.one * Random.Range(0.8f, 1.2f);
            obj.transform.SetParent(parent);
            obj.SetActive(true);
        }
    }

    /// <summary>
    /// âœ… GPU Instancing batch'e ekle
    /// </summary>
    void AddToInstancingBatch(GameObject prefab, Vector3 pos) {
        if (!_instancingMatrices.ContainsKey(prefab)) {
            _instancingMatrices[prefab] = new List<Matrix4x4>();
            
            // âœ… Mesh ve Material'i cache'le
            MeshFilter mf = prefab.GetComponent<MeshFilter>();
            MeshRenderer mr = prefab.GetComponent<MeshRenderer>();
            
            if (mf != null && mr != null) {
                _instancingMeshes[prefab] = mf.sharedMesh;
                _instancingMaterials[prefab] = mr.sharedMaterial;
            }
        }
        
        // âœ… Transform matrix'i oluÅŸtur
        Matrix4x4 matrix = Matrix4x4.TRS(
            pos,
            Quaternion.Euler(0, Random.Range(0f, 360f), 0),
            Vector3.one * Random.Range(0.8f, 1.2f)
        );
        
        _instancingMatrices[prefab].Add(matrix);
    }

    /// <summary>
    /// âœ… GPU Instancing batch'lerini render et (her frame)
    /// </summary>
    void Update() {
        if (!useGPUInstancing) return;
        
        // âœ… Her prefab iÃ§in instancing batch'i render et
        foreach (var kvp in _instancingMatrices) {
            GameObject prefab = kvp.Key;
            List<Matrix4x4> matrices = kvp.Value;
            
            if (matrices.Count == 0) continue;
            if (!_instancingMeshes.ContainsKey(prefab)) continue;
            if (!_instancingMaterials.ContainsKey(prefab)) continue;
            
            Mesh mesh = _instancingMeshes[prefab];
            Material material = _instancingMaterials[prefab];
            
            // âœ… Unity'nin GPU Instancing limiti: 1023 obje
            int batchSize = 1023;
            int batchCount = Mathf.CeilToInt((float)matrices.Count / batchSize);
            
            for (int i = 0; i < batchCount; i++) {
                int startIndex = i * batchSize;
                int count = Mathf.Min(batchSize, matrices.Count - startIndex);
                
                // âœ… GetRange yerine manuel array oluÅŸtur
                Matrix4x4[] batch = new Matrix4x4[count];
                for (int j = 0; j < count; j++) {
                    batch[j] = matrices[startIndex + j];
                }
                Graphics.DrawMeshInstanced(mesh, 0, material, batch);
            }
        }
    }

    /// <summary>
    /// âœ… Object Pooling: Pool'dan obje al
    /// </summary>
    GameObject GetPooledObject(GameObject prefab) {
        if (!_objectPools.ContainsKey(prefab)) {
            _objectPools[prefab] = new Queue<GameObject>();
            _activeObjects[prefab] = new List<GameObject>();
        }
        
        GameObject obj;
        if (_objectPools[prefab].Count > 0) {
            obj = _objectPools[prefab].Dequeue();
        } else {
            obj = Instantiate(prefab);
        }
        
        _activeObjects[prefab].Add(obj);
        return obj;
    }

    /// <summary>
    /// âœ… Chunk silindiÄŸinde vegetation'Ä± da sil
    /// </summary>
    public void ClearVegetationForChunk(Vector3Int chunkCoord) {
        _spawnedChunks.Remove(chunkCoord);
        // âœ… GPU Instancing batch'lerini temizle
        _instancingMatrices.Clear();
    }
}
```

**Optimizasyon NotlarÄ±:**
- **GPU Instancing:** 1000+ aÄŸaÃ§ iÃ§in `Graphics.DrawMeshInstanced()` kullanÄ±lÄ±r (CPU'yu yormaz)
- **Object Pooling:** Daha az obje iÃ§in pool sistemi (memory efficient)
- **Cache:** AynÄ± chunk'Ä± tekrar spawn etme (performans)
- **Raycast Optimizasyonu:** Sadece gerekli noktalarda raycast

---

### 3.2 ChunkManager.cs - Vegetation Entegrasyonu

**Dosya:** `_Stratocraft/Engine/Core/ChunkManager.cs` (yukarÄ±daki koda eklenecek)

```csharp
// ChunkManager.cs iÃ§ine eklenecek
private VegetationSpawner _vegetationSpawner;

void Start() {
    _vegetationSpawner = ServiceLocator.Instance?.Get<VegetationSpawner>();
}

void SpawnChunk(Vector3Int coord) {
    // ... (mevcut kod) ...
    
    // âœ… Vegetation spawn et (chunk oluÅŸturulduktan sonra)
    if (_vegetationSpawner != null) {
        _vegetationSpawner.SpawnVegetationForChunk(newChunk, worldPos);
    }
}

void UnloadChunk(Vector3Int coord) {
    // ... (mevcut kod) ...
    
    // âœ… Vegetation temizle
    if (_vegetationSpawner != null) {
        _vegetationSpawner.ClearVegetationForChunk(coord);
    }
}
```

---

## ğŸŒŠ ADIM 4: SU SÄ°STEMÄ° (Okyanus ve AkÄ±ÅŸkanlar)

### 4.1 Sonsuz Okyanus (GÃ¶rsel)

**Dosya:** `_Stratocraft/Scripts/Systems/Water/OceanPlane.cs`

**AmaÃ§:** Y=0 seviyesinde sonsuz okyanus (oyuncuyu takip eden dÃ¼zlem)

**Kod:**

```csharp
using UnityEngine;

/// <summary>
/// âœ… Sonsuz okyanus dÃ¼zlemi - Oyuncuyu takip eder
/// </summary>
public class OceanPlane : MonoBehaviour {
    [Header("Ayarlar")]
    [Tooltip("Okyanus dÃ¼zlemi boyutu")]
    public float planeSize = 10000f;
    
    [Tooltip("Oyuncuyu takip etme hÄ±zÄ± (smooth)")]
    public float followSpeed = 10f;
    
    [Tooltip("Takip edilecek oyuncu (null ise Camera.main'i takip eder)")]
    public Transform targetPlayer;

    private Transform _cameraTransform;

    void Start() {
        // âœ… DÃ¼zlemi oluÅŸtur
        CreateOceanPlane();
        
        // âœ… Kamera transform'unu al
        if (targetPlayer != null) {
            _cameraTransform = targetPlayer;
        } else if (Camera.main != null) {
            _cameraTransform = Camera.main.transform;
        }
    }

    void Update() {
        if (_cameraTransform == null) return;
        
        // âœ… Oyuncuyu takip et (sadece X ve Z ekseninde)
        Vector3 targetPos = new Vector3(
            _cameraTransform.position.x,
            0f, // Y=0 (deniz seviyesi)
            _cameraTransform.position.z
        );
        
        transform.position = Vector3.Lerp(transform.position, targetPos, Time.deltaTime * followSpeed);
    }

    /// <summary>
    /// âœ… Okyanus dÃ¼zlemini oluÅŸtur
    /// </summary>
    void CreateOceanPlane() {
        // âœ… Mesh oluÅŸtur
        Mesh mesh = new Mesh();
        mesh.name = "OceanPlane";
        
        // âœ… Basit dÃ¼zlem mesh'i (4 kÃ¶ÅŸe)
        Vector3[] vertices = new Vector3[4] {
            new Vector3(-planeSize, 0, -planeSize),
            new Vector3(planeSize, 0, -planeSize),
            new Vector3(-planeSize, 0, planeSize),
            new Vector3(planeSize, 0, planeSize)
        };
        
        int[] triangles = new int[6] {
            0, 2, 1,
            2, 3, 1
        };
        
        Vector2[] uv = new Vector2[4] {
            new Vector2(0, 0),
            new Vector2(1, 0),
            new Vector2(0, 1),
            new Vector2(1, 1)
        };
        
        mesh.vertices = vertices;
        mesh.triangles = triangles;
        mesh.uv = uv;
        mesh.RecalculateNormals();
        
        // âœ… MeshFilter ve MeshRenderer ekle
        MeshFilter mf = gameObject.GetComponent<MeshFilter>();
        if (mf == null) mf = gameObject.AddComponent<MeshFilter>();
        mf.mesh = mesh;
        
        MeshRenderer mr = gameObject.GetComponent<MeshRenderer>();
        if (mr == null) mr = gameObject.AddComponent<MeshRenderer>();
        
        // âœ… Okyanus materyali oluÅŸtur (veya Asset'ten yÃ¼kle)
        Material oceanMat = CreateOceanMaterial();
        mr.material = oceanMat;
        
        // âœ… Pozisyonu ayarla
        transform.position = Vector3.zero;
    }

    /// <summary>
    /// âœ… Okyanus materyali oluÅŸtur (basit transparan mavi)
    /// </summary>
    Material CreateOceanMaterial() {
        Material mat = new Material(Shader.Find("Standard"));
        mat.SetFloat("_Mode", 3); // Transparent mode
        mat.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.SrcAlpha);
        mat.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);
        mat.SetInt("_ZWrite", 0);
        mat.DisableKeyword("_ALPHATEST_ON");
        mat.EnableKeyword("_ALPHABLEND_ON");
        mat.DisableKeyword("_ALPHAPREMULTIPLY_ON");
        mat.renderQueue = 3000;
        
        // âœ… Mavi renk
        mat.color = new Color(0.2f, 0.5f, 0.8f, 0.7f);
        
        return mat;
    }
}
```

**KullanÄ±m:**
1. Sahneye boÅŸ GameObject ekle
2. `OceanPlane.cs` scriptini ekle
3. `planeSize` deÄŸerini ayarla (Ã¶rn: 10000)
4. Okyanus otomatik oluÅŸturulur ve oyuncuyu takip eder

---

### 4.2 Voxel Su SimÃ¼lasyonu (Opsiyonel - Zor)

**Dosya:** `_Stratocraft/Engine/ComputeShaders/WaterSim.compute`

**AmaÃ§:** Minecraft tarzÄ± akÄ±ÅŸkan su fiziÄŸi (GPU Ã¼zerinde)

**Kod:**

```hlsl
// âœ… Voxel Su SimÃ¼lasyonu - Minecraft tarzÄ± matematiksel akÄ±ÅŸkan su
#pragma kernel UpdateWater

RWStructuredBuffer<int> WaterGrid;      // 0:BoÅŸ, 1-7:Su seviyesi, 8:Kaynak Su
RWStructuredBuffer<float> TerrainDensity; // Zemin yoÄŸunluÄŸu
int3 Size;

// âœ… Su seviyesi sabitleri
#define WATER_EMPTY 0
#define WATER_SOURCE 8
#define WATER_MAX_LEVEL 7

[numthreads(8, 8, 8)]
void UpdateWater (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= Size.x || id.y >= Size.y || id.z >= Size.z) return;
    
    int index = id.x + id.y * Size.x + id.z * Size.x * Size.y;
    int waterLevel = WaterGrid[index];
    
    // âœ… Su yoksa iÅŸlem yapma
    if (waterLevel == WATER_EMPTY) return;
    
    // âœ… Kaynak su hiÃ§ deÄŸiÅŸmez
    if (waterLevel == WATER_SOURCE) return;
    
    int3 pos = int3(id.x, id.y, id.z);
    
    // âœ… 1. Ã–NCELÄ°K: AÅAÄI AKIÅ (Gravity)
    int indexBelow = index - Size.x;
    if (id.y > 0 && 
        TerrainDensity[indexBelow] < 0 && 
        WaterGrid[indexBelow] == WATER_EMPTY) {
        
        // AÅŸaÄŸÄ± akÄ±ÅŸ - tam su seviyesi
        WaterGrid[indexBelow] = WATER_MAX_LEVEL;
        WaterGrid[index] = WATER_EMPTY;
        return; // AÅŸaÄŸÄ± akÄ±ÅŸ varsa diÄŸer akÄ±ÅŸlarÄ± yapma
    }
    
    // âœ… 2. Ã–NCELÄ°K: YAN TARAFA AKIÅ (4 yÃ¶n: Kuzey, GÃ¼ney, DoÄŸu, BatÄ±)
    // Su seviyesi 1'den fazlaysa yan tarafa akar
    if (waterLevel > 1) {
        int3 directions[4] = {
            int3(0, 0, 1),  // Kuzey
            int3(0, 0, -1), // GÃ¼ney
            int3(1, 0, 0),  // DoÄŸu
            int3(-1, 0, 0)  // BatÄ±
        };
        
        for (int i = 0; i < 4; i++) {
            int3 neighborPos = pos + directions[i];
            
            // SÄ±nÄ±r kontrolÃ¼
            if (neighborPos.x < 0 || neighborPos.x >= Size.x ||
                neighborPos.y < 0 || neighborPos.y >= Size.y ||
                neighborPos.z < 0 || neighborPos.z >= Size.z) {
                continue;
            }
            
            int neighborIndex = neighborPos.x + neighborPos.y * Size.x + neighborPos.z * Size.x * Size.y;
            
            // KomÅŸu boÅŸ mu ve terrain yok mu?
            if (TerrainDensity[neighborIndex] < 0 && 
                WaterGrid[neighborIndex] == WATER_EMPTY) {
                
                // Yan tarafa akÄ±ÅŸ - su seviyesi 1 azalÄ±r
                WaterGrid[neighborIndex] = waterLevel - 1;
                WaterGrid[index] = WATER_EMPTY;
                return; // Yan akÄ±ÅŸ varsa yayÄ±lmayÄ± yapma
            }
        }
    }
    
    // âœ… 3. Ã–NCELÄ°K: YAYILMA MEKANÄ°ÄÄ° (Su seviyesi dÃ¼ÅŸÃ¼kse)
    // Su seviyesi 1 ise ve altÄ±nda su yoksa yayÄ±lma yapÄ±lmaz
    if (waterLevel == 1) {
        // AltÄ±nda su var mÄ± kontrol et
        if (id.y > 0) {
            int indexBelow = index - Size.x;
            if (WaterGrid[indexBelow] > WATER_EMPTY) {
                // AltÄ±nda su var, yayÄ±lma yapma
                return;
            }
        }
    }
    
    // âœ… YayÄ±lma: Su seviyesi 1'den fazlaysa ve altÄ±nda su yoksa
    // komÅŸulara yayÄ±l (sadece aynÄ± seviyede veya daha dÃ¼ÅŸÃ¼k seviyede)
    if (waterLevel > 1) {
        int3 directions[4] = {
            int3(0, 0, 1),  // Kuzey
            int3(0, 0, -1), // GÃ¼ney
            int3(1, 0, 0),  // DoÄŸu
            int3(-1, 0, 0)  // BatÄ±
        };
        
        for (int i = 0; i < 4; i++) {
            int3 neighborPos = pos + directions[i];
            
            // SÄ±nÄ±r kontrolÃ¼
            if (neighborPos.x < 0 || neighborPos.x >= Size.x ||
                neighborPos.y < 0 || neighborPos.y >= Size.y ||
                neighborPos.z < 0 || neighborPos.z >= Size.z) {
                continue;
            }
            
            int neighborIndex = neighborPos.x + neighborPos.y * Size.x + neighborPos.z * Size.x * Size.y;
            int neighborWaterLevel = WaterGrid[neighborIndex];
            
            // KomÅŸu boÅŸ mu veya daha dÃ¼ÅŸÃ¼k seviyede su var mÄ±?
            if (TerrainDensity[neighborIndex] < 0) {
                if (neighborWaterLevel == WATER_EMPTY) {
                    // BoÅŸ komÅŸuya yayÄ±l (seviye 1 azalÄ±r)
                    WaterGrid[neighborIndex] = waterLevel - 1;
                } else if (neighborWaterLevel < waterLevel - 1) {
                    // Daha dÃ¼ÅŸÃ¼k seviyede su varsa denge saÄŸla
                    int newLevel = (waterLevel + neighborWaterLevel) / 2;
                    WaterGrid[neighborIndex] = newLevel;
                    WaterGrid[index] = newLevel;
                }
            }
        }
    }
}
```

**C# TarafÄ± (WaterSimulator.cs):**

**Dosya:** `_Stratocraft/Scripts/Systems/Water/WaterSimulator.cs`

**Kod:**

```csharp
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Voxel su simÃ¼latÃ¶rÃ¼ (GPU Ã¼zerinde)
/// Referans: Minecraft tarzÄ± akÄ±ÅŸkan su fiziÄŸi
/// </summary>
public class WaterSimulator : MonoBehaviour {
    [Header("Ayarlar")]
    [Tooltip("WaterSim.compute shader'Ä±")]
    public ComputeShader waterCompute;
    
    [Tooltip("Su gÃ¼ncelleme aralÄ±ÄŸÄ± (saniye) - DÃ¼ÅŸÃ¼k deÄŸer = daha hÄ±zlÄ± akÄ±ÅŸ")]
    public float updateInterval = 0.2f; // 5 kez/saniye (performans iÃ§in)
    
    [Tooltip("Chunk boyutu (ChunkManager'dan alÄ±nacak)")]
    public int chunkSize = 32;
    
    [Header("Performans")]
    [Tooltip("Maksimum aktif su voxel sayÄ±sÄ±")]
    public int maxWaterVoxels = 10000;
    
    // âœ… OPTÄ°MÄ°ZE: GPU Buffer'larÄ±
    private ComputeBuffer _waterGrid;
    private ComputeBuffer _terrainDensity;
    private int _updateKernel;
    private float _lastUpdate;
    
    // âœ… OPTÄ°MÄ°ZE: Chunk bazlÄ± su grid cache
    private Dictionary<Vector3Int, ComputeBuffer> _chunkWaterGrids = new Dictionary<Vector3Int, ComputeBuffer>();
    
    // âœ… OPTÄ°MÄ°ZE: ChunkManager referansÄ±
    private ChunkManager _chunkManager;
    
    void Start() {
        // âœ… ServiceLocator'dan ChunkManager al
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        
        if (waterCompute == null) {
            waterCompute = Resources.Load<ComputeShader>("ComputeShaders/WaterSim");
            if (waterCompute == null) {
                Debug.LogWarning("[WaterSimulator] WaterSim.compute bulunamadÄ±! Su simÃ¼lasyonu devre dÄ±ÅŸÄ±.");
                enabled = false;
                return;
            }
        }
        
        _updateKernel = waterCompute.FindKernel("UpdateWater");
        
        // âœ… ServiceLocator'a kaydet
        ServiceLocator.Instance?.Register<WaterSimulator>(this);
        
        Debug.Log("[WaterSimulator] Su simÃ¼latÃ¶rÃ¼ baÅŸlatÄ±ldÄ±");
    }
    
    void Update() {
        if (waterCompute == null || _chunkManager == null) return;
        
        // âœ… Cooldown kontrolÃ¼ (performans iÃ§in)
        if (Time.time - _lastUpdate < updateInterval) return;
        _lastUpdate = Time.time;
        
        // âœ… Aktif chunk'lar iÃ§in su simÃ¼lasyonu Ã§alÄ±ÅŸtÄ±r
        UpdateWaterForActiveChunks();
    }
    
    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: Aktif chunk'lar iÃ§in su simÃ¼lasyonu
    /// Scrawk'Ä±n chunk sistemiyle entegre
    /// </summary>
    void UpdateWaterForActiveChunks() {
        if (_chunkManager == null) return;
        
        // âœ… ChunkManager'dan aktif chunk koordinatlarÄ±nÄ± al
        List<Vector3Int> activeChunks = _chunkManager.GetActiveChunkCoords();
        
        foreach (var chunkCoord in activeChunks) {
            // âœ… Su grid'i yoksa oluÅŸtur
            if (!_chunkWaterGrids.ContainsKey(chunkCoord)) {
                CreateWaterGridForChunk(chunkCoord);
            }
            
            ComputeBuffer waterGrid = _chunkWaterGrids[chunkCoord];
            
            // âœ… Terrain density buffer'Ä±nÄ± al (ChunkManager'dan - Scrawk sistemi)
            ComputeBuffer terrainDensity = GetTerrainDensityForChunk(chunkCoord);
            if (terrainDensity == null) {
                // âœ… Chunk henÃ¼z hazÄ±r deÄŸil, atla
                continue;
            }
            
            // âœ… GPU Ã¼zerinde su simÃ¼lasyonu Ã§alÄ±ÅŸtÄ±r
            waterCompute.SetBuffer(_updateKernel, "WaterGrid", waterGrid);
            waterCompute.SetBuffer(_updateKernel, "TerrainDensity", terrainDensity);
            waterCompute.SetInts("Size", chunkSize, chunkSize, chunkSize);
            
            int threadGroups = Mathf.CeilToInt(chunkSize / 8f);
            waterCompute.Dispatch(_updateKernel, threadGroups, threadGroups, threadGroups);
        }
        
        // âœ… Silinen chunk'larÄ±n su grid'lerini temizle
        List<Vector3Int> chunksToRemove = new List<Vector3Int>();
        foreach (var coord in _chunkWaterGrids.Keys) {
            if (!activeChunks.Contains(coord)) {
                chunksToRemove.Add(coord);
            }
        }
        
        foreach (var coord in chunksToRemove) {
            RemoveWaterGridForChunk(coord);
        }
    }
    
    /// <summary>
    /// âœ… Chunk iÃ§in su grid'i oluÅŸtur
    /// </summary>
    public void CreateWaterGridForChunk(Vector3Int chunkCoord) {
        if (_chunkWaterGrids.ContainsKey(chunkCoord)) {
            return; // Zaten var
        }
        
        int voxelCount = chunkSize * chunkSize * chunkSize;
        ComputeBuffer waterGrid = new ComputeBuffer(voxelCount, sizeof(int));
        
        // âœ… BaÅŸlangÄ±Ã§ deÄŸerleri: 0 (boÅŸ)
        int[] initialData = new int[voxelCount];
        waterGrid.SetData(initialData);
        
        _chunkWaterGrids[chunkCoord] = waterGrid;
    }
    
    /// <summary>
    /// âœ… Chunk iÃ§in su grid'ini temizle
    /// </summary>
    public void RemoveWaterGridForChunk(Vector3Int chunkCoord) {
        if (_chunkWaterGrids.TryGetValue(chunkCoord, out ComputeBuffer waterGrid)) {
            waterGrid.Release();
            _chunkWaterGrids.Remove(chunkCoord);
        }
    }
    
    /// <summary>
    /// âœ… ChunkManager'dan terrain density buffer'Ä±nÄ± al
    /// Scrawk'Ä±n MarchingCubesGPU sistemiyle uyumlu
    /// </summary>
    ComputeBuffer GetTerrainDensityForChunk(Vector3Int chunkCoord) {
        if (_chunkManager == null) return null;
        
        // âœ… ChunkManager'dan density buffer'Ä± al (yeni API)
        return _chunkManager.GetDensityBufferForChunk(chunkCoord);
    }
    
    /// <summary>
    /// âœ… Belirli bir pozisyona su ekle (kaynak su)
    /// </summary>
    public void AddWaterSource(Vector3 worldPos) {
        if (_chunkManager == null) return;
        
        Vector3Int chunkCoord = _chunkManager.GetChunkCoord(worldPos);
        
        if (!_chunkWaterGrids.TryGetValue(chunkCoord, out ComputeBuffer waterGrid)) {
            CreateWaterGridForChunk(chunkCoord);
            waterGrid = _chunkWaterGrids[chunkCoord];
        }
        
        // âœ… Chunk iÃ§indeki lokal pozisyonu hesapla
        Vector3 localPos = worldPos - (Vector3)(chunkCoord * chunkSize);
        int x = Mathf.FloorToInt(localPos.x);
        int y = Mathf.FloorToInt(localPos.y);
        int z = Mathf.FloorToInt(localPos.z);
        
        if (x < 0 || x >= chunkSize || y < 0 || y >= chunkSize || z < 0 || z >= chunkSize) {
            return; // Chunk dÄ±ÅŸÄ±
        }
        
        // âœ… Su grid'ini gÃ¼ncelle (8 = Kaynak su, sonsuz)
        int index = x + y * chunkSize + z * chunkSize * chunkSize;
        int[] data = new int[1];
        data[0] = 8; // Kaynak su (sonsuz)
        waterGrid.SetData(data, index, 1);
    }
    
    /// <summary>
    /// âœ… Su seviyesini al (0-7 arasÄ±, 8=kaynak su)
    /// </summary>
    public int GetWaterLevel(Vector3 worldPos) {
        if (_chunkManager == null) return 0;
        
        Vector3Int chunkCoord = _chunkManager.GetChunkCoord(worldPos);
        if (!_chunkWaterGrids.TryGetValue(chunkCoord, out ComputeBuffer waterGrid)) {
            return 0; // Su yok
        }
        
        Vector3 localPos = worldPos - (Vector3)(chunkCoord * chunkSize);
        int x = Mathf.FloorToInt(localPos.x);
        int y = Mathf.FloorToInt(localPos.y);
        int z = Mathf.FloorToInt(localPos.z);
        
        if (x < 0 || x >= chunkSize || y < 0 || y >= chunkSize || z < 0 || z >= chunkSize) {
            return 0;
        }
        
        int index = x + y * chunkSize + z * chunkSize * chunkSize;
        int[] data = new int[1];
        waterGrid.GetData(data, index, 1);
        
        return data[0] == 8 ? 7 : data[0]; // Kaynak su = 7 seviye
    }
    
    /// <summary>
    /// âœ… Su ekle (belirli seviyede, 1-7 arasÄ±)
    /// </summary>
    public void AddWater(Vector3 worldPos, int level) {
        if (level < 1 || level > 7) return;
        if (_chunkManager == null) return;
        
        Vector3Int chunkCoord = _chunkManager.GetChunkCoord(worldPos);
        if (!_chunkWaterGrids.TryGetValue(chunkCoord, out ComputeBuffer waterGrid)) {
            CreateWaterGridForChunk(chunkCoord);
            waterGrid = _chunkWaterGrids[chunkCoord];
        }
        
        Vector3 localPos = worldPos - (Vector3)(chunkCoord * chunkSize);
        int x = Mathf.FloorToInt(localPos.x);
        int y = Mathf.FloorToInt(localPos.y);
        int z = Mathf.FloorToInt(localPos.z);
        
        if (x < 0 || x >= chunkSize || y < 0 || y >= chunkSize || z < 0 || z >= chunkSize) {
            return;
        }
        
        int index = x + y * chunkSize + z * chunkSize * chunkSize;
        int[] data = new int[1];
        data[0] = level;
        waterGrid.SetData(data, index, 1);
    }
    
    /// <summary>
    /// âœ… Su kaldÄ±r
    /// </summary>
    public void RemoveWater(Vector3 worldPos) {
        if (_chunkManager == null) return;
        
        Vector3Int chunkCoord = _chunkManager.GetChunkCoord(worldPos);
        if (!_chunkWaterGrids.TryGetValue(chunkCoord, out ComputeBuffer waterGrid)) {
            return;
        }
        
        Vector3 localPos = worldPos - (Vector3)(chunkCoord * chunkSize);
        int x = Mathf.FloorToInt(localPos.x);
        int y = Mathf.FloorToInt(localPos.y);
        int z = Mathf.FloorToInt(localPos.z);
        
        if (x < 0 || x >= chunkSize || y < 0 || y >= chunkSize || z < 0 || z >= chunkSize) {
            return;
        }
        
        int index = x + y * chunkSize + z * chunkSize * chunkSize;
        int[] data = new int[1];
        data[0] = 0; // BoÅŸ
        waterGrid.SetData(data, index, 1);
    }
    
    void OnDestroy() {
        // âœ… TÃ¼m buffer'larÄ± temizle
        foreach (var waterGrid in _chunkWaterGrids.Values) {
            waterGrid?.Release();
        }
        _chunkWaterGrids.Clear();
        
        _terrainDensity?.Release();
    }
}
```

**Su MekaniÄŸi Ã–zellikleri:**
- âœ… **AÅŸaÄŸÄ± AkÄ±ÅŸ (Gravity):** Su her zaman aÅŸaÄŸÄ± akar (en yÃ¼ksek Ã¶ncelik)
- âœ… **Yan Tarafa AkÄ±ÅŸ:** Su seviyesi 1'den fazlaysa 4 yÃ¶ne akar (kuzey, gÃ¼ney, doÄŸu, batÄ±)
- âœ… **YayÄ±lma MekaniÄŸi:** Su seviyesi dÃ¼ÅŸÃ¼kse komÅŸulara yayÄ±lÄ±r (denge saÄŸlar)
- âœ… **Ã–ncelik Sistemi:** AÅŸaÄŸÄ± > Yan > YayÄ±lma
- âœ… **Su Seviyesi:** 0-7 arasÄ± (0=boÅŸ, 7=tam blok, 8=kaynak su)
- âœ… **BoÅŸluk KontrolÃ¼:** Su sadece boÅŸ voxel'lere akar (terrain yoksa)
- âœ… **Kaynak Su:** Sonsuz su kaynaÄŸÄ± (seviye 8, hiÃ§ deÄŸiÅŸmez)

**Performans NotlarÄ±:**
- GPU Ã¼zerinde hesaplanÄ±r (CPU'yu yormaz)
- Chunk bazlÄ± cache sistemi
- Update interval ile sÄ±nÄ±rlandÄ±rÄ±lmÄ±ÅŸ (varsayÄ±lan: 0.2s = 5 kez/saniye)

---



**Not:** Su mekaniÄŸi sistemi tam Ã§alÄ±ÅŸÄ±r durumda. Ä°leride eklenebilecek geliÅŸmiÅŸ Ã¶zellikler (waterlogging, lava etkileÅŸimi, su altÄ± fizik) iÃ§in ayrÄ± sistemler gerekecek ve Faz 3+ fazlarÄ±nda eklenebilir.

---

## ğŸŒ³ ADIM 5: VOXEL AÄAÃ‡ SÄ°STEMÄ° (ProsedÃ¼rel + AÅŸamalÄ± BÃ¼yÃ¼me)

### 5.1 Problem TanÄ±mÄ± ve Ã‡Ã¶zÃ¼m

**Mevcut Sorun:**
- VegetationSpawner.cs prefab-based aÄŸaÃ§ spawn kullanÄ±yor (GPU Instancing)
- AÄŸaÃ§lar voxel felsefesine uygun deÄŸil - kÄ±rÄ±lamaz, sadece prefab
- Her ÅŸey voxel olmalÄ± (voxel felsefesi)

**Ã‡Ã¶zÃ¼m:**
- AÄŸaÃ§lar **voxel bloklardan** oluÅŸur
- **ProsedÃ¼rel algoritma** ile her aÄŸaÃ§ farklÄ± (L-System veya Fractal Tree)
- **AÅŸamalÄ± bÃ¼yÃ¼me** (fidan â†’ kÃ¼Ã§Ã¼k â†’ orta â†’ bÃ¼yÃ¼k â†’ olgun)
- Kesilebilir (her blok ayrÄ±, NetworkMining ile)

### 5.2 VoxelTreeGenerator.cs - ProsedÃ¼rel AÄŸaÃ§ OluÅŸturma

**Dosya:** `_Stratocraft/Scripts/Systems/Nature/VoxelTreeGenerator.cs`

**AmaÃ§:** L-System veya Fractal Tree algoritmasÄ± ile voxel bloklardan aÄŸaÃ§ oluÅŸturur

**Kod:**

```csharp
using UnityEngine;
using Unity.Collections;
using Unity.Jobs;
using Unity.Burst;
using Unity.Mathematics;
using System.Collections.Generic;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Voxel Tree Generator - ProsedÃ¼rel aÄŸaÃ§ oluÅŸturma
/// L-System veya Fractal Tree algoritmasÄ± ile voxel bloklardan aÄŸaÃ§ oluÅŸturur
/// </summary>
public class VoxelTreeGenerator : MonoBehaviour {
    private ChunkManager _chunkManager;
    
    void Start() {
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        
        // âœ… ServiceLocator'a kaydet
        ServiceLocator.Instance?.Register<VoxelTreeGenerator>(this);
    }
    
    /// <summary>
    /// âœ… AÄŸaÃ§ oluÅŸtur (voxel bloklardan)
    /// </summary>
    public void GenerateTree(Vector3Int rootPos, string treeType, TreeGrowthSystem.GrowthStageData stageData) {
        if (_chunkManager == null) {
            Debug.LogError("[VoxelTreeGenerator] ChunkManager bulunamadÄ±!");
            return;
        }
        
        // âœ… Job System ile paralel aÄŸaÃ§ generation
        GenerateTreeJob job = new GenerateTreeJob {
            rootPos = new int3(rootPos.x, rootPos.y, rootPos.z),
            minHeight = stageData.minHeight,
            maxHeight = stageData.maxHeight,
            branchCount = stageData.branchCount,
            treeType = treeType
        };
        
        job.treeBlocks = new NativeList<int3>(Allocator.TempJob);
        
        JobHandle handle = job.Schedule();
        handle.Complete();
        
        // âœ… AÄŸaÃ§ bloklarÄ±nÄ± dÃ¼nyaya yerleÅŸtir
        PlaceTreeBlocks(job.treeBlocks, rootPos);
        
        job.treeBlocks.Dispose();
    }
    
    /// <summary>
    /// âœ… AÄŸaÃ§ bloklarÄ±nÄ± dÃ¼nyaya yerleÅŸtir
    /// </summary>
    void PlaceTreeBlocks(NativeList<int3> blocks, Vector3Int rootPos) {
        for (int i = 0; i < blocks.Length; i++) {
            int3 blockPos = blocks[i];
            Vector3Int worldPos = rootPos + new Vector3Int(blockPos.x, blockPos.y, blockPos.z);
            
            // âœ… ChunkManager'a blok ekle
            _chunkManager.AddDensityAtPoint(worldPos, 1.0f);
            _chunkManager.SetBlockType(worldPos, "wood"); // AÄŸaÃ§ gÃ¶vdesi
        }
    }
    
    /// <summary>
    /// âœ… AÄŸacÄ± kaldÄ±r (kÄ±rÄ±ldÄ±ÄŸÄ±nda)
    /// </summary>
    public void RemoveTreeAt(Vector3Int treePos) {
        if (_chunkManager == null) return;
        
        // AÄŸaÃ§ pozisyonundaki tÃ¼m bloklarÄ± kaldÄ±r
        // AÄŸaÃ§ genellikle 3x3x10 alan kaplar (yaklaÅŸÄ±k)
        int searchRadius = 5;
        for (int x = -searchRadius; x <= searchRadius; x++) {
            for (int y = 0; y <= 15; y++) {
                for (int z = -searchRadius; z <= searchRadius; z++) {
                    Vector3Int checkPos = treePos + new Vector3Int(x, y, z);
                    string blockType = _chunkManager.GetBlockType(checkPos);
                    
                    if (blockType == "wood" || blockType == "leaves") {
                        _chunkManager.RemoveDensityAtPoint(checkPos);
                        _chunkManager.SetBlockType(checkPos, null);
                    }
                }
            }
        }
    }
}

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: AÄŸaÃ§ generation Job (Burst ile optimize)
/// </summary>
[BurstCompile]
public struct GenerateTreeJob : IJob {
    public int3 rootPos;
    public int minHeight;
    public int maxHeight;
    public int branchCount;
    public string treeType;
    
    public NativeList<int3> treeBlocks;
    
    public void Execute() {
        // âœ… Deterministik rastgelelik iÃ§in seed kullan
        Unity.Mathematics.Random random = new Unity.Mathematics.Random((uint)(rootPos.x * 1000 + rootPos.z + rootPos.y));
        
        // âœ… L-System benzeri algoritma ile aÄŸaÃ§ oluÅŸtur
        int height = random.NextInt(minHeight, maxHeight + 1);
        
        // GÃ¶vde oluÅŸtur
        for (int y = 0; y < height; y++) {
            treeBlocks.Add(new int3(0, y, 0));
        }
        
        // Dallar oluÅŸtur
        for (int i = 0; i < branchCount; i++) {
            int branchHeight = random.NextInt(height / 2, height);
            int branchLength = random.NextInt(2, 6);
            int branchDir = random.NextInt(0, 4); // 4 yÃ¶n
            
            // Dal bloklarÄ±nÄ± ekle
            for (int j = 0; j < branchLength; j++) {
                int3 branchPos = GetBranchPosition(branchHeight, branchDir, j);
                treeBlocks.Add(branchPos);
            }
        }
        
        // Yapraklar oluÅŸtur (gÃ¶vde etrafÄ±nda)
        GenerateLeaves(height, random);
    }
    
    int3 GetBranchPosition(int height, int direction, int length) {
        int3 offset = new int3(0, height, 0);
        
        switch (direction) {
            case 0: offset.x += length; break; // DoÄŸu
            case 1: offset.x -= length; break; // BatÄ±
            case 2: offset.z += length; break; // Kuzey
            case 3: offset.z -= length; break; // GÃ¼ney
        }
        
        return offset;
    }
    
    void GenerateLeaves(int height, Unity.Mathematics.Random random) {
        // GÃ¶vde Ã¼stÃ¼nde yaprak kÃ¼mesi
        int leafHeight = height - 1;
        int leafRadius = random.NextInt(2, 4);
        
        for (int x = -leafRadius; x <= leafRadius; x++) {
            for (int z = -leafRadius; z <= leafRadius; z++) {
                for (int y = 0; y < 2; y++) {
                    float distance = math.sqrt(x * x + z * z);
                    if (distance <= leafRadius) {
                        // Rastgele yaprak yoÄŸunluÄŸu
                        if (random.NextFloat() > 0.3f) {
                            treeBlocks.Add(new int3(x, leafHeight + y, z));
                        }
                    }
                }
            }
        }
    }
}
```

### 5.3 TreeGrowthSystem.cs - AÅŸamalÄ± BÃ¼yÃ¼me YÃ¶netimi

**Dosya:** `_Stratocraft/Scripts/Systems/Nature/TreeGrowthSystem.cs`

**AmaÃ§:** AÅŸamalÄ± aÄŸaÃ§ bÃ¼yÃ¼me yÃ¶netimi (5 aÅŸama: Fidan, KÃ¼Ã§Ã¼k, Orta, BÃ¼yÃ¼k, Olgun)

**Kod:**

```csharp
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Tree Growth System - AÅŸamalÄ± aÄŸaÃ§ bÃ¼yÃ¼me yÃ¶netimi
/// </summary>
public class TreeGrowthSystem : MonoBehaviour {
    private ChunkManager _chunkManager;
    private VoxelTreeGenerator _treeGenerator;
    
    // âœ… OPTÄ°MÄ°ZE: Aktif bÃ¼yÃ¼yen aÄŸaÃ§lar cache'i
    private Dictionary<Vector3Int, Coroutine> _growingTrees = new Dictionary<Vector3Int, Coroutine>();
    
    public enum GrowthStage {
        Sapling,    // Fidan (1 blok)
        Small,      // KÃ¼Ã§Ã¼k (3-4 blok)
        Medium,     // Orta (5-7 blok)
        Large,      // BÃ¼yÃ¼k (8-12 blok)
        Mature      // Olgun (tam boyut)
    }
    
    [System.Serializable]
    public class GrowthStageData {
        public GrowthStage stage;
        public float growthTime; // Bu aÅŸamaya geÃ§iÅŸ sÃ¼resi (saniye)
        public int minHeight; // Minimum yÃ¼kseklik (blok)
        public int maxHeight; // Maksimum yÃ¼kseklik (blok)
        public int branchCount; // Dal sayÄ±sÄ±
    }
    
    [Header("BÃ¼yÃ¼me AyarlarÄ±")]
    public List<GrowthStageData> growthStages = new List<GrowthStageData> {
        new GrowthStageData { stage = GrowthStage.Sapling, growthTime = 120f, minHeight = 1, maxHeight = 1, branchCount = 0 },
        new GrowthStageData { stage = GrowthStage.Small, growthTime = 300f, minHeight = 3, maxHeight = 4, branchCount = 2 },
        new GrowthStageData { stage = GrowthStage.Medium, growthTime = 600f, minHeight = 5, maxHeight = 7, branchCount = 4 },
        new GrowthStageData { stage = GrowthStage.Large, growthTime = 900f, minHeight = 8, maxHeight = 12, branchCount = 6 },
        new GrowthStageData { stage = GrowthStage.Mature, growthTime = 0f, minHeight = 10, maxHeight = 15, branchCount = 8 }
    };
    
    void Start() {
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        _treeGenerator = GetComponent<VoxelTreeGenerator>();
        
        if (_treeGenerator == null) {
            _treeGenerator = gameObject.AddComponent<VoxelTreeGenerator>();
        }
        
        // âœ… ServiceLocator'a kaydet
        ServiceLocator.Instance?.Register<TreeGrowthSystem>(this);
    }
    
    /// <summary>
    /// âœ… Fidan dik (bÃ¼yÃ¼me baÅŸlat)
    /// </summary>
    public void PlantSapling(Vector3Int position, string treeType) {
        if (_growingTrees.ContainsKey(position)) {
            Debug.LogWarning($"[TreeGrowthSystem] Bu pozisyonda zaten bir aÄŸaÃ§ bÃ¼yÃ¼yor: {position}");
            return;
        }
        
        // âœ… BÃ¼yÃ¼me coroutine'ini baÅŸlat
        Coroutine growthCoroutine = StartCoroutine(GrowTree(position, treeType));
        _growingTrees[position] = growthCoroutine;
    }
    
    /// <summary>
    /// âœ… AÄŸaÃ§ bÃ¼yÃ¼me coroutine
    /// </summary>
    IEnumerator GrowTree(Vector3Int treePos, string treeType) {
        GrowthStage currentStage = GrowthStage.Sapling;
        
        while (currentStage != GrowthStage.Mature) {
            // âœ… Mevcut aÅŸamayÄ± render et
            RenderTreeStage(treePos, treeType, currentStage);
            
            // âœ… Bir sonraki aÅŸamaya geÃ§iÅŸ sÃ¼resini bekle
            GrowthStageData stageData = growthStages.Find(s => s.stage == currentStage);
            if (stageData != null && stageData.growthTime > 0) {
                yield return new WaitForSeconds(stageData.growthTime);
            } else {
                yield break; // BÃ¼yÃ¼me tamamlandÄ±
            }
            
            // âœ… Sonraki aÅŸamaya geÃ§
            currentStage = GetNextStage(currentStage);
        }
        
        // âœ… Olgun aÄŸaÃ§ render et
        RenderTreeStage(treePos, treeType, GrowthStage.Mature);
        
        // âœ… Cache'den kaldÄ±r
        _growingTrees.Remove(treePos);
    }
    
    /// <summary>
    /// âœ… Sonraki aÅŸamayÄ± al
    /// </summary>
    GrowthStage GetNextStage(GrowthStage current) {
        switch (current) {
            case GrowthStage.Sapling: return GrowthStage.Small;
            case GrowthStage.Small: return GrowthStage.Medium;
            case GrowthStage.Medium: return GrowthStage.Large;
            case GrowthStage.Large: return GrowthStage.Mature;
            default: return GrowthStage.Mature;
        }
    }
    
    /// <summary>
    /// âœ… AÄŸaÃ§ aÅŸamasÄ±nÄ± render et
    /// </summary>
    void RenderTreeStage(Vector3Int treePos, string treeType, GrowthStage stage) {
        // âœ… Mevcut aÄŸacÄ± kaldÄ±r
        _treeGenerator.RemoveTreeAt(treePos);
        
        // âœ… Yeni aÅŸamayÄ± oluÅŸtur
        GrowthStageData stageData = growthStages.Find(s => s.stage == stage);
        if (stageData != null) {
            _treeGenerator.GenerateTree(treePos, treeType, stageData);
        }
    }
    
    /// <summary>
    /// âœ… AÄŸacÄ± kÄ±r (bÃ¼yÃ¼meyi durdur)
    /// </summary>
    public void BreakTree(Vector3Int treePos) {
        if (_growingTrees.ContainsKey(treePos)) {
            StopCoroutine(_growingTrees[treePos]);
            _growingTrees.Remove(treePos);
        }
        
        _treeGenerator.RemoveTreeAt(treePos);
    }
}
```

**BÃ¼yÃ¼me ZamanlarÄ±:**
- **Fidan â†’ KÃ¼Ã§Ã¼k:** 2 dakika (120 saniye)
- **KÃ¼Ã§Ã¼k â†’ Orta:** 5 dakika (300 saniye)
- **Orta â†’ BÃ¼yÃ¼k:** 10 dakika (600 saniye)
- **BÃ¼yÃ¼k â†’ Olgun:** 15 dakika (900 saniye)
- **Toplam:** ~32 dakika (Minecraft'tan Ã§ok daha yavaÅŸ, gerÃ§ekÃ§i)

**Optimizasyon:**
- âœ… **Job System:** Paralel aÄŸaÃ§ generation (Burst ile optimize)
- âœ… **Coroutines:** Asenkron bÃ¼yÃ¼me sistemi (UI donmasÄ±nÄ± Ã¶nler)
- âœ… **Dictionary Cache:** Aktif bÃ¼yÃ¼yen aÄŸaÃ§lar cache'i

---

## â›ï¸ ADIM 6: VOXEL MADEN SÄ°STEMÄ° (Density-Based Spawn)

### 6.1 Problem TanÄ±mÄ± ve Ã‡Ã¶zÃ¼m

**Mevcut Sorun:**
- Madenler sadece density-based (TerrainDensity.compute iÃ§inde)
- GÃ¶rÃ¼nmez, kÄ±rÄ±lamaz, oyuncu gÃ¶remez
- Voxel felsefesine uygun deÄŸil

**Ã‡Ã¶zÃ¼m:**
- Madenler **voxel bloklar** olarak spawn edilir
- **TerrainDensity.compute** maden yerlerini belirler
- **OreSpawner.cs** maden bloklarÄ±nÄ± yerleÅŸtirir
- KÄ±rÄ±labilir (NetworkMining ile)

### 6.2 OreSpawner.cs - Voxel Maden Blok Spawn

**Dosya:** `_Stratocraft/Scripts/Systems/Mining/OreSpawner.cs`

**AmaÃ§:** Voxel maden blok spawn sistemi (TerrainDensity.compute entegrasyonu)

**Kod:**

```csharp
using UnityEngine;
using Unity.Collections;
using Unity.Jobs;
using Unity.Burst;
using Unity.Mathematics;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Ore Spawner - Voxel maden blok spawn sistemi
/// TerrainDensity.compute ile entegre, density-based maden spawn
/// </summary>
public class OreSpawner : MonoBehaviour {
    private ChunkManager _chunkManager;
    
    [Header("Maden AyarlarÄ±")]
    public OreDefinition[] oreDefinitions;
    
    // âœ… OPTÄ°MÄ°ZE: Spawn edilmiÅŸ madenler cache'i
    private Dictionary<Vector3Int, string> _spawnedOres = new Dictionary<Vector3Int, string>();
    
    void Start() {
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        
        if (_chunkManager != null) {
            // Chunk generation event'ine abone ol
            _chunkManager.OnChunkGenerated += OnChunkGenerated;
        }
        
        // âœ… ServiceLocator'a kaydet
        ServiceLocator.Instance?.Register<OreSpawner>(this);
    }
    
    void OnDestroy() {
        if (_chunkManager != null) {
            _chunkManager.OnChunkGenerated -= OnChunkGenerated;
        }
    }
    
    /// <summary>
    /// âœ… Chunk generation sÄ±rasÄ±nda maden spawn et
    /// </summary>
    public void OnChunkGenerated(Vector3Int chunkCoord) {
        if (_chunkManager == null) {
            _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
            if (_chunkManager == null) return;
        }
        
        // âœ… Job System ile paralel maden spawn
        SpawnOresInChunkJob job = new SpawnOresInChunkJob {
            chunkCoord = new int3(chunkCoord.x, chunkCoord.y, chunkCoord.z),
            chunkSize = _chunkManager.chunkSize,
            worldSeed = _chunkManager.GetWorldSeed()
        };
        
        job.orePositions = new NativeList<int4>(Allocator.TempJob); // x, y, z, oreTypeIndex
        
        JobHandle handle = job.Schedule();
        handle.Complete();
        
        // âœ… Maden bloklarÄ±nÄ± yerleÅŸtir
        PlaceOreBlocks(job.orePositions, chunkCoord);
        
        job.orePositions.Dispose();
    }
    
    /// <summary>
    /// âœ… Maden bloklarÄ±nÄ± yerleÅŸtir
    /// </summary>
    void PlaceOreBlocks(NativeList<int4> orePositions, Vector3Int chunkCoord) {
        if (_chunkManager == null || oreDefinitions == null || oreDefinitions.Length == 0) return;
        
        for (int i = 0; i < orePositions.Length; i++) {
            int4 oreData = orePositions[i];
            Vector3Int worldPos = chunkCoord * _chunkManager.chunkSize + 
                                 new Vector3Int(oreData.x, oreData.y, oreData.z);
            
            int oreTypeIndex = oreData.w;
            if (oreTypeIndex >= 0 && oreTypeIndex < oreDefinitions.Length) {
                OreDefinition oreDef = oreDefinitions[oreTypeIndex];
                
                // âœ… ChunkManager'a maden blok ekle
                _chunkManager.AddDensityAtPoint(worldPos, 1.0f);
                _chunkManager.SetBlockType(worldPos, oreDef.oreId);
                
                // âœ… Cache'e ekle
                _spawnedOres[worldPos] = oreDef.oreId;
            }
        }
    }
}

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Maden spawn Job (Burst ile optimize)
/// </summary>
[BurstCompile]
public struct SpawnOresInChunkJob : IJob {
    public int3 chunkCoord;
    public int chunkSize;
    public int worldSeed;
    
    public NativeList<int4> orePositions;
    
    public void Execute() {
        // âœ… Deterministik rastgelelik iÃ§in seed
        Unity.Mathematics.Random random = new Unity.Mathematics.Random((uint)(chunkCoord.x * 1000 + chunkCoord.z + worldSeed));
        
        // âœ… Her voxel iÃ§in maden kontrolÃ¼
        for (int x = 0; x < chunkSize; x++) {
            for (int y = 0; y < chunkSize; y++) {
                for (int z = 0; z < chunkSize; z++) {
                    int3 localPos = new int3(x, y, z);
                    int3 worldPos = chunkCoord * chunkSize + localPos;
                    
                    // âœ… Maden spawn kontrolÃ¼ (yÃ¼ksekliÄŸe gÃ¶re)
                    if (worldPos.y < -20) {
                        // Maden spawn ÅŸansÄ± (noise ile)
                        float noiseValue = noise.snoise(new float3(worldPos.x, worldPos.y, worldPos.z) * 0.1f + (float)worldSeed);
                        if (noiseValue > 0.7f) {
                            // Maden tipi belirle (yÃ¼ksekliÄŸe gÃ¶re)
                            int oreType = DetermineOreType(worldPos.y, random);
                            if (oreType >= 0) {
                                orePositions.Add(new int4(localPos.x, localPos.y, localPos.z, oreType));
                            }
                        }
                    }
                }
            }
        }
    }
    
    int DetermineOreType(int worldY, Unity.Mathematics.Random random) {
        // YÃ¼ksekliÄŸe gÃ¶re maden tipi
        if (worldY < -100) {
            // Titanium (Ã§ok nadir)
            return random.NextFloat() < 0.1f ? 0 : -1;
        }
        if (worldY < -50) {
            // Diamond (nadir)
            return random.NextFloat() < 0.2f ? 1 : -1;
        }
        if (worldY < -20) {
            // Iron (yaygÄ±n)
            return random.NextFloat() < 0.3f ? 2 : -1;
        }
        return -1;
    }
}
```

### 6.3 OreDefinition.cs - Maden TanÄ±mlarÄ±

**Dosya:** `_Stratocraft/Scripts/Data/ScriptableObjects/OreDefinition.cs`

**AmaÃ§:** Maden tanÄ±mlarÄ± (ScriptableObject)

**Kod:**

```csharp
using UnityEngine;

/// <summary>
/// âœ… Maden tanÄ±mÄ± (ScriptableObject)
/// </summary>
[CreateAssetMenu(fileName = "OreDefinition", menuName = "Stratocraft/Ore Definition")]
public class OreDefinition : ScriptableObject {
    [Header("Maden Bilgileri")]
    public string oreId; // "iron_ore", "diamond_ore", vb.
    
    [Header("Spawn AyarlarÄ±")]
    [Tooltip("Minimum derinlik (world Y koordinatÄ±)")]
    public int minDepth = -50; // -50'de baÅŸlar
    
    [Tooltip("Maksimum derinlik (world Y koordinatÄ±)")]
    public int maxDepth = -20; // -20'de biter
    
    [Tooltip("Spawn ÅŸansÄ± (0-1 arasÄ±)")]
    [Range(0f, 1f)]
    public float spawnChance = 0.3f; // %30 ÅŸans
    
    [Header("Item Drop")]
    [Tooltip("KÄ±rÄ±ldÄ±ÄŸÄ±nda dÃ¼ÅŸecek item ID")]
    public string itemDropId; // "iron_ingot", "diamond", vb.
    
    [Tooltip("Drop miktarÄ± (min-max)")]
    public int minDropAmount = 1;
    public int maxDropAmount = 3;
}
```

**Optimizasyon:**
- âœ… **Job System:** Paralel maden spawn (Burst ile optimize)
- âœ… **Dictionary Cache:** Spawn edilmiÅŸ madenler cache'i
- âœ… **Chunk Event:** Chunk generation sÄ±rasÄ±nda otomatik spawn

---

## ğŸ—ï¸ ADIM 7: Ä°NÅA SÄ°STEMÄ° (Grid-Based + Blueprint + Sculpting)

### 7.1 Problem TanÄ±mÄ± ve Ã‡Ã¶zÃ¼m

**Mevcut Sorun:**
- Smooth voxel dÃ¼nyada tutarsÄ±z inÅŸa
- Her yerleÅŸtirme farklÄ± gÃ¶rÃ¼nÃ¼yor
- Grid yok, blueprint yok

**Ã‡Ã¶zÃ¼m:**
- **Grid-Based Placement:** Hidden grid sistemi (1m grid)
- **Blueprint System:** YapÄ± kaydetme/kopyalama
- **Sculpting System:** Blok yontma ve template sistemi

### 7.2 GridPlacementSystem.cs - Grid TabanlÄ± YerleÅŸtirme

**Dosya:** `_Stratocraft/Scripts/Systems/Building/GridPlacementSystem.cs`

**AmaÃ§:** Grid tabanlÄ± blok yerleÅŸtirme (smooth voxel dÃ¼nyada tutarlÄ± inÅŸa)

**Kod:**

```csharp
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Grid Placement System - Grid tabanlÄ± blok yerleÅŸtirme
/// Smooth voxel dÃ¼nyada tutarlÄ± inÅŸa iÃ§in grid sistemi
/// </summary>
public class GridPlacementSystem : MonoBehaviour {
    private ChunkManager _chunkManager;
    
    [Header("Grid AyarlarÄ±")]
    public float gridSize = 1.0f; // 1 metre grid
    
    // âœ… OPTÄ°MÄ°ZE: Grid pozisyon cache'i
    private Dictionary<Vector3Int, bool> _gridOccupied = new Dictionary<Vector3Int, bool>();
    
    void Start() {
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        
        // âœ… ServiceLocator'a kaydet
        ServiceLocator.Instance?.Register<GridPlacementSystem>(this);
    }
    
    /// <summary>
    /// âœ… Grid'e yapÄ±ÅŸtÄ±r
    /// </summary>
    public Vector3 SnapToGrid(Vector3 worldPos) {
        float snappedX = Mathf.Round(worldPos.x / gridSize) * gridSize;
        float snappedY = Mathf.Round(worldPos.y / gridSize) * gridSize;
        float snappedZ = Mathf.Round(worldPos.z / gridSize) * gridSize;
        return new Vector3(snappedX, snappedY, snappedZ);
    }
    
    /// <summary>
    /// âœ… Grid koordinatÄ±na Ã§evir
    /// </summary>
    public Vector3Int WorldToGrid(Vector3 worldPos) {
        Vector3 snapped = SnapToGrid(worldPos);
        return new Vector3Int(
            Mathf.RoundToInt(snapped.x / gridSize),
            Mathf.RoundToInt(snapped.y / gridSize),
            Mathf.RoundToInt(snapped.z / gridSize)
        );
    }
    
    /// <summary>
    /// âœ… Grid noktasÄ±na blok yerleÅŸtir
    /// </summary>
    public bool PlaceBlockAtGrid(Vector3 worldPos, string blockType, string variantId = null) {
        Vector3 gridPos = SnapToGrid(worldPos);
        Vector3Int gridCoord = WorldToGrid(gridPos);
        
        // âœ… Grid noktasÄ± dolu mu kontrol et
        if (_gridOccupied.ContainsKey(gridCoord) && _gridOccupied[gridCoord]) {
            return false; // Dolu
        }
        
        // âœ… ChunkManager'a blok ekle
        if (_chunkManager != null) {
            _chunkManager.AddDensityAtPoint(gridPos, 1.0f);
            _chunkManager.SetBlockType(gridPos, variantId ?? blockType);
            
            // âœ… Grid'i iÅŸaretle
            _gridOccupied[gridCoord] = true;
            
            return true;
        }
        
        return false;
    }
    
    /// <summary>
    /// âœ… Grid noktasÄ±ndan blok kaldÄ±r
    /// </summary>
    public bool RemoveBlockAtGrid(Vector3 worldPos) {
        Vector3Int gridCoord = WorldToGrid(worldPos);
        
        if (_chunkManager != null) {
            _chunkManager.RemoveDensityAtPoint(worldPos);
            _gridOccupied[gridCoord] = false;
            return true;
        }
        
        return false;
    }
    
    /// <summary>
    /// âœ… Grid noktasÄ± dolu mu?
    /// </summary>
    public bool IsGridOccupied(Vector3 worldPos) {
        Vector3Int gridCoord = WorldToGrid(worldPos);
        return _gridOccupied.ContainsKey(gridCoord) && _gridOccupied[gridCoord];
    }
}
```

### 7.3 BlueprintSystem.cs - YapÄ± Kaydetme/Kopyalama

**Dosya:** `_Stratocraft/Scripts/Systems/Building/BlueprintSystem.cs`

**AmaÃ§:** YapÄ± kaydetme ve kopyalama sistemi

**Kod:**

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.IO;
using System.Linq;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Blueprint System - YapÄ± kaydetme ve kopyalama
/// </summary>
public class BlueprintSystem : MonoBehaviour {
    private GridPlacementSystem _gridSystem;
    private ChunkManager _chunkManager;
    
    // âœ… OPTÄ°MÄ°ZE: Blueprint cache
    private Dictionary<string, Blueprint> _blueprintCache = new Dictionary<string, Blueprint>();
    
    [System.Serializable]
    public class Blueprint {
        public string blueprintId;
        public string blueprintName;
        public Vector3Int size; // Boyut (x, y, z)
        public List<BlueprintBlock> blocks = new List<BlueprintBlock>();
    }
    
    [System.Serializable]
    public class BlueprintBlock {
        public Vector3Int gridCoord; // Grid koordinatÄ± (relative)
        public string blockType;
        public string variantId; // Variant ID (opsiyonel)
    }
    
    void Start() {
        _gridSystem = ServiceLocator.Instance?.Get<GridPlacementSystem>();
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        
        // âœ… ServiceLocator'a kaydet
        ServiceLocator.Instance?.Register<BlueprintSystem>(this);
    }
    
    /// <summary>
    /// âœ… YapÄ±yÄ± blueprint olarak kaydet
    /// </summary>
    public Blueprint SaveBlueprint(Vector3Int startPos, Vector3Int endPos, string blueprintName) {
        Blueprint blueprint = new Blueprint {
            blueprintId = System.Guid.NewGuid().ToString(),
            blueprintName = blueprintName,
            size = new Vector3Int(
                Mathf.Abs(endPos.x - startPos.x) + 1,
                Mathf.Abs(endPos.y - startPos.y) + 1,
                Mathf.Abs(endPos.z - startPos.z) + 1
            )
        };
        
        // âœ… Grid koordinatlarÄ± arasÄ±ndaki tÃ¼m bloklarÄ± kaydet
        Vector3Int minPos = new Vector3Int(
            Mathf.Min(startPos.x, endPos.x),
            Mathf.Min(startPos.y, endPos.y),
            Mathf.Min(startPos.z, endPos.z)
        );
        
        for (int x = 0; x < blueprint.size.x; x++) {
            for (int y = 0; y < blueprint.size.y; y++) {
                for (int z = 0; z < blueprint.size.z; z++) {
                    Vector3Int gridPos = minPos + new Vector3Int(x, y, z);
                    string blockType = GetBlockAtGrid(gridPos);
                    
                    if (!string.IsNullOrEmpty(blockType)) {
                        blueprint.blocks.Add(new BlueprintBlock {
                            gridCoord = new Vector3Int(x, y, z), // Relative koordinat
                            blockType = blockType
                        });
                    }
                }
            }
        }
        
        // âœ… Cache'e ekle
        _blueprintCache[blueprint.blueprintId] = blueprint;
        
        // âœ… Dosyaya kaydet (opsiyonel)
        SaveBlueprintToFile(blueprint);
        
        return blueprint;
    }
    
    /// <summary>
    /// âœ… Blueprint'i yÃ¼kle ve yerleÅŸtir
    /// </summary>
    public void LoadBlueprint(Vector3Int startPos, string blueprintId) {
        if (!_blueprintCache.ContainsKey(blueprintId)) {
            // âœ… Dosyadan yÃ¼kle
            LoadBlueprintFromFile(blueprintId);
        }
        
        if (!_blueprintCache.ContainsKey(blueprintId)) {
            Debug.LogError($"[BlueprintSystem] Blueprint bulunamadÄ±: {blueprintId}");
            return;
        }
        
        Blueprint blueprint = _blueprintCache[blueprintId];
        
        // âœ… Blueprint bloklarÄ±nÄ± yerleÅŸtir
        foreach (var block in blueprint.blocks) {
            Vector3Int worldPos = startPos + block.gridCoord;
            _gridSystem.PlaceBlockAtGrid(worldPos, block.blockType, block.variantId);
        }
    }
    
    /// <summary>
    /// âœ… Grid pozisyonundaki blok tipini al
    /// </summary>
    string GetBlockAtGrid(Vector3Int gridPos) {
        if (_chunkManager != null && _gridSystem != null) {
            Vector3 worldPos = new Vector3(
                gridPos.x * _gridSystem.gridSize, 
                gridPos.y * _gridSystem.gridSize, 
                gridPos.z * _gridSystem.gridSize
            );
            return _chunkManager.GetBlockType(worldPos);
        }
        return null;
    }
    
    /// <summary>
    /// âœ… Blueprint'i dosyaya kaydet
    /// </summary>
    void SaveBlueprintToFile(Blueprint blueprint) {
        string path = Path.Combine(Application.persistentDataPath, "Blueprints", $"{blueprint.blueprintId}.json");
        Directory.CreateDirectory(Path.GetDirectoryName(path));
        
        string json = JsonUtility.ToJson(blueprint, true);
        File.WriteAllText(path, json);
    }
    
    /// <summary>
    /// âœ… Blueprint'i dosyadan yÃ¼kle
    /// </summary>
    void LoadBlueprintFromFile(string blueprintId) {
        string path = Path.Combine(Application.persistentDataPath, "Blueprints", $"{blueprintId}.json");
        
        if (File.Exists(path)) {
            string json = File.ReadAllText(path);
            Blueprint blueprint = JsonUtility.FromJson<Blueprint>(json);
            _blueprintCache[blueprintId] = blueprint;
        }
    }
}
```

### 7.4 SculptingSystem.cs - Blok Yontma Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Building/SculptingSystem.cs`

**AmaÃ§:** Blok yontma ve ÅŸekil verme sistemi

**Kod:**

```csharp
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Sculpting System - Blok yontma ve ÅŸekil verme
/// </summary>
public class SculptingSystem : MonoBehaviour {
    private GridPlacementSystem _gridSystem;
    private VariantMeshGenerator _variantGenerator;
    private ChunkManager _chunkManager;
    
    [System.Serializable]
    public class SculptedShape {
        public string shapeId;
        public string shapeName;
        public List<Vector3> vertices = new List<Vector3>();
        public List<int> triangles = new List<int>();
    }
    
    // âœ… OPTÄ°MÄ°ZE: YontulmuÅŸ ÅŸekiller cache'i
    private Dictionary<string, SculptedShape> _sculptedShapes = new Dictionary<string, SculptedShape>();
    
    private bool _isSculpting = false;
    private Vector3 _currentSculptPos;
    private SculptedShape _currentShape;
    
    void Start() {
        _gridSystem = ServiceLocator.Instance?.Get<GridPlacementSystem>();
        _variantGenerator = ServiceLocator.Instance?.Get<VariantMeshGenerator>();
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        
        // âœ… ServiceLocator'a kaydet
        ServiceLocator.Instance?.Register<SculptingSystem>(this);
    }
    
    /// <summary>
    /// âœ… Blok yontmaya baÅŸla
    /// </summary>
    public void StartSculpting(Vector3 blockPos) {
        _isSculpting = true;
        _currentSculptPos = blockPos;
        _currentShape = new SculptedShape {
            shapeId = System.Guid.NewGuid().ToString(),
            vertices = new List<Vector3>(),
            triangles = new List<int>()
        };
        
        Debug.Log($"[SculptingSystem] Yontma baÅŸladÄ±: {blockPos}");
    }
    
    /// <summary>
    /// âœ… Yontma iÅŸlemini bitir
    /// </summary>
    public void FinishSculpting() {
        if (!_isSculpting) return;
        
        _isSculpting = false;
        
        // YontulmuÅŸ ÅŸekli kaydet
        if (_currentShape != null && _currentShape.vertices.Count > 0) {
            _sculptedShapes[_currentShape.shapeId] = _currentShape;
        }
        
        _currentShape = null;
    }
    
    /// <summary>
    /// âœ… YontulmuÅŸ ÅŸekli template olarak kaydet
    /// </summary>
    public void SaveAsTemplate(SculptedShape shape, string templateName) {
        if (shape == null) return;
        
        shape.shapeId = System.Guid.NewGuid().ToString();
        shape.shapeName = templateName;
        _sculptedShapes[shape.shapeId] = shape;
        
        Debug.Log($"[SculptingSystem] Template kaydedildi: {templateName} ({shape.shapeId})");
    }
    
    /// <summary>
    /// âœ… Template'i uygula
    /// </summary>
    public void ApplyTemplate(Vector3 blockPos, string templateId) {
        if (!_sculptedShapes.ContainsKey(templateId)) {
            Debug.LogError($"[SculptingSystem] Template bulunamadÄ±: {templateId}");
            return;
        }
        
        SculptedShape template = _sculptedShapes[templateId];
        
        // Template'i blok pozisyonuna uygula
        if (_variantGenerator != null) {
            // Template'den mesh oluÅŸtur
            Mesh templateMesh = CreateMeshFromShape(template);
            
            // Mesh'i blok pozisyonuna yerleÅŸtir
            // ChunkManager'a density ekle
            if (_chunkManager != null) {
                _chunkManager.AddDensityAtPoint(blockPos, 1.0f);
                _chunkManager.SetBlockType(blockPos, $"sculpted_{templateId}");
            }
        }
    }
    
    /// <summary>
    /// âœ… SculptedShape'den mesh oluÅŸtur
    /// </summary>
    Mesh CreateMeshFromShape(SculptedShape shape) {
        Mesh mesh = new Mesh();
        mesh.vertices = shape.vertices.ToArray();
        mesh.triangles = shape.triangles.ToArray();
        mesh.RecalculateNormals();
        mesh.RecalculateBounds();
        return mesh;
    }
}
```

**Optimizasyon:**
- âœ… **Dictionary Cache:** Grid, blueprint, sculpted shapes cache'i
- âœ… **JSON Dosya Kaydetme:** Blueprint'ler persistent data'da saklanÄ±r
- âœ… **ServiceLocator Entegrasyonu:** TÃ¼m sistemler birbirine baÄŸlÄ±

---

## ğŸ§± ADIM 8: VARIANT BLOK SÄ°STEMÄ° (740 Variant Per Material)

### 8.1 Problem TanÄ±mÄ± ve Ã‡Ã¶zÃ¼m

**Mevcut Sorun:**
- Sadece basit kÄ±rma/yerleÅŸtirme var
- Åekil seÃ§imi yok
- Minecraft'taki gibi merdiven, yarÄ± blok, vb. yok

**Ã‡Ã¶zÃ¼m:**
- **740 Variant Per Material:** TÃ¼m olasÄ± kombinasyonlar
- **Algoritma TabanlÄ±:** Runtime'da mesh generation (cache ile optimize)
- **7,400 Total Variant:** 10 material Ã— 740 variant

### 8.2 Variant Kategorileri ve Hesaplama

**1. DÄ°K KESÄ°MLER (ORTHOGONAL CUTS) - ~200 variant**
- Tek yÃ¶n kesimler: YarÄ± (1/2), Ã‡eyrek (1/4), 1/5, 2/5, 3/5, 4/5 (6 yÃ¶n Ã— 5 seviye = 30 variant)
- Ä°ki yÃ¶n kombinasyonlarÄ±: C(6,2) = 15 variant (her seviye iÃ§in)
- ÃœÃ§ yÃ¶n kombinasyonlarÄ±: C(6,3) = 20 variant
- DÃ¶rt, beÅŸ, altÄ± yÃ¶n kombinasyonlarÄ±: ~135 variant

**2. Ã‡APRAZ KESÄ°MLER (DIAGONAL CUTS) - ~100 variant**
- Kenar Ã§apraz kesimler: 12 kenar Ã— 5 seviye = 60 variant
- KÃ¶ÅŸe Ã§apraz kesimler: 8 kÃ¶ÅŸe Ã— 5 seviye = 40 variant

**3. YUVARLANMIÅ KÃ–ÅELER (ROUNDED CORNERS) - ~100 variant**
- KÃ¶ÅŸe yuvarlatma: 8 kÃ¶ÅŸe Ã— 5 seviye = 40 variant
- Kenar yuvarlatma: 12 kenar Ã— 5 seviye = 60 variant

**4. RAMP ÅEKÄ°LLERÄ° (RAMP SHAPES) - ~130 variant**
- Dik ramp'ler: 6 yÃ¶n Ã— 5 seviye = 30 variant
- Ã‡apraz ramp'ler: 12 kenar Ã— 5 seviye + 8 kÃ¶ÅŸe Ã— 5 seviye = 100 variant

**5. MERDÄ°VEN BENZERÄ° ÅEKÄ°LLER (STAIRS-LIKE) - ~40 variant**
- Normal merdivenler: 4 yÃ¶n Ã— 2 tip = 8 variant
- KÃ¶ÅŸe merdivenleri: 8 yÃ¶n Ã— 2 tip Ã— 2 tip (inner/outer) = 32 variant

**6. Ä°Ã‡/DIÅ KÃ–ÅELER (INNER/OUTER CORNERS) - ~80 variant**
- Ä°Ã§ kÃ¶ÅŸeler: 8 yÃ¶n Ã— 5 seviye = 40 variant
- DÄ±ÅŸ kÃ¶ÅŸeler: 8 yÃ¶n Ã— 5 seviye = 40 variant

**7. Ã–ZEL ÅEKÄ°LLER (SPECIAL SHAPES) - ~90 variant**
- Trapezoid: 6 yÃ¶n Ã— 5 seviye = 30 variant
- Piramit: 6 yÃ¶n Ã— 5 seviye = 30 variant
- YarÄ±m kÃ¼re: 6 yÃ¶n Ã— 5 seviye = 30 variant

**TOPLAM:** ~**740 variant per material**
- **10 material Ã— 740 variant = 7,400 total variant**

### 8.3 Variant ID Sistemi ve Naming Convention

**Variant ID FormatÄ±:**
- **Temel Format:** `{material}_{variantType}_{parameters}`
- **Ã–rnekler:**
  - `wood_half_top` - YarÄ± blok (Ã¼stten kesilmiÅŸ)
  - `stone_quarter_top_left` - Ã‡eyrek blok (Ã¼stten ve soldan kesilmiÅŸ)
  - `wood_fifth_top_1` - 1/5 blok (Ã¼stten, seviye 1)
  - `stone_diagonal_edge_top_front_2` - Ã‡apraz kenar kesim (Ã¼st-Ã¶n kenar, seviye 2)
  - `wood_rounded_corner_top_left_front_3` - YuvarlanmÄ±ÅŸ kÃ¶ÅŸe (Ã¼st-sol-Ã¶n kÃ¶ÅŸe, seviye 3)
  - `stone_ramp_top_2` - Ramp ÅŸekli (Ã¼st yÃ¶n, seviye 2)
  - `wood_stairs_north_inverted` - Merdiven (kuzey yÃ¶nÃ¼, ters)
  - `stone_inner_corner_top_left_front_1` - Ä°Ã§ kÃ¶ÅŸe (Ã¼st-sol-Ã¶n kÃ¶ÅŸe, seviye 1)
  - `wood_outer_corner_top_left_front_1` - DÄ±ÅŸ kÃ¶ÅŸe (Ã¼st-sol-Ã¶n kÃ¶ÅŸe, seviye 1)

**Variant Type Enum:**
```csharp
public enum VariantType {
    Full,           // Tam blok
    Half,           // YarÄ± (1/2)
    Quarter,        // Ã‡eyrek (1/4)
    Fifth,          // 1/5
    TwoFifth,       // 2/5
    ThreeFifth,     // 3/5
    FourFifth,      // 4/5
    Diagonal,       // Ã‡apraz
    Rounded,        // YuvarlanmÄ±ÅŸ
    Ramp,           // Ramp
    Stairs,         // Merdiven
    InnerCorner,    // Ä°Ã§ kÃ¶ÅŸe
    OuterCorner,    // DÄ±ÅŸ kÃ¶ÅŸe
    Special         // Ã–zel ÅŸekil
}
```

**Variant ID OluÅŸturma:**
```csharp
public string GetVariantId(string baseItemId, VariantType type, params object[] parameters) {
    string variantId = baseItemId;
    
    switch (type) {
        case VariantType.Half:
            variantId += $"_half_{parameters[0]}"; // "wood_half_top"
            break;
        case VariantType.Quarter:
            variantId += $"_quarter_{parameters[0]}_{parameters[1]}"; // "wood_quarter_top_left"
            break;
        case VariantType.Fifth:
            variantId += $"_fifth_{parameters[0]}_{parameters[1]}"; // "wood_fifth_top_1" (1/5)
            break;
        case VariantType.Diagonal:
            variantId += $"_diagonal_{parameters[0]}_{parameters[1]}"; // "wood_diagonal_edge_top_front"
            break;
        case VariantType.Rounded:
            variantId += $"_rounded_{parameters[0]}_{parameters[1]}"; // "wood_rounded_corner_top_left_1"
            break;
        case VariantType.Ramp:
            variantId += $"_ramp_{parameters[0]}_{parameters[1]}"; // "wood_ramp_top_1"
            break;
        case VariantType.Stairs:
            variantId += $"_stairs_{parameters[0]}_{parameters[1]}"; // "wood_stairs_north_inverted"
            break;
        case VariantType.InnerCorner:
            variantId += $"_inner_{parameters[0]}_{parameters[1]}_{parameters[2]}"; // "wood_inner_corner_top_left_1"
            break;
        // ... diÄŸer tipler
    }
    
    return variantId;
}
```

### 8.4 VariantMeshGenerator.cs - Algoritma TabanlÄ± Mesh OluÅŸturma

**Dosya:** `_Stratocraft/Scripts/Systems/Blocks/VariantMeshGenerator.cs`

**AmaÃ§:** Algoritma tabanlÄ± variant mesh generation (740 variant per material)

**Kod:**

```csharp
using UnityEngine;
using System.Collections.Generic;
using Unity.Collections;
using Unity.Jobs;
using Unity.Burst;
using Unity.Mathematics;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Variant Mesh Generator - Algoritma tabanlÄ± mesh oluÅŸturma
/// Minecraft'taki gibi her variant iÃ§in ayrÄ± mesh tanÄ±mlamak yerine,
/// algoritma ile procedural mesh generation yapar
/// </summary>
public class VariantMeshGenerator : MonoBehaviour {
    private static VariantMeshGenerator _instance;
    public static VariantMeshGenerator Instance {
        get {
            if (_instance == null) {
                _instance = FindObjectOfType<VariantMeshGenerator>();
            }
            return _instance;
        }
    }
    
    // âœ… OPTÄ°MÄ°ZE: Mesh cache (O(1) lookup)
    private Dictionary<string, Mesh> _meshCache = new Dictionary<string, Mesh>();
    
    // âœ… OPTÄ°MÄ°ZE: Material cache
    private Dictionary<string, Material> _materialCache = new Dictionary<string, Material>();
    
    void Awake() {
        if (_instance == null) {
            _instance = this;
            DontDestroyOnLoad(gameObject);
        } else if (_instance != this) {
            Destroy(gameObject);
            return;
        }
        
        ServiceLocator.Instance?.Register<VariantMeshGenerator>(this);
    }
    
    /// <summary>
    /// âœ… Variant mesh al (cache'den veya generate et)
    /// </summary>
    public Mesh GetVariantMesh(string variantId) {
        if (_meshCache.ContainsKey(variantId)) {
            return _meshCache[variantId];
        }
        
        // Cache'de yoksa generate et
        Mesh mesh = GenerateVariantMesh(variantId);
        if (mesh != null) {
            _meshCache[variantId] = mesh;
        }
        
        return mesh;
    }
    
    /// <summary>
    /// âœ… Variant ID'den mesh generate et (algoritma tabanlÄ±)
    /// </summary>
    Mesh GenerateVariantMesh(string variantId) {
        // Variant ID formatÄ±: "wood_half_top", "stone_quarter_top_left", vb.
        string[] parts = variantId.Split('_');
        if (parts.Length < 2) {
            Debug.LogWarning($"[VariantMeshGenerator] GeÃ§ersiz variant ID: {variantId}");
            return GenerateFullBlockMesh(); // Tam blok
        }
        
        string materialId = parts[0];
        string variantType = parts[1];
        
        // Variant tipine gÃ¶re mesh generate et
        switch (variantType) {
            case "half":
                return GenerateHalfBlockMesh(parts);
            case "quarter":
                return GenerateQuarterBlockMesh(parts);
            case "fifth":
                return GenerateFifthBlockMesh(parts);
            case "eighth":
                return GenerateEighthBlockMesh(parts);
            case "diagonal":
                return GenerateDiagonalCutMesh(parts[2], parts[3] + "_" + parts[4], float.Parse(parts[5]));
            case "rounded":
                return GenerateRoundedCornerMesh(parts[2], parts[3] + "_" + parts[4], float.Parse(parts[5]));
            case "ramp":
                return GenerateRampShapeMesh(parts[2], float.Parse(parts[3]));
            case "stairs":
                return GenerateStairsShapeMesh(parts[2], parts.Length > 3 && parts[3] == "inverted");
            case "inner":
            case "outer":
                return GenerateCornerShapeMesh(parts[1], parts[2] + "_" + parts[3] + "_" + parts[4], parts.Length > 5 ? float.Parse(parts[5]) : 1.0f);
            default:
                return GenerateFullBlockMesh();
        }
    }
    
    /// <summary>
    /// âœ… Tam blok mesh (1x1x1 kÃ¼p)
    /// </summary>
    Mesh GenerateFullBlockMesh() {
        Mesh mesh = new Mesh();
        mesh.name = "FullBlock";
        
        // 8 kÃ¶ÅŸe
        Vector3[] vertices = new Vector3[8] {
            new Vector3(0, 0, 0), // 0: Sol-Alt-Ã–n
            new Vector3(1, 0, 0), // 1: SaÄŸ-Alt-Ã–n
            new Vector3(1, 1, 0), // 2: SaÄŸ-Ãœst-Ã–n
            new Vector3(0, 1, 0), // 3: Sol-Ãœst-Ã–n
            new Vector3(0, 0, 1), // 4: Sol-Alt-Arka
            new Vector3(1, 0, 1), // 5: SaÄŸ-Alt-Arka
            new Vector3(1, 1, 1), // 6: SaÄŸ-Ãœst-Arka
            new Vector3(0, 1, 1)  // 7: Sol-Ãœst-Arka
        };
        
        // 12 Ã¼Ã§gen (6 yÃ¼z Ã— 2 Ã¼Ã§gen)
        int[] triangles = new int[36] {
            // Ã–n yÃ¼z
            0, 2, 1, 0, 3, 2,
            // Arka yÃ¼z
            5, 7, 4, 5, 6, 7,
            // Ãœst yÃ¼z
            3, 6, 2, 3, 7, 6,
            // Alt yÃ¼z
            1, 4, 0, 1, 5, 4,
            // SaÄŸ yÃ¼z
            1, 6, 5, 1, 2, 6,
            // Sol yÃ¼z
            4, 3, 0, 4, 7, 3
        };
        
        mesh.vertices = vertices;
        mesh.triangles = triangles;
        mesh.RecalculateNormals();
        mesh.RecalculateBounds();
        
        return mesh;
    }
    
    /// <summary>
    /// âœ… YarÄ± blok mesh (1 yÃ¶nden kesilmiÅŸ)
    /// </summary>
    Mesh GenerateHalfBlockMesh(string[] parts) {
        if (parts.Length < 3) return GenerateFullBlockMesh();
        
        string direction = parts[2]; // "top", "bottom", "front", vb.
        float cutRatio = 0.5f; // YarÄ±
        
        return GenerateCutBlockMesh(direction, cutRatio);
    }
    
    /// <summary>
    /// âœ… Ã‡eyrek blok mesh (2 yÃ¶nden kesilmiÅŸ)
    /// </summary>
    Mesh GenerateQuarterBlockMesh(string[] parts) {
        if (parts.Length < 4) return GenerateFullBlockMesh();
        
        string dir1 = parts[2];
        string dir2 = parts[3];
        float cutRatio = 0.5f;
        
        return GenerateCutBlockMesh(dir1, dir2, cutRatio);
    }
    
    /// <summary>
    /// âœ… 1/5 blok mesh
    /// </summary>
    Mesh GenerateFifthBlockMesh(string[] parts) {
        if (parts.Length < 4) return GenerateFullBlockMesh();
        
        string direction = parts[2];
        int level = int.Parse(parts[3]); // 1, 2, 3, 4
        float cutRatio = level / 5f; // 0.2, 0.4, 0.6, 0.8
        
        return GenerateCutBlockMesh(direction, cutRatio);
    }
    
    /// <summary>
    /// âœ… 1/8 blok mesh (3 yÃ¶nden kesilmiÅŸ)
    /// </summary>
    Mesh GenerateEighthBlockMesh(string[] parts) {
        if (parts.Length < 5) return GenerateFullBlockMesh();
        
        string dir1 = parts[2];
        string dir2 = parts[3];
        string dir3 = parts[4];
        float cutRatio = 0.5f;
        
        return GenerateCutBlockMesh(dir1, dir2, dir3, cutRatio);
    }
    
    /// <summary>
    /// âœ… Tek yÃ¶nden kesilmiÅŸ blok mesh
    /// </summary>
    Mesh GenerateCutBlockMesh(string direction, float cutRatio) {
        Mesh mesh = new Mesh();
        List<Vector3> vertices = new List<Vector3>();
        List<int> triangles = new List<int>();
        
        // YÃ¶n bazlÄ± kesim
        Vector3 cutPlane = GetDirectionVector(direction);
        float cutDistance = cutRatio;
        
        // 8 kÃ¶ÅŸe noktasÄ±
        Vector3[] corners = new Vector3[8] {
            new Vector3(0, 0, 0), new Vector3(1, 0, 0),
            new Vector3(1, 1, 0), new Vector3(0, 1, 0),
            new Vector3(0, 0, 1), new Vector3(1, 0, 1),
            new Vector3(1, 1, 1), new Vector3(0, 1, 1)
        };
        
        // Kesim dÃ¼zleminin hangi tarafÄ±nda olduÄŸunu kontrol et
        List<Vector3> validCorners = new List<Vector3>();
        foreach (var corner in corners) {
            float distance = Vector3.Dot(corner, cutPlane);
            if (distance <= cutDistance) {
                validCorners.Add(corner);
            }
        }
        
        // Mesh oluÅŸtur
        BuildMeshFromCorners(validCorners, cutPlane, cutDistance, vertices, triangles);
        
        mesh.vertices = vertices.ToArray();
        mesh.triangles = triangles.ToArray();
        mesh.RecalculateNormals();
        mesh.RecalculateBounds();
        
        return mesh;
    }
    
    /// <summary>
    /// âœ… Ä°ki yÃ¶nden kesilmiÅŸ blok mesh
    /// </summary>
    Mesh GenerateCutBlockMesh(string dir1, string dir2, float cutRatio) {
        // Ä°ki kesim dÃ¼zlemi
        Vector3 plane1 = GetDirectionVector(dir1);
        Vector3 plane2 = GetDirectionVector(dir2);
        
        // Ä°ki dÃ¼zlemin kesiÅŸimini hesapla
        return GenerateMultiCutMesh(new Vector3[] { plane1, plane2 }, cutRatio);
    }
    
    /// <summary>
    /// âœ… ÃœÃ§ yÃ¶nden kesilmiÅŸ blok mesh
    /// </summary>
    Mesh GenerateCutBlockMesh(string dir1, string dir2, string dir3, float cutRatio) {
        Vector3 plane1 = GetDirectionVector(dir1);
        Vector3 plane2 = GetDirectionVector(dir2);
        Vector3 plane3 = GetDirectionVector(dir3);
        
        return GenerateMultiCutMesh(new Vector3[] { plane1, plane2, plane3 }, cutRatio);
    }
    
    /// <summary>
    /// âœ… Ã‡oklu kesim mesh
    /// </summary>
    Mesh GenerateMultiCutMesh(Vector3[] planes, float cutRatio) {
        Mesh mesh = new Mesh();
        List<Vector3> vertices = new List<Vector3>();
        List<int> triangles = new List<int>();
        
        Vector3[] corners = new Vector3[8] {
            new Vector3(0, 0, 0), new Vector3(1, 0, 0),
            new Vector3(1, 1, 0), new Vector3(0, 1, 0),
            new Vector3(0, 0, 1), new Vector3(1, 0, 1),
            new Vector3(1, 1, 1), new Vector3(0, 1, 1)
        };
        
        // TÃ¼m dÃ¼zlemlerin iÃ§inde kalan kÃ¶ÅŸeleri bul
        List<Vector3> validCorners = new List<Vector3>();
        foreach (var corner in corners) {
            bool valid = true;
            foreach (var plane in planes) {
                float distance = Vector3.Dot(corner, plane);
                if (distance > cutRatio) {
                    valid = false;
                    break;
                }
            }
            if (valid) {
                validCorners.Add(corner);
            }
        }
        
        // Kesim dÃ¼zlemlerinin kesiÅŸim noktalarÄ±nÄ± ekle
        AddIntersectionPoints(planes, cutRatio, validCorners);
        
        // Mesh oluÅŸtur
        BuildMeshFromCorners(validCorners, Vector3.zero, 0, vertices, triangles);
        
        mesh.vertices = vertices.ToArray();
        mesh.triangles = triangles.ToArray();
        mesh.RecalculateNormals();
        mesh.RecalculateBounds();
        
        return mesh;
    }
    
    /// <summary>
    /// âœ… Ã‡apraz kesim mesh
    /// </summary>
    Mesh GenerateDiagonalCutMesh(string edgeType, string location, float cutRatio) {
        // Ã‡apraz kesim iÃ§in Ã¶zel algoritma
        Mesh mesh = new Mesh();
        List<Vector3> vertices = new List<Vector3>();
        List<int> triangles = new List<int>();
        
        // Location'dan yÃ¶nleri parse et
        string[] locParts = location.Split('_');
        Vector3 cutDir1 = Vector3.zero;
        Vector3 cutDir2 = Vector3.zero;
        
        if (locParts.Length >= 2) {
            cutDir1 = GetDirectionVector(locParts[0]);
            cutDir2 = GetDirectionVector(locParts[1]);
        }
        
        // Ã‡apraz kesim iÃ§in eÄŸimli dÃ¼zlem
        Vector3 cutNormal = (cutDir1 + cutDir2).normalized;
        float cutDistance = cutRatio;
        
        // 8 kÃ¶ÅŸe noktasÄ±
        Vector3[] corners = new Vector3[8] {
            new Vector3(0, 0, 0), new Vector3(1, 0, 0),
            new Vector3(1, 1, 0), new Vector3(0, 1, 0),
            new Vector3(0, 0, 1), new Vector3(1, 0, 1),
            new Vector3(1, 1, 1), new Vector3(0, 1, 1)
        };
        
        // Ã‡apraz dÃ¼zlemin altÄ±nda kalan kÃ¶ÅŸeleri bul
        List<Vector3> validCorners = new List<Vector3>();
        foreach (var corner in corners) {
            float distance = Vector3.Dot(corner - Vector3.one * 0.5f, cutNormal);
            if (distance <= cutDistance) {
                validCorners.Add(corner);
            }
        }
        
        // DÃ¼zlem-kÃ¼p kesiÅŸim noktalarÄ±nÄ± ekle
        AddPlaneCubeIntersections(cutNormal, cutDistance, validCorners);
        
        // Mesh oluÅŸtur
        BuildMeshFromCorners(validCorners, cutNormal, cutDistance, vertices, triangles);
        
        mesh.vertices = vertices.ToArray();
        mesh.triangles = triangles.ToArray();
        mesh.RecalculateNormals();
        mesh.RecalculateBounds();
        
        return mesh;
    }
    
    /// <summary>
    /// âœ… DÃ¼zlem-kÃ¼p kesiÅŸim noktalarÄ±nÄ± ekle
    /// </summary>
    void AddPlaneCubeIntersections(Vector3 planeNormal, float planeDistance, List<Vector3> points) {
        // KÃ¼pÃ¼n 12 kenarÄ±nÄ± kontrol et
        Vector3[] edgeStarts = new Vector3[12] {
            new Vector3(0, 0, 0), new Vector3(1, 0, 0), new Vector3(1, 1, 0), new Vector3(0, 1, 0), // Alt yÃ¼z
            new Vector3(0, 0, 1), new Vector3(1, 0, 1), new Vector3(1, 1, 1), new Vector3(0, 1, 1), // Ãœst yÃ¼z
            new Vector3(0, 0, 0), new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(1, 1, 0)  // Dikey kenarlar
        };
        
        Vector3[] edgeEnds = new Vector3[12] {
            new Vector3(1, 0, 0), new Vector3(1, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 0),
            new Vector3(1, 0, 1), new Vector3(1, 1, 1), new Vector3(0, 1, 1), new Vector3(0, 0, 1),
            new Vector3(0, 0, 1), new Vector3(0, 1, 1), new Vector3(1, 0, 1), new Vector3(1, 1, 1)
        };
        
        for (int i = 0; i < 12; i++) {
            Vector3 intersection = GetLinePlaneIntersection(edgeStarts[i], edgeEnds[i], planeNormal, planeDistance);
            if (intersection != Vector3.zero && IsPointInCube(intersection)) {
                if (!points.Contains(intersection)) {
                    points.Add(intersection);
                }
            }
        }
    }
    
    /// <summary>
    /// âœ… DoÄŸru-dÃ¼zlem kesiÅŸim noktasÄ±
    /// </summary>
    Vector3 GetLinePlaneIntersection(Vector3 lineStart, Vector3 lineEnd, Vector3 planeNormal, float planeDistance) {
        Vector3 lineDir = (lineEnd - lineStart).normalized;
        float denom = Vector3.Dot(planeNormal, lineDir);
        
        if (Mathf.Abs(denom) < 0.0001f) return Vector3.zero; // Paralel
        
        Vector3 planePoint = planeNormal * planeDistance;
        float t = Vector3.Dot(planeNormal, planePoint - lineStart) / denom;
        
        if (t < 0 || t > Vector3.Distance(lineStart, lineEnd)) return Vector3.zero;
        
        return lineStart + lineDir * t;
    }
    
    /// <summary>
    /// âœ… Nokta kÃ¼p iÃ§inde mi?
    /// </summary>
    bool IsPointInCube(Vector3 point) {
        return point.x >= 0 && point.x <= 1 && 
               point.y >= 0 && point.y <= 1 && 
               point.z >= 0 && point.z <= 1;
    }
    
    /// <summary>
    /// âœ… YuvarlanmÄ±ÅŸ kÃ¶ÅŸe mesh
    /// </summary>
    Mesh GenerateRoundedCornerMesh(string cornerType, string location, float roundness) {
        Mesh mesh = new Mesh();
        List<Vector3> vertices = new List<Vector3>();
        List<int> triangles = new List<int>();
        
        // Location'dan kÃ¶ÅŸe pozisyonunu belirle
        string[] locParts = location.Split('_');
        Vector3 cornerPos = Vector3.zero;
        
        if (locParts.Length >= 3) {
            // "top_left_front" -> (1, 1, 1)
            cornerPos = new Vector3(
                locParts[1] == "left" ? 0 : 1,
                locParts[0] == "top" ? 1 : 0,
                locParts[2] == "front" ? 0 : 1
            );
        }
        
        // Yuvarlatma radius'u
        float radius = roundness * 0.3f; // Maksimum 0.3 birim yuvarlatma
        
        // YuvarlatÄ±lmÄ±ÅŸ kÃ¶ÅŸe iÃ§in mesh oluÅŸtur
        int segments = 8; // Yuvarlatma segment sayÄ±sÄ±
        
        // KÃ¶ÅŸe etrafÄ±nda yuvarlatÄ±lmÄ±ÅŸ yÃ¼zey oluÅŸtur
        for (int i = 0; i < segments; i++) {
            float angle1 = (i / (float)segments) * Mathf.PI * 0.5f;
            float angle2 = ((i + 1) / (float)segments) * Mathf.PI * 0.5f;
            
            Vector3 v1 = cornerPos + new Vector3(
                Mathf.Cos(angle1) * radius,
                Mathf.Sin(angle1) * radius,
                0
            );
            Vector3 v2 = cornerPos + new Vector3(
                Mathf.Cos(angle2) * radius,
                Mathf.Sin(angle2) * radius,
                0
            );
            
            vertices.Add(cornerPos);
            vertices.Add(v1);
            vertices.Add(v2);
            
            int baseIdx = vertices.Count - 3;
            triangles.Add(baseIdx);
            triangles.Add(baseIdx + 1);
            triangles.Add(baseIdx + 2);
        }
        
        mesh.vertices = vertices.ToArray();
        mesh.triangles = triangles.ToArray();
        mesh.RecalculateNormals();
        mesh.RecalculateBounds();
        
        return mesh;
    }
    
    /// <summary>
    /// âœ… Ramp ÅŸekli mesh
    /// </summary>
    Mesh GenerateRampShapeMesh(string direction, float slope) {
        Mesh mesh = new Mesh();
        List<Vector3> vertices = new List<Vector3>();
        List<int> triangles = new List<int>();
        
        Vector3 dir = GetDirectionVector(direction);
        float height = slope; // EÄŸim yÃ¼ksekliÄŸi (0-1)
        
        // Ramp iÃ§in eÄŸimli yÃ¼zey oluÅŸtur
        if (direction == "top" || direction == "bottom") {
            // Y ekseni boyunca eÄŸim
            vertices.Add(new Vector3(0, direction == "top" ? height : 0, 0));
            vertices.Add(new Vector3(1, direction == "top" ? height : 0, 0));
            vertices.Add(new Vector3(1, direction == "top" ? 1 : (1 - height), 0));
            vertices.Add(new Vector3(0, direction == "top" ? 1 : (1 - height), 0));
            vertices.Add(new Vector3(0, direction == "top" ? height : 0, 1));
            vertices.Add(new Vector3(1, direction == "top" ? height : 0, 1));
            vertices.Add(new Vector3(1, direction == "top" ? 1 : (1 - height), 1));
            vertices.Add(new Vector3(0, direction == "top" ? 1 : (1 - height), 1));
        } else {
            // X veya Z ekseni boyunca eÄŸim
            float startY = 0;
            float endY = height;
            
            vertices.Add(new Vector3(0, startY, 0));
            vertices.Add(new Vector3(1, startY, 0));
            vertices.Add(new Vector3(1, endY, 0));
            vertices.Add(new Vector3(0, endY, 0));
            vertices.Add(new Vector3(0, startY, 1));
            vertices.Add(new Vector3(1, startY, 1));
            vertices.Add(new Vector3(1, endY, 1));
            vertices.Add(new Vector3(0, endY, 1));
        }
        
        // ÃœÃ§genler
        triangles.AddRange(new int[] { 0, 2, 1, 0, 3, 2 }); // Ã–n yÃ¼z
        triangles.AddRange(new int[] { 4, 5, 6, 4, 6, 7 }); // Arka yÃ¼z
        triangles.AddRange(new int[] { 0, 4, 7, 0, 7, 3 }); // Sol yÃ¼z
        triangles.AddRange(new int[] { 1, 2, 6, 1, 6, 5 }); // SaÄŸ yÃ¼z
        triangles.AddRange(new int[] { 3, 7, 6, 3, 6, 2 }); // Ãœst yÃ¼z (eÄŸimli)
        triangles.AddRange(new int[] { 0, 1, 5, 0, 5, 4 }); // Alt yÃ¼z
        
        mesh.vertices = vertices.ToArray();
        mesh.triangles = triangles.ToArray();
        mesh.RecalculateNormals();
        mesh.RecalculateBounds();
        
        return mesh;
    }
    
    // ========== UTILITY METHODS ==========
    
    /// <summary>
    /// âœ… Merdiven ÅŸekli mesh
    /// </summary>
    Mesh GenerateStairsShapeMesh(string direction, bool inverted) {
        Mesh mesh = new Mesh();
        List<Vector3> vertices = new List<Vector3>();
        List<int> triangles = new List<int>();
        
        // Merdiven iÃ§in 2 basamak oluÅŸtur
        float stepHeight = 0.5f;
        float stepDepth = 0.5f;
        
        // Ä°lk basamak (alt)
        vertices.Add(new Vector3(0, 0, 0));
        vertices.Add(new Vector3(1, 0, 0));
        vertices.Add(new Vector3(1, stepHeight, 0));
        vertices.Add(new Vector3(0, stepHeight, 0));
        vertices.Add(new Vector3(0, 0, stepDepth));
        vertices.Add(new Vector3(1, 0, stepDepth));
        vertices.Add(new Vector3(1, stepHeight, stepDepth));
        vertices.Add(new Vector3(0, stepHeight, stepDepth));
        
        // Ä°kinci basamak (Ã¼st)
        vertices.Add(new Vector3(0, stepHeight, stepDepth));
        vertices.Add(new Vector3(1, stepHeight, stepDepth));
        vertices.Add(new Vector3(1, 1, stepDepth));
        vertices.Add(new Vector3(0, 1, stepDepth));
        vertices.Add(new Vector3(0, stepHeight, 1));
        vertices.Add(new Vector3(1, stepHeight, 1));
        vertices.Add(new Vector3(1, 1, 1));
        vertices.Add(new Vector3(0, 1, 1));
        
        // YÃ¶n bazlÄ± rotasyon
        if (direction == "south" || direction == "back") {
            // 180 derece dÃ¶ndÃ¼r
            for (int i = 0; i < vertices.Count; i++) {
                vertices[i] = new Vector3(1 - vertices[i].x, vertices[i].y, 1 - vertices[i].z);
            }
        } else if (direction == "east" || direction == "right") {
            // 90 derece dÃ¶ndÃ¼r
            for (int i = 0; i < vertices.Count; i++) {
                float temp = vertices[i].x;
                vertices[i] = new Vector3(vertices[i].z, vertices[i].y, 1 - temp);
            }
        } else if (direction == "west" || direction == "left") {
            // -90 derece dÃ¶ndÃ¼r
            for (int i = 0; i < vertices.Count; i++) {
                float temp = vertices[i].x;
                vertices[i] = new Vector3(1 - vertices[i].z, vertices[i].y, temp);
            }
        }
        
        // Inverted ise ters Ã§evir
        if (inverted) {
            for (int i = 0; i < vertices.Count; i++) {
                vertices[i] = new Vector3(vertices[i].x, 1 - vertices[i].y, vertices[i].z);
            }
        }
        
        // ÃœÃ§genler (alt basamak)
        triangles.AddRange(new int[] { 0, 2, 1, 0, 3, 2 }); // Ã–n
        triangles.AddRange(new int[] { 4, 5, 6, 4, 6, 7 }); // Arka
        triangles.AddRange(new int[] { 0, 4, 7, 0, 7, 3 }); // Sol
        triangles.AddRange(new int[] { 1, 2, 6, 1, 6, 5 }); // SaÄŸ
        triangles.AddRange(new int[] { 3, 7, 6, 3, 6, 2 }); // Ãœst
        triangles.AddRange(new int[] { 0, 1, 5, 0, 5, 4 }); // Alt
        
        // ÃœÃ§genler (Ã¼st basamak)
        triangles.AddRange(new int[] { 8, 10, 9, 8, 11, 10 }); // Ã–n
        triangles.AddRange(new int[] { 12, 13, 14, 12, 14, 15 }); // Arka
        triangles.AddRange(new int[] { 8, 12, 15, 8, 15, 11 }); // Sol
        triangles.AddRange(new int[] { 9, 10, 14, 9, 14, 13 }); // SaÄŸ
        triangles.AddRange(new int[] { 11, 15, 14, 11, 14, 10 }); // Ãœst
        triangles.AddRange(new int[] { 8, 9, 13, 8, 13, 12 }); // Alt
        
        mesh.vertices = vertices.ToArray();
        mesh.triangles = triangles.ToArray();
        mesh.RecalculateNormals();
        mesh.RecalculateBounds();
        
        return mesh;
    }
    
    /// <summary>
    /// âœ… KÃ¶ÅŸe ÅŸekli mesh (inner/outer corner)
    /// </summary>
    Mesh GenerateCornerShapeMesh(string cornerType, string location, float cutRatio) {
        Mesh mesh = new Mesh();
        List<Vector3> vertices = new List<Vector3>();
        List<int> triangles = new List<int>();
        
        // Location'dan kÃ¶ÅŸe pozisyonunu belirle
        string[] locParts = location.Split('_');
        Vector3 cornerPos = Vector3.zero;
        Vector3 dir1 = Vector3.zero;
        Vector3 dir2 = Vector3.zero;
        
        if (locParts.Length >= 3) {
            cornerPos = new Vector3(
                locParts[1] == "left" ? 0 : 1,
                locParts[0] == "top" ? 1 : 0,
                locParts[2] == "front" ? 0 : 1
            );
            dir1 = GetDirectionVector(locParts[0]);
            dir2 = GetDirectionVector(locParts[1]);
        }
        
        // Inner corner (L ÅŸekli) veya Outer corner
        if (cornerType == "inner") {
            // Ä°Ã§ kÃ¶ÅŸe: L ÅŸekli, iki yÃ¶nden kesilmiÅŸ
            float cut1 = cutRatio;
            float cut2 = cutRatio;
            
            // L ÅŸekli iÃ§in kÃ¶ÅŸeler
            vertices.Add(new Vector3(0, 0, 0));
            vertices.Add(new Vector3(cut1, 0, 0));
            vertices.Add(new Vector3(cut1, 1, 0));
            vertices.Add(new Vector3(0, 1, 0));
            vertices.Add(new Vector3(0, 0, cut2));
            vertices.Add(new Vector3(cut1, 0, cut2));
            vertices.Add(new Vector3(cut1, 1, cut2));
            vertices.Add(new Vector3(0, 1, cut2));
            
            // ÃœÃ§genler
            triangles.AddRange(new int[] { 0, 2, 1, 0, 3, 2 });
            triangles.AddRange(new int[] { 4, 5, 6, 4, 6, 7 });
            triangles.AddRange(new int[] { 0, 4, 7, 0, 7, 3 });
            triangles.AddRange(new int[] { 1, 2, 6, 1, 6, 5 });
            triangles.AddRange(new int[] { 3, 7, 6, 3, 6, 2 });
            triangles.AddRange(new int[] { 0, 1, 5, 0, 5, 4 });
        } else {
            // Outer corner: DÄ±ÅŸ kÃ¶ÅŸe, Ã¼Ã§ yÃ¶nden kesilmiÅŸ
            float cut = cutRatio;
            
            vertices.Add(new Vector3(0, 0, 0));
            vertices.Add(new Vector3(cut, 0, 0));
            vertices.Add(new Vector3(cut, cut, 0));
            vertices.Add(new Vector3(0, cut, 0));
            vertices.Add(new Vector3(0, 0, cut));
            vertices.Add(new Vector3(cut, 0, cut));
            vertices.Add(new Vector3(cut, cut, cut));
            vertices.Add(new Vector3(0, cut, cut));
            
            // ÃœÃ§genler
            triangles.AddRange(new int[] { 0, 2, 1, 0, 3, 2 });
            triangles.AddRange(new int[] { 4, 5, 6, 4, 6, 7 });
            triangles.AddRange(new int[] { 0, 4, 7, 0, 7, 3 });
            triangles.AddRange(new int[] { 1, 2, 6, 1, 6, 5 });
            triangles.AddRange(new int[] { 3, 7, 6, 3, 6, 2 });
            triangles.AddRange(new int[] { 0, 1, 5, 0, 5, 4 });
        }
        
        mesh.vertices = vertices.ToArray();
        mesh.triangles = triangles.ToArray();
        mesh.RecalculateNormals();
        mesh.RecalculateBounds();
        
        return mesh;
    }
    
    /// <summary>
    /// âœ… Merdiven ÅŸekli mesh
    /// </summary>
    Mesh GenerateStairsShapeMesh(string direction, bool inverted) {
        Mesh mesh = new Mesh();
        List<Vector3> vertices = new List<Vector3>();
        List<int> triangles = new List<int>();
        
        // Merdiven iÃ§in 2 basamak oluÅŸtur
        float stepHeight = 0.5f;
        float stepDepth = 0.5f;
        
        // Ä°lk basamak (alt)
        vertices.Add(new Vector3(0, 0, 0));
        vertices.Add(new Vector3(1, 0, 0));
        vertices.Add(new Vector3(1, stepHeight, 0));
        vertices.Add(new Vector3(0, stepHeight, 0));
        vertices.Add(new Vector3(0, 0, stepDepth));
        vertices.Add(new Vector3(1, 0, stepDepth));
        vertices.Add(new Vector3(1, stepHeight, stepDepth));
        vertices.Add(new Vector3(0, stepHeight, stepDepth));
        
        // Ä°kinci basamak (Ã¼st)
        vertices.Add(new Vector3(0, stepHeight, stepDepth));
        vertices.Add(new Vector3(1, stepHeight, stepDepth));
        vertices.Add(new Vector3(1, 1, stepDepth));
        vertices.Add(new Vector3(0, 1, stepDepth));
        vertices.Add(new Vector3(0, stepHeight, 1));
        vertices.Add(new Vector3(1, stepHeight, 1));
        vertices.Add(new Vector3(1, 1, 1));
        vertices.Add(new Vector3(0, 1, 1));
        
        // YÃ¶n bazlÄ± rotasyon
        if (direction == "south" || direction == "back") {
            // 180 derece dÃ¶ndÃ¼r
            for (int i = 0; i < vertices.Count; i++) {
                vertices[i] = new Vector3(1 - vertices[i].x, vertices[i].y, 1 - vertices[i].z);
            }
        } else if (direction == "east" || direction == "right") {
            // 90 derece dÃ¶ndÃ¼r
            for (int i = 0; i < vertices.Count; i++) {
                float temp = vertices[i].x;
                vertices[i] = new Vector3(vertices[i].z, vertices[i].y, 1 - temp);
            }
        } else if (direction == "west" || direction == "left") {
            // -90 derece dÃ¶ndÃ¼r
            for (int i = 0; i < vertices.Count; i++) {
                float temp = vertices[i].x;
                vertices[i] = new Vector3(1 - vertices[i].z, vertices[i].y, temp);
            }
        }
        
        // Inverted ise ters Ã§evir
        if (inverted) {
            for (int i = 0; i < vertices.Count; i++) {
                vertices[i] = new Vector3(vertices[i].x, 1 - vertices[i].y, vertices[i].z);
            }
        }
        
        // ÃœÃ§genler (alt basamak)
        triangles.AddRange(new int[] { 0, 2, 1, 0, 3, 2 }); // Ã–n
        triangles.AddRange(new int[] { 4, 5, 6, 4, 6, 7 }); // Arka
        triangles.AddRange(new int[] { 0, 4, 7, 0, 7, 3 }); // Sol
        triangles.AddRange(new int[] { 1, 2, 6, 1, 6, 5 }); // SaÄŸ
        triangles.AddRange(new int[] { 3, 7, 6, 3, 6, 2 }); // Ãœst
        triangles.AddRange(new int[] { 0, 1, 5, 0, 5, 4 }); // Alt
        
        // ÃœÃ§genler (Ã¼st basamak)
        triangles.AddRange(new int[] { 8, 10, 9, 8, 11, 10 }); // Ã–n
        triangles.AddRange(new int[] { 12, 13, 14, 12, 14, 15 }); // Arka
        triangles.AddRange(new int[] { 8, 12, 15, 8, 15, 11 }); // Sol
        triangles.AddRange(new int[] { 9, 10, 14, 9, 14, 13 }); // SaÄŸ
        triangles.AddRange(new int[] { 11, 15, 14, 11, 14, 10 }); // Ãœst
        triangles.AddRange(new int[] { 8, 9, 13, 8, 13, 12 }); // Alt
        
        mesh.vertices = vertices.ToArray();
        mesh.triangles = triangles.ToArray();
        mesh.RecalculateNormals();
        mesh.RecalculateBounds();
        
        return mesh;
    }
    
    /// <summary>
    /// âœ… KÃ¶ÅŸe ÅŸekli mesh (inner/outer corner)
    /// </summary>
    Mesh GenerateCornerShapeMesh(string cornerType, string location, float cutRatio) {
        Mesh mesh = new Mesh();
        List<Vector3> vertices = new List<Vector3>();
        List<int> triangles = new List<int>();
        
        // Location'dan kÃ¶ÅŸe pozisyonunu belirle
        string[] locParts = location.Split('_');
        Vector3 cornerPos = Vector3.zero;
        Vector3 dir1 = Vector3.zero;
        Vector3 dir2 = Vector3.zero;
        
        if (locParts.Length >= 3) {
            cornerPos = new Vector3(
                locParts[1] == "left" ? 0 : 1,
                locParts[0] == "top" ? 1 : 0,
                locParts[2] == "front" ? 0 : 1
            );
            dir1 = GetDirectionVector(locParts[0]);
            dir2 = GetDirectionVector(locParts[1]);
        }
        
        // Inner corner (L ÅŸekli) veya Outer corner
        if (cornerType == "inner") {
            // Ä°Ã§ kÃ¶ÅŸe: L ÅŸekli, iki yÃ¶nden kesilmiÅŸ
            float cut1 = cutRatio;
            float cut2 = cutRatio;
            
            // L ÅŸekli iÃ§in kÃ¶ÅŸeler
            vertices.Add(new Vector3(0, 0, 0));
            vertices.Add(new Vector3(cut1, 0, 0));
            vertices.Add(new Vector3(cut1, 1, 0));
            vertices.Add(new Vector3(0, 1, 0));
            vertices.Add(new Vector3(0, 0, cut2));
            vertices.Add(new Vector3(cut1, 0, cut2));
            vertices.Add(new Vector3(cut1, 1, cut2));
            vertices.Add(new Vector3(0, 1, cut2));
            
            // ÃœÃ§genler
            triangles.AddRange(new int[] { 0, 2, 1, 0, 3, 2 });
            triangles.AddRange(new int[] { 4, 5, 6, 4, 6, 7 });
            triangles.AddRange(new int[] { 0, 4, 7, 0, 7, 3 });
            triangles.AddRange(new int[] { 1, 2, 6, 1, 6, 5 });
            triangles.AddRange(new int[] { 3, 7, 6, 3, 6, 2 });
            triangles.AddRange(new int[] { 0, 1, 5, 0, 5, 4 });
        } else {
            // Outer corner: DÄ±ÅŸ kÃ¶ÅŸe, Ã¼Ã§ yÃ¶nden kesilmiÅŸ
            float cut = cutRatio;
            
            vertices.Add(new Vector3(0, 0, 0));
            vertices.Add(new Vector3(cut, 0, 0));
            vertices.Add(new Vector3(cut, cut, 0));
            vertices.Add(new Vector3(0, cut, 0));
            vertices.Add(new Vector3(0, 0, cut));
            vertices.Add(new Vector3(cut, 0, cut));
            vertices.Add(new Vector3(cut, cut, cut));
            vertices.Add(new Vector3(0, cut, cut));
            
            // ÃœÃ§genler
            triangles.AddRange(new int[] { 0, 2, 1, 0, 3, 2 });
            triangles.AddRange(new int[] { 4, 5, 6, 4, 6, 7 });
            triangles.AddRange(new int[] { 0, 4, 7, 0, 7, 3 });
            triangles.AddRange(new int[] { 1, 2, 6, 1, 6, 5 });
            triangles.AddRange(new int[] { 3, 7, 6, 3, 6, 2 });
            triangles.AddRange(new int[] { 0, 1, 5, 0, 5, 4 });
        }
        
        mesh.vertices = vertices.ToArray();
        mesh.triangles = triangles.ToArray();
        mesh.RecalculateNormals();
        mesh.RecalculateBounds();
        
        return mesh;
    }
    
    // ========== UTILITY METHODS ==========
    
    Vector3 GetDirectionVector(string direction) {
        switch (direction.ToLower()) {
            case "top": return Vector3.up;
            case "bottom": return Vector3.down;
            case "front": return Vector3.forward;
            case "back": return Vector3.back;
            case "left": return Vector3.left;
            case "right": return Vector3.right;
            case "north": return Vector3.forward;
            case "south": return Vector3.back;
            case "east": return Vector3.right;
            case "west": return Vector3.left;
            default: return Vector3.zero;
        }
    }
    
    void BuildMeshFromCorners(List<Vector3> corners, Vector3 plane, float distance, List<Vector3> vertices, List<int> triangles) {
        // KÃ¶ÅŸelerden mesh oluÅŸtur (convex hull algoritmasÄ±)
        if (corners.Count < 3) return;
        
        // KÃ¶ÅŸeleri dÃ¼zleme gÃ¶re sÄ±rala (normal'e gÃ¶re)
        corners.Sort((a, b) => {
            float distA = Vector3.Dot(a, plane);
            float distB = Vector3.Dot(b, plane);
            return distA.CompareTo(distB);
        });
        
        // Basit triangulation (fan pattern)
        if (corners.Count == 3) {
            // Tek Ã¼Ã§gen
            vertices.AddRange(corners);
            triangles.AddRange(new int[] { 0, 1, 2 });
        } else if (corners.Count == 4) {
            // Ä°ki Ã¼Ã§gen (quad)
            vertices.AddRange(corners);
            triangles.AddRange(new int[] { 0, 1, 2, 0, 2, 3 });
        } else {
            // Fan triangulation (merkez noktadan)
            Vector3 center = Vector3.zero;
            foreach (var corner in corners) {
                center += corner;
            }
            center /= corners.Count;
            
            vertices.Add(center);
            int centerIndex = 0;
            
            // Her kenar iÃ§in Ã¼Ã§gen oluÅŸtur
            for (int i = 0; i < corners.Count; i++) {
                int nextIndex = (i + 1) % corners.Count;
                
                // KÃ¶ÅŸeleri ekle
                int idx1 = vertices.Count;
                vertices.Add(corners[i]);
                int idx2 = vertices.Count;
                vertices.Add(corners[nextIndex]);
                
                // ÃœÃ§gen ekle
                triangles.Add(centerIndex);
                triangles.Add(idx1);
                triangles.Add(idx2);
            }
        }
    }
    
    void AddIntersectionPoints(Vector3[] planes, float cutRatio, List<Vector3> points) {
        // DÃ¼zlemlerin kesiÅŸim noktalarÄ±nÄ± ekle
        // KÃ¼pÃ¼n kenarlarÄ± ile dÃ¼zlemlerin kesiÅŸimlerini hesapla
        Vector3[] edgeStarts = new Vector3[12] {
            new Vector3(0, 0, 0), new Vector3(1, 0, 0), new Vector3(1, 1, 0), new Vector3(0, 1, 0),
            new Vector3(0, 0, 1), new Vector3(1, 0, 1), new Vector3(1, 1, 1), new Vector3(0, 1, 1),
            new Vector3(0, 0, 0), new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(1, 1, 0)
        };
        
        Vector3[] edgeEnds = new Vector3[12] {
            new Vector3(1, 0, 0), new Vector3(1, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 0),
            new Vector3(1, 0, 1), new Vector3(1, 1, 1), new Vector3(0, 1, 1), new Vector3(0, 0, 1),
            new Vector3(0, 0, 1), new Vector3(0, 1, 1), new Vector3(1, 0, 1), new Vector3(1, 1, 1)
        };
        
        foreach (var plane in planes) {
            for (int i = 0; i < 12; i++) {
                Vector3 intersection = GetLinePlaneIntersection(edgeStarts[i], edgeEnds[i], plane, cutRatio);
                if (intersection != Vector3.zero && IsPointInCube(intersection)) {
                    bool exists = false;
                    foreach (var p in points) {
                        if (Vector3.Distance(p, intersection) < 0.001f) {
                            exists = true;
                            break;
                        }
                    }
                    if (!exists) {
                        points.Add(intersection);
                    }
                }
            }
        }
    }
    
    /// <summary>
    /// âœ… DoÄŸru-dÃ¼zlem kesiÅŸim noktasÄ±
    /// </summary>
    Vector3 GetLinePlaneIntersection(Vector3 lineStart, Vector3 lineEnd, Vector3 planeNormal, float planeDistance) {
        Vector3 lineDir = (lineEnd - lineStart).normalized;
        float denom = Vector3.Dot(planeNormal, lineDir);
        
        if (Mathf.Abs(denom) < 0.0001f) return Vector3.zero; // Paralel
        
        Vector3 planePoint = planeNormal * planeDistance;
        float t = Vector3.Dot(planeNormal, planePoint - lineStart) / denom;
        
        if (t < 0 || t > Vector3.Distance(lineStart, lineEnd)) return Vector3.zero;
        
        return lineStart + lineDir * t;
    }
    
    /// <summary>
    /// âœ… Nokta kÃ¼p iÃ§inde mi?
    /// </summary>
    bool IsPointInCube(Vector3 point) {
        return point.x >= 0 && point.x <= 1 && 
               point.y >= 0 && point.y <= 1 && 
               point.z >= 0 && point.z <= 1;
    }
    
    /// <summary>
    /// âœ… DÃ¼zlem-kÃ¼p kesiÅŸim noktalarÄ±nÄ± ekle
    /// </summary>
    void AddPlaneCubeIntersections(Vector3 planeNormal, float planeDistance, List<Vector3> points) {
        // KÃ¼pÃ¼n 12 kenarÄ±nÄ± kontrol et
        Vector3[] edgeStarts = new Vector3[12] {
            new Vector3(0, 0, 0), new Vector3(1, 0, 0), new Vector3(1, 1, 0), new Vector3(0, 1, 0), // Alt yÃ¼z
            new Vector3(0, 0, 1), new Vector3(1, 0, 1), new Vector3(1, 1, 1), new Vector3(0, 1, 1), // Ãœst yÃ¼z
            new Vector3(0, 0, 0), new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(1, 1, 0)  // Dikey kenarlar
        };
        
        Vector3[] edgeEnds = new Vector3[12] {
            new Vector3(1, 0, 0), new Vector3(1, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 0),
            new Vector3(1, 0, 1), new Vector3(1, 1, 1), new Vector3(0, 1, 1), new Vector3(0, 0, 1),
            new Vector3(0, 0, 1), new Vector3(0, 1, 1), new Vector3(1, 0, 1), new Vector3(1, 1, 1)
        };
        
        for (int i = 0; i < 12; i++) {
            Vector3 intersection = GetLinePlaneIntersection(edgeStarts[i], edgeEnds[i], planeNormal, planeDistance);
            if (intersection != Vector3.zero && IsPointInCube(intersection)) {
                if (!points.Contains(intersection)) {
                    points.Add(intersection);
                }
            }
        }
    }
    
    /// <summary>
    /// âœ… YuvarlanmÄ±ÅŸ kÃ¶ÅŸe mesh
    /// </summary>
    Mesh GenerateRoundedCornerMesh(string cornerType, string location, float roundness) {
        Mesh mesh = new Mesh();
        List<Vector3> vertices = new List<Vector3>();
        List<int> triangles = new List<int>();
        
        // Location'dan kÃ¶ÅŸe pozisyonunu belirle
        string[] locParts = location.Split('_');
        Vector3 cornerPos = Vector3.zero;
        
        if (locParts.Length >= 3) {
            // "top_left_front" -> (1, 1, 1)
            cornerPos = new Vector3(
                locParts[1] == "left" ? 0 : 1,
                locParts[0] == "top" ? 1 : 0,
                locParts[2] == "front" ? 0 : 1
            );
        }
        
        // Yuvarlatma radius'u
        float radius = roundness * 0.3f; // Maksimum 0.3 birim yuvarlatma
        
        // YuvarlatÄ±lmÄ±ÅŸ kÃ¶ÅŸe iÃ§in mesh oluÅŸtur
        int segments = 8; // Yuvarlatma segment sayÄ±sÄ±
        
        // KÃ¶ÅŸe etrafÄ±nda yuvarlatÄ±lmÄ±ÅŸ yÃ¼zey oluÅŸtur
        for (int i = 0; i < segments; i++) {
            float angle1 = (i / (float)segments) * Mathf.PI * 0.5f;
            float angle2 = ((i + 1) / (float)segments) * Mathf.PI * 0.5f;
            
            Vector3 v1 = cornerPos + new Vector3(
                Mathf.Cos(angle1) * radius,
                Mathf.Sin(angle1) * radius,
                0
            );
            Vector3 v2 = cornerPos + new Vector3(
                Mathf.Cos(angle2) * radius,
                Mathf.Sin(angle2) * radius,
                0
            );
            
            vertices.Add(cornerPos);
            vertices.Add(v1);
            vertices.Add(v2);
            
            int baseIdx = vertices.Count - 3;
            triangles.Add(baseIdx);
            triangles.Add(baseIdx + 1);
            triangles.Add(baseIdx + 2);
        }
        
        mesh.vertices = vertices.ToArray();
        mesh.triangles = triangles.ToArray();
        mesh.RecalculateNormals();
        mesh.RecalculateBounds();
        
        return mesh;
    }
    
    /// <summary>
    /// âœ… Cache'i temizle (memory yÃ¶netimi)
    /// </summary>
    public void ClearCache() {
        foreach (var mesh in _meshCache.Values) {
            if (mesh != null) {
                Destroy(mesh);
            }
        }
        _meshCache.Clear();
    }
    
    void OnDestroy() {
        ClearCache();
    }
}
```








## âœ… FAZ 3 BÄ°TÄ°Å RAPORU

### ğŸ“Š Tamamlanan Ã–zellikler

**1. Veri OdaklÄ± Biyom Sistemi:**
- âœ… BiomeDefinition ScriptableObject
- âœ… BiomeManager (cache sistemi ile)
- âœ… Ä°klim bazlÄ± biyom seÃ§imi

**2. GPU Biyom MatematiÄŸi:**
- âœ… TerrainDensity.compute gÃ¼ncellendi (biyom desteÄŸi)
- âœ… FastNoiseLite entegrasyonu
- âœ… Ä°klim haritasÄ± (sÄ±caklÄ±k/nem)
- âœ… MaÄŸara sistemi (3D noise)

**3. Vegetation Spawning:**
- âœ… GPU Instancing desteÄŸi (1000+ aÄŸaÃ§)
- âœ… Object Pooling (daha az obje iÃ§in)
- âœ… Raycast optimizasyonu
- âœ… Chunk bazlÄ± cache

**4. Su Sistemi:**
- âœ… Sonsuz okyanus (oyuncuyu takip eden dÃ¼zlem)
- âœ… Voxel su simÃ¼lasyonu (Minecraft benzeri matematiksel su mekaniÄŸi)
- âœ… Su akÄ±ÅŸ mekaniÄŸi (aÅŸaÄŸÄ±, yan, yayÄ±lma Ã¶ncelikleri)
- âœ… Su seviyesi yÃ¶netimi (0-7 arasÄ±, 8=kaynak su)

**5. Voxel AÄŸaÃ§ Sistemi:**
- âœ… VoxelTreeGenerator.cs (ProsedÃ¼rel aÄŸaÃ§ oluÅŸturma - L-System/Fractal Tree)
- âœ… TreeGrowthSystem.cs (AÅŸamalÄ± bÃ¼yÃ¼me: Fidan â†’ KÃ¼Ã§Ã¼k â†’ Orta â†’ BÃ¼yÃ¼k â†’ Olgun)
- âœ… 5 bÃ¼yÃ¼me aÅŸamasÄ± (toplam ~32 dakika)
- âœ… Job System ile paralel aÄŸaÃ§ generation
- âœ… Voxel bloklardan oluÅŸan aÄŸaÃ§lar (kÄ±rÄ±labilir)

**6. Voxel Maden Sistemi:**
- âœ… OreSpawner.cs (Voxel maden blok spawn - TerrainDensity.compute entegrasyonu)
- âœ… OreDefinition.cs (Maden tanÄ±mlarÄ± - ScriptableObject)
- âœ… Job System ile paralel maden spawn
- âœ… YÃ¼kseklik bazlÄ± maden daÄŸÄ±lÄ±mÄ±
- âœ… GÃ¶rÃ¼nÃ¼r ve kÄ±rÄ±labilir maden bloklarÄ±

**7. Ä°nÅŸa Sistemi:**
- âœ… GridPlacementSystem.cs (Grid tabanlÄ± yerleÅŸtirme - smooth voxel dÃ¼nyada tutarlÄ± inÅŸa)
- âœ… BlueprintSystem.cs (YapÄ± kaydetme ve kopyalama)
- âœ… SculptingSystem.cs (Blok yontma ve ÅŸekil verme)
- âœ… Grid cache sistemi (O(1) lookup)

**8. Variant Blok Sistemi:**
- âœ… VariantMeshGenerator.cs (740 variant algoritma tabanlÄ± mesh generation)
- âœ… Dik kesimler (6 yÃ¶n, 5 seviye: 1/5, 2/5, 3/5, 4/5, 5/5)
- âœ… Ã‡apraz kesimler (diagonal cuts)
- âœ… YuvarlanmÄ±ÅŸ kÃ¶ÅŸeler (rounded corners)
- âœ… Ramp ÅŸekilleri (ramp shapes)
- âœ… Merdiven benzeri ÅŸekiller (stairs-like)
- âœ… Ä°Ã§/DÄ±ÅŸ kÃ¶ÅŸeler (inner/outer corners)
- âœ… Ã–zel ÅŸekiller (trapezoids, pyramids, hemispheres)
- âœ… Mesh cache sistemi (O(1) lookup, pre-generated meshes)

**9. ChunkManager GÃ¼ncellemeleri:**
- âœ… AddDensityAtPoint() (Blok yerleÅŸtirme iÃ§in)
- âœ… RemoveDensityAtPoint() (Blok kÄ±rma iÃ§in)
- âœ… SetBlockType() / GetBlockType() (Blok tipi yÃ¶netimi)
- âœ… OnChunkGenerated event (OreSpawner, VoxelTreeGenerator iÃ§in)
- âœ… GetWorldSeed() (Deterministik rastgelelik iÃ§in)
- âœ… Block type cache sistemi (Dictionary<Vector3Int, string>)

### ğŸ¯ AmaÃ§ ve SonuÃ§

**AmaÃ§:** DÃ¼nyayÄ± tek dÃ¼ze taÅŸtan kurtarÄ±p; Ã‡Ã¶l, Orman, Buzul gibi bÃ¶lgelere ayÄ±rmak. Binlerce aÄŸacÄ± kasmadan yerleÅŸtirmek.

**SonuÃ§:**
- âœ… CanlÄ± dÃ¼nya (biyomlar Ã§alÄ±ÅŸÄ±yor)
- âœ… Voxel aÄŸaÃ§lar (prosedÃ¼rel, aÅŸamalÄ± bÃ¼yÃ¼me, kÄ±rÄ±labilir)
- âœ… Voxel madenler (gÃ¶rÃ¼nÃ¼r, kÄ±rÄ±labilir, yÃ¼kseklik bazlÄ±)
- âœ… TutarlÄ± inÅŸa sistemi (grid-based + blueprint + sculpting)
- âœ… 740 blok variant (tÃ¼m kesim ve ÅŸekil kombinasyonlarÄ±)
- âœ… Okyanus (sonsuz deniz + voxel su simÃ¼lasyonu)
- âœ… MaÄŸaralar (3D noise ile)

### ğŸ“‚ Mevcut Dosya YapÄ±sÄ± (Faz 3 SonrasÄ±)

```
Assets/_Stratocraft/
â”œâ”€â”€ Data/
â”‚   â””â”€â”€ Biomes/
â”‚       â”œâ”€â”€ DesertDef.asset          âœ… YENÄ°
â”‚       â”œâ”€â”€ ForestDef.asset          âœ… YENÄ°
â”‚       â””â”€â”€ MountainDef.asset        âœ… YENÄ°
â”‚
â”œâ”€â”€ Engine/
â”‚   â”œâ”€â”€ ComputeShaders/
â”‚   â”‚   â”œâ”€â”€ TerrainDensity.compute   âœ… GÃœNCELLENDÄ° (Biyomlu)
â”‚   â”‚   â””â”€â”€ WaterSim.compute         âœ… YENÄ° (Minecraft benzeri su mekaniÄŸi)
â”‚   â”‚
â”‚   â””â”€â”€ Core/
â”‚       â”œâ”€â”€ ChunkManager.cs          âœ… GÃœNCELLENDÄ° (AddDensityAtPoint, SetBlockType, OnChunkGenerated)
â”‚       â””â”€â”€ VegetationSpawner.cs     âœ… YENÄ° (GPU Instancing - eski sistem, VoxelTreeGenerator ile deÄŸiÅŸtirilebilir)
â”‚
â”œâ”€â”€ Scripts/
â”‚   â”œâ”€â”€ Core/
â”‚   â”‚   â””â”€â”€ Definitions/
â”‚   â”‚       â””â”€â”€ BiomeDefinition.cs  âœ… YENÄ°
â”‚   â”‚
â”‚   â”œâ”€â”€ Systems/
â”‚   â”‚   â”œâ”€â”€ Biomes/
â”‚   â”‚   â”‚   â””â”€â”€ BiomeManager.cs      âœ… YENÄ°
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Water/
â”‚   â”‚   â”‚   â”œâ”€â”€ OceanPlane.cs        âœ… YENÄ°
â”‚   â”‚   â”‚   â””â”€â”€ WaterSimulator.cs    âœ… YENÄ° (Voxel su simÃ¼lasyonu)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Nature/
â”‚   â”‚   â”‚   â”œâ”€â”€ VoxelTreeGenerator.cs âœ… YENÄ° (ProsedÃ¼rel aÄŸaÃ§ oluÅŸturma)
â”‚   â”‚   â”‚   â””â”€â”€ TreeGrowthSystem.cs    âœ… YENÄ° (AÅŸamalÄ± bÃ¼yÃ¼me)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Mining/
â”‚   â”‚   â”‚   â”œâ”€â”€ NetworkMining.cs      âœ… GÃœNCELLENDÄ° (Voxel terrain entegrasyonu)
â”‚   â”‚   â”‚   â””â”€â”€ OreSpawner.cs         âœ… YENÄ° (Voxel maden spawn)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Building/
â”‚   â”‚   â”‚   â”œâ”€â”€ GridPlacementSystem.cs âœ… YENÄ° (Grid tabanlÄ± yerleÅŸtirme)
â”‚   â”‚   â”‚   â”œâ”€â”€ BlueprintSystem.cs     âœ… YENÄ° (YapÄ± kaydetme/kopyalama)
â”‚   â”‚   â”‚   â””â”€â”€ SculptingSystem.cs     âœ… YENÄ° (Blok yontma)
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ Blocks/
â”‚   â”‚       â””â”€â”€ VariantMeshGenerator.cs âœ… YENÄ° (740 variant mesh generation)
â”‚   â”‚
â”‚   â””â”€â”€ Data/
â”‚       â””â”€â”€ ScriptableObjects/
â”‚           â””â”€â”€ OreDefinition.cs      âœ… YENÄ° (Maden tanÄ±mlarÄ±)
â”‚
â””â”€â”€ Art/
    â””â”€â”€ Materials/
        â””â”€â”€ OceanMat.mat             âœ… YENÄ°
```

### ğŸ”® Gelecek Fazlarda Bu Ã–zelliklere Eklenecekler

**Faz 4 (Oyun Mekanikleri):**
- `ItemDefinition` sistemi (madenler biyom bazlÄ± spawn edilecek)
- `RitualManager` (ritÃ¼eller biyom bazlÄ± Ã§alÄ±ÅŸacak)
- `DatabaseManager` (biyom verileri SQLite'da saklanacak)

**Faz 5+ (Ä°leri Ã–zellikler):**
- Klan sistemi (biyom bazlÄ± bÃ¶lge korumasÄ±)
- YapÄ± sistemi (biyom bazlÄ± yapÄ± bonuslarÄ±)
- Tuzak sistemi (biyom bazlÄ± tuzak efektleri)

---

## ğŸ§ª TEST ADIMLARI

### Test 1: Biyom Sistemi

1. Unity'de `DesertDef.asset` oluÅŸtur
2. `BiomeManager` GameObject'ine ekle
3. `allBiomes` listesine ekle
4. Play tuÅŸuna bas

**Beklenen SonuÃ§:**
- Console'da biyom seÃ§imi mesajlarÄ± gÃ¶rÃ¼nmeli
- DÃ¼nyada Ã§Ã¶l bÃ¶lgeleri gÃ¶rÃ¼nmeli

---

### Test 2: Vegetation Spawning

1. `VegetationSpawner` GameObject'ine `currentBiome` ata
2. `treePrefabs` listesine aÄŸaÃ§ prefab'larÄ± ekle
3. `useGPUInstancing = true` yap
4. Play tuÅŸuna bas ve chunk'larÄ±n yÃ¼klendiÄŸini izle

**Beklenen SonuÃ§:**
- Chunk'lar yÃ¼klendiÄŸinde aÄŸaÃ§lar spawn olmalÄ±
- Performance profiler'da GPU Instancing gÃ¶rÃ¼nmeli
- 1000+ aÄŸaÃ§ olmasÄ±na raÄŸmen FPS dÃ¼ÅŸmemeli

---

### Test 3: Okyanus

1. Sahneye `OceanPlane` GameObject'i ekle
2. `planeSize = 10000` yap
3. Play tuÅŸuna bas ve oyuncuyu hareket ettir

**Beklenen SonuÃ§:**
- Y=0 seviyesinde mavi okyanus gÃ¶rÃ¼nmeli
- Oyuncu hareket ettikÃ§e okyanus takip etmeli
- Okyanus asla bitmemeli

---

## âš ï¸ BÄ°LÄ°NEN SORUNLAR VE Ã‡Ã–ZÃœMLERÄ°

### Sorun 1: GPU Instancing Ã‡alÄ±ÅŸmÄ±yor

**Sebep:** Material GPU Instancing desteklemiyor

**Ã‡Ã¶zÃ¼m:**
- Material'in `Enable GPU Instancing` checkbox'Ä±nÄ± iÅŸaretle
- Shader'Ä±n GPU Instancing desteklediÄŸinden emin ol

---

### Sorun 2: AÄŸaÃ§lar Havada UÃ§uyor

**Sebep:** Raycast zemin layer'Ä±nÄ± bulamÄ±yor

**Ã‡Ã¶zÃ¼m:**
- `groundLayer` mask'Ä±nÄ± doÄŸru ayarla
- Chunk'larÄ±n layer'Ä±nÄ± "Ground" yap

---

### Sorun 3: Biyomlar KarÄ±ÅŸmÄ±yor

**Sebep:** `TerrainDensity.compute` iÃ§inde biyom seÃ§imi yanlÄ±ÅŸ

**Ã‡Ã¶zÃ¼m:**
- `temperature` ve `humidity` deÄŸerlerini kontrol et
- `ClimateNoiseScale` deÄŸerini ayarla (daha geniÅŸ biyomlar iÃ§in)

---

## ğŸ”— FAZ 3 ENTEGRASYON PLANI

### Faz 3'e NasÄ±l Entegre Edilir?

TÃ¼m bu sistemler **FAZ 3: DOÄA, SU VE BÄ°YOMLAR** iÃ§ine entegre edilmiÅŸtir. Ä°ÅŸte entegrasyon Ã¶zeti:

#### **1. VariantMeshGenerator Entegrasyonu**

**Nerede KullanÄ±lacak:**
- **NetworkMining.cs** iÃ§inde variant blok yerleÅŸtirme iÃ§in
- **GridPlacementSystem.cs** ile entegre

**Entegrasyon:**
- `VariantMeshGenerator.cs` dosyasÄ± `Scripts/Systems/Blocks/` klasÃ¶rÃ¼ne eklendi
- `ServiceLocator`'a kaydedildi (Awake'de)
- `NetworkMining.cs`'e variant desteÄŸi eklendi

#### **2. VoxelTreeGenerator + TreeGrowthSystem Entegrasyonu**

**Nerede KullanÄ±lacak:**
- **VegetationSpawner.cs** yerine voxel aÄŸaÃ§lar kullanÄ±lacak
- Prefab spawn yerine prosedÃ¼rel voxel aÄŸaÃ§lar

**Entegrasyon:**
- `VoxelTreeGenerator.cs` ve `TreeGrowthSystem.cs` dosyalarÄ± `Scripts/Systems/Nature/` klasÃ¶rÃ¼ne eklendi
- `VegetationSpawner.cs` gÃ¼ncellenebilir (opsiyonel - eski sistem hala Ã§alÄ±ÅŸÄ±yor)

#### **3. OreSpawner Entegrasyonu**

**Nerede KullanÄ±lacak:**
- **ChunkManager.cs** iÃ§inde chunk generation sÄ±rasÄ±nda
- **TerrainDensity.compute** ile entegre

**Entegrasyon:**
- `OreSpawner.cs` dosyasÄ± `Scripts/Systems/Mining/` klasÃ¶rÃ¼ne eklendi
- `OreDefinition.cs` ScriptableObject'i `Scripts/Data/ScriptableObjects/` klasÃ¶rÃ¼ne eklendi
- `ChunkManager.cs`'e `OnChunkGenerated` event'i eklendi
- `OreSpawner.cs`'te event'e abone olundu

#### **4. GridPlacementSystem + BlueprintSystem + SculptingSystem Entegrasyonu**

**Nerede KullanÄ±lacak:**
- **NetworkMining.cs** iÃ§inde blok yerleÅŸtirme iÃ§in
- Ä°nÅŸa sistemi iÃ§in

**Entegrasyon:**
- `GridPlacementSystem.cs`, `BlueprintSystem.cs`, `SculptingSystem.cs` dosyalarÄ± `Scripts/Systems/Building/` klasÃ¶rÃ¼ne eklendi
- `NetworkMining.cs`'e grid desteÄŸi eklendi

#### **5. ChunkManager GÃ¼ncellemeleri**

**Eklenecek Metodlar:**
- `AddDensityAtPoint(Vector3 worldPos, float density)` - Blok yerleÅŸtirme âœ…
- `RemoveDensityAtPoint(Vector3 worldPos)` - Blok kÄ±rma âœ…
- `SetBlockType(Vector3 worldPos, string blockType)` - Blok tipi kaydetme âœ…
- `GetBlockType(Vector3 worldPos)` - Blok tipi alma âœ…
- `GetWorldSeed()` - World seed alma âœ…
- `OnChunkGenerated` event - Chunk generation event'i âœ…

**Entegrasyon:**
- `ChunkManager.cs` dosyasÄ±na yukarÄ±daki metodlar eklendi
- `MarchingCubesGPU.cs`'e `AddDensity()` ve `RemoveDensity()` metodlarÄ± eklendi (Scrawk'tan)

---

### Entegrasyon SÄ±rasÄ±

1. âœ… **ChunkManager GÃ¼ncellemeleri** (Ã–nce bu yapÄ±ldÄ± - diÄŸer sistemler buna baÄŸÄ±mlÄ±)
   - `AddDensityAtPoint()`, `RemoveDensityAtPoint()`, `SetBlockType()`, `GetBlockType()`, `GetWorldSeed()` metodlarÄ±
   - `OnChunkGenerated` event'i
   - `RegenerateChunk()` coroutine'i

2. âœ… **VariantMeshGenerator** (Blok yerleÅŸtirme iÃ§in gerekli)
   - ServiceLocator'a kayÄ±t
   - NetworkMining.cs'te kullanÄ±m

3. âœ… **VoxelTreeGenerator + TreeGrowthSystem** (VegetationSpawner yerine)
   - VegetationSpawner.cs'te prefab spawn yerine voxel aÄŸaÃ§ spawn (opsiyonel)
   - Chunk generation sÄ±rasÄ±nda aÄŸaÃ§ spawn

4. âœ… **OreSpawner** (Maden spawn iÃ§in)
   - ChunkManager.OnChunkGenerated event'ine abone ol
   - TerrainDensity.compute ile entegrasyon

5. âœ… **GridPlacementSystem + BlueprintSystem + SculptingSystem** (Ä°nÅŸa sistemi)
   - NetworkMining.cs'te grid-based placement
   - Blueprint kaydetme/yÃ¼kleme
   - Sculpting sistemi

---

### Ã–nemli Notlar

1. **ChunkManager Dependencies:**
   - TÃ¼m sistemler ChunkManager'a baÄŸÄ±mlÄ±
   - ChunkManager gÃ¼ncellemeleri yapÄ±ldÄ±

2. **ServiceLocator:**
   - TÃ¼m yeni sistemler ServiceLocator'a kaydedildi
   - Awake() metodlarÄ±nda kayÄ±t yapÄ±ldÄ±

3. **Network Synchronization:**
   - Server-authoritative olmalÄ±
   - TÃ¼m deÄŸiÅŸiklikler server'da yapÄ±lmalÄ±
   - Client'lara RPC ile senkronize edilmeli

4. **Performance:**
   - Job System kullanÄ±ldÄ± (aÄŸaÃ§/maden generation)
   - Cache'ler kullanÄ±ldÄ± (mesh, grid, blueprint)
   - GPU Instancing (variant mesh rendering)

---

## ğŸ”„ ESKÄ° SÄ°STEM REFERANSLARI VE GÃœNCELLEMELER

### STRATOCRAFT_UNITY_DONUSUM_MASTER_PLAN.md'de GÃ¼ncellenmesi Gerekenler

#### **1. VegetationSpawner.cs - Voxel AÄŸaÃ§ Sistemi ile DeÄŸiÅŸtirilecek**

**Mevcut Durum (Faz 3'te):**
- Prefab-based aÄŸaÃ§ spawn (GPU Instancing ile)
- `PlaceVegetation()` metodu prefab instantiate ediyor

**Yeni Durum (Faz 3 GÃ¼ncellemesi):**
- **VoxelTreeGenerator** kullanÄ±lacak (prefab yerine)
- **TreeGrowthSystem** ile aÅŸamalÄ± bÃ¼yÃ¼me
- VegetationSpawner.cs'te `SpawnTrees()` metodu gÃ¼ncellenecek:

```csharp
// ESKÄ° KOD (Prefab-based):
void SpawnTrees(GameObject chunk, Vector3 chunkPos) {
    // ... prefab spawn kodu ...
    GameObject treePrefab = currentBiome.treePrefabs[Random.Range(0, currentBiome.treePrefabs.Count)];
    PlaceVegetation(treePrefab, pos, chunk.transform);
}

// YENÄ° KOD (Voxel-based):
void SpawnTrees(GameObject chunk, Vector3 chunkPos) {
    // VoxelTreeGenerator kullan
    VoxelTreeGenerator treeGenerator = ServiceLocator.Instance?.Get<VoxelTreeGenerator>();
    TreeGrowthSystem growthSystem = ServiceLocator.Instance?.Get<TreeGrowthSystem>();
    
    if (treeGenerator == null || growthSystem == null) return;
    
    // Fidan dik (bÃ¼yÃ¼me baÅŸlat)
    Vector3Int treePos = new Vector3Int(
        Mathf.FloorToInt(chunkPos.x),
        Mathf.FloorToInt(chunkPos.y),
        Mathf.FloorToInt(chunkPos.z)
    );
    
    growthSystem.PlantSapling(treePos, "oak");
}
```

**GÃ¼ncellenecek Dosya:** `STRATOCRAFT_UNITY_DONUSUM_MASTER_PLAN.md` - Faz 3, ADIM 3.1 VegetationSpawner.cs

---

#### **2. WaterSim.compute - DetaylÄ± Su MekaniÄŸi Eklenecek**

**Mevcut Durum (Faz 3'te):**
- Sadece aÅŸaÄŸÄ± akÄ±ÅŸ var
- Yan tarafa akÄ±ÅŸ yok
- YayÄ±lma mekaniÄŸi yok
- Ã–ncelik sistemi yok

**Yeni Durum (Faz 3 GÃ¼ncellemesi):**
- **Minecraft tarzÄ± matematiksel voxel su mekaniÄŸi**
- AÅŸaÄŸÄ± akÄ±ÅŸ (gravity)
- Yan tarafa akÄ±ÅŸ (4 yÃ¶n: kuzey, gÃ¼ney, doÄŸu, batÄ±)
- YayÄ±lma mekaniÄŸi (su seviyesi 0-7 arasÄ±)
- Ã–ncelik sistemi (aÅŸaÄŸÄ± > yan > yayÄ±lma)
- BoÅŸluk kontrolÃ¼ (su sadece boÅŸ voxel'lere akar)
- Kaynak su (sonsuz su kaynaÄŸÄ±)
- Su seviyesi (full block = 7, akÄ±ÅŸkan = 0-6)

**Not:** DetaylÄ± WaterSim.compute kodu Faz 3, ADIM 4.2'de mevcuttur.

**GÃ¼ncellenecek Dosya:** `STRATOCRAFT_UNITY_DONUSUM_MASTER_PLAN.md` - Faz 3, ADIM 4.2 WaterSim.compute

---

#### **3. WaterSimulator.cs - Su MekaniÄŸi Entegrasyonu**

**Mevcut Durum:**
- Basit su grid yÃ¶netimi
- Sadece aÅŸaÄŸÄ± akÄ±ÅŸ

**Yeni Durum:**
- Su seviyesi yÃ¶netimi (0-7)
- Kaynak su sistemi
- YayÄ±lma mekaniÄŸi
- Ã–ncelik sistemi

**Not:** DetaylÄ± WaterSimulator.cs metodlarÄ± Faz 3, ADIM 4.2'de mevcuttur.

**GÃ¼ncellenecek Dosya:** `STRATOCRAFT_UNITY_DONUSUM_MASTER_PLAN.md` - Faz 3, ADIM 4.2 WaterSimulator.cs

---

#### **4. ChunkManager.cs - Yeni Metodlar**

**Eklenecek Metodlar:**
- `GetActiveChunkCoords()` - Aktif chunk koordinatlarÄ±nÄ± dÃ¶ndÃ¼r
- `GetDensityBufferForChunk(Vector3Int chunkCoord)` - Density buffer'Ä± dÃ¶ndÃ¼r
- `GetChunkCoord(Vector3 worldPos)` - World pozisyonundan chunk koordinatÄ±
- `AddDensityAtPoint(Vector3 worldPos, float density)` - Blok yerleÅŸtirme iÃ§in
- `RemoveDensityAtPoint(Vector3 worldPos)` - Blok kÄ±rma iÃ§in
- `SetBlockType(Vector3 worldPos, string blockType)` - Blok tipi ayarlama
- `GetBlockType(Vector3 worldPos)` - Blok tipi alma
- `GetWorldSeed()` - Deterministik rastgelelik iÃ§in
- `OnChunkGenerated` event - OreSpawner, VoxelTreeGenerator iÃ§in

**Not:** Bu metodlar Faz 1-2'de ChunkManager.cs'e eklenmiÅŸtir.

**GÃ¼ncellenecek Dosya:** `STRATOCRAFT_UNITY_DONUSUM_MASTER_PLAN.md` - Faz 1-2, ChunkManager.cs

---

### Faz 3'te YapÄ±lacak GÃ¼ncellemeler Ã–zeti

1. âœ… **VegetationSpawner.cs** â†’ VoxelTreeGenerator + TreeGrowthSystem kullanÄ±lacak
2. âœ… **WaterSim.compute** â†’ DetaylÄ± su mekaniÄŸi (akma, yayÄ±lma, Ã¶ncelik)
3. âœ… **WaterSimulator.cs** â†’ Su seviyesi yÃ¶netimi, kaynak su, yayÄ±lma
4. âœ… **ChunkManager.cs** â†’ Yeni metodlar (AddDensityAtPoint, SetBlockType, OnChunkGenerated)

---

### DiÄŸer Fazlarda GÃ¼ncellenmesi Gerekenler

**Faz 4-8:** Bu fazlarda voxel sistem referanslarÄ± kontrol edilmeli:
- `NetworkMining.cs` â†’ Variant blok desteÄŸi eklenecek
- `ItemSpawner.cs` â†’ Voxel terrain uyumluluÄŸu kontrol edilecek
- `MobSpawner.cs` â†’ Voxel terrain uyumluluÄŸu kontrol edilecek

**Not:** Bu gÃ¼ncellemeler Faz 3 tamamlandÄ±ktan sonra yapÄ±lacak.

---

## ğŸ”§ GÃœNCELLENMESÄ° GEREKEN MEVCUT DOSYALAR

### 1. NetworkMining.cs GÃ¼ncellemeleri:

```csharp
// NetworkMining.cs'e eklenecek:

private VariantMeshGenerator _variantGenerator;
private GridPlacementSystem _gridSystem;

void Start() {
    _variantGenerator = ServiceLocator.Instance?.Get<VariantMeshGenerator>();
    _gridSystem = ServiceLocator.Instance?.Get<GridPlacementSystem>();
}

// Variant blok yerleÅŸtirme
void PlaceVariantBlock(Vector3 point, string variantId) {
    if (_gridSystem != null) {
        _gridSystem.PlaceBlockAtGrid(point, "block", variantId);
    }
}
```

### 2. ChunkManager.cs GÃ¼ncellemeleri:

**Not:** ChunkManager.cs gÃ¼ncellemeleri Faz 1-2'de yapÄ±lmÄ±ÅŸtÄ±r. AÅŸaÄŸÄ±daki metodlar mevcuttur:

- `AddDensityAtPoint(Vector3 worldPos, float density)` - Blok yerleÅŸtirme iÃ§in
- `RemoveDensityAtPoint(Vector3 worldPos)` - Blok kÄ±rma iÃ§in
- `SetBlockType(Vector3 worldPos, string blockType)` - Blok tipi ayarlama
- `GetBlockType(Vector3 worldPos)` - Blok tipi alma
- `GetWorldSeed()` - Deterministik rastgelelik iÃ§in
- `OnChunkGenerated` event - OreSpawner, VoxelTreeGenerator iÃ§in

---

## ğŸ“š REFERANSLAR VE KAYNAKLAR

1. **GPU Instancing:** https://docs.unity3d.com/Manual/GPUInstancing.html
2. **FastNoiseLite:** https://github.com/Auburn/FastNoiseLite
3. **Object Pooling:** https://learn.unity.com/tutorial/introduction-to-object-pooling
4. **Compute Shaders:** https://docs.unity3d.com/Manual/ComputeShaders.html

---

**Son GÃ¼ncelleme:** BugÃ¼n  
**Durum:** âœ… FAZ 3 TAMAMLANDI - DetaylÄ± dokÃ¼mantasyon hazÄ±r

---





**Son GÃ¼ncelleme:** BugÃ¼n  
**Durum:** âœ… FAZ 3 TAMAMLANDI - DetaylÄ± dokÃ¼mantasyon hazÄ±r

---

# ğŸ® FAZ 4: OYUN MEKANÄ°KLERÄ° (GAMEPLAY SYSTEMS)

**AmaÃ§:** DÃ¼nyayÄ± tek dÃ¼ze bir simÃ¼lasyondan, oyuncularÄ±n ticaret yaptÄ±ÄŸÄ±, bÃ¼yÃ¼ler kurduÄŸu ve bÃ¶lge savaÅŸÄ± verdiÄŸi bir **MMO RPG**'ye dÃ¶nÃ¼ÅŸtÃ¼rmek.

**SÃ¼re Tahmini:** 3-4 hafta  
**Zorluk:** â­â­â­â­ (Veri OdaklÄ± TasarÄ±m ve AÄŸ Senkronizasyonu)

**Motto:** **"Data-Driven Design"** - Kod iÃ§ine `if (item == "Sword")` yazmak yasak. Her ÅŸey Unity EditÃ¶rÃ¼nden yÃ¶netilecek.

---

## ğŸ’ ADIM 1: EÅYA MÄ°MARÄ°SÄ° (Item Architecture)

### 1.1 ItemDefinition.cs (ScriptableObject)

**Dosya:** `_Stratocraft/Scripts/Core/Definitions/ItemDefinition.cs`

**AmaÃ§:** Unity'ye "EÅŸya nedir?" sorusunu Ã¶ÄŸretmek. String kullanmak yerine ID tabanlÄ± bir sistem kurmak.

**Kod:**

```csharp
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// âœ… Data-Driven Item System - ScriptableObject tabanlÄ± eÅŸya tanÄ±mlarÄ±
/// Java'daki ItemManager'Ä±n Unity eÅŸdeÄŸeri
/// </summary>
public enum ItemType {
    Material,      // Madenler, taÅŸlar (Titanium, Red Diamond)
    Weapon,        // Silahlar (War Fan, Tower Shield)
    Tool,          // AraÃ§lar (Rusty Hook, Titan Grapple)
    Structure,     // YapÄ± Ã§ekirdekleri (Structure Core, Trap Core)
    Battery,       // Bataryalar (Lightning Core, Flame Amplifier)
    Consumable,    // TÃ¼ketilebilirler (Life Elixir, Power Fruit)
    Contract,      // Kontrat kaÄŸÄ±dÄ±
    Recipe,        // Tarif kitaplarÄ±
    Special        // Ã–zel eÅŸyalar (Casusluk DÃ¼rbÃ¼nÃ¼, Personal Terminal)
}

/// <summary>
/// âœ… Materyal tipleri (kÄ±rma sistemi iÃ§in)
/// </summary>
public enum MaterialType {
    GRASS,         // Ã‡imen
    DIRT,          // Toprak
    STONE,         // TaÅŸ
    DEEP_STONE,    // Derin taÅŸ
    IRON_ORE,      // Demir cevheri
    COAL_ORE,      // KÃ¶mÃ¼r cevheri
    COPPER_ORE,    // BakÄ±r cevheri
    GOLD_ORE,      // AltÄ±n cevheri
    DIAMOND_ORE,   // Elmas cevheri
    EMERALD_ORE    // ZÃ¼mrÃ¼t cevheri
}

[CreateAssetMenu(fileName = "New Item", menuName = "Stratocraft/Data/Item", order = 1)]
public class ItemDefinition : ScriptableObject {
    [Header("Kimlik")]
    [Tooltip("EÅŸya ID'si (veritabanÄ± iÃ§in) - Ã–rn: 'titanium_ore', 'clan_crystal'")]
    public string itemID = "";
    
    [Tooltip("GÃ¶rÃ¼nen ad")]
    public string displayName = "Unknown Item";
    
    [Tooltip("AÃ§Ä±klama")]
    [TextArea(3, 5)]
    public string description = "";
    
    [Tooltip("UI Ä°konu")]
    public Sprite icon;
    
    [Tooltip("Yere atÄ±lÄ±nca oluÅŸacak 3D model (fiziksel obje)")]
    public GameObject worldPrefab;

    [Header("Ã–zellikler")]
    [Tooltip("EÅŸya tipi")]
    public ItemType type = ItemType.Material;
    
    [Tooltip("Maksimum yÄ±ÄŸÄ±n sayÄ±sÄ±")]
    [Range(1, 999)]
    public int maxStack = 64;
    
    [Tooltip("AÄŸÄ±rlÄ±k (taÅŸÄ±ma sistemi iÃ§in)")]
    [Range(0.1f, 100f)]
    public float weight = 1.0f;
    
    [Tooltip("DeÄŸer (altÄ±n cinsinden)")]
    public int value = 0;

    [Header("RitÃ¼el Verisi")]
    [Tooltip("RitÃ¼elde kullanÄ±ldÄ±ÄŸÄ±nda yayacaÄŸÄ± enerji rengi (gÃ¶rsel ÅŸÃ¶len iÃ§in)")]
    public Color ritualEnergyColor = Color.white;
    
    [Tooltip("RitÃ¼el enerji yoÄŸunluÄŸu (0-1)")]
    [Range(0f, 1f)]
    public float ritualEnergyIntensity = 0.5f;

    [Header("Ã–zel Ã–zellikler")]
    [Tooltip("TÃ¼ketilebilir mi? (Consumable iÃ§in)")]
    public bool isConsumable = false;
    
    [Tooltip("Can yenileme miktarÄ± (Consumable iÃ§in)")]
    public int healthRestored = 0;
    
    [Tooltip("Hasar artÄ±ÅŸÄ± (Consumable iÃ§in)")]
    public float damageMultiplier = 1.0f;
    
    [Tooltip("HÄ±z artÄ±ÅŸÄ± (Consumable iÃ§in)")]
    public float speedMultiplier = 1.0f;

    [Header("AÄŸ Ã–zellikleri")]
    [Tooltip("AÄŸ Ã¼zerinden senkronize edilsin mi?")]
    public bool syncOverNetwork = true;
    
    [Tooltip("Spawn edildiÄŸinde otomatik despawn sÃ¼resi (saniye, 0 = despawn yok)")]
    public float autoDespawnTime = 300f; // 5 dakika
    
    [Header("Blok Ã–zellikleri (YerleÅŸtirilebilir EÅŸyalar Ä°Ã§in)")]
    [Tooltip("Bu eÅŸya blok olarak yerleÅŸtirilebilir mi?")]
    public bool isPlaceable = false;
    
    [Tooltip("Blok hardness deÄŸeri (kÄ±rma sÃ¼resi - saniye) - 0.5 = hÄ±zlÄ±, 5.0 = Ã§ok yavaÅŸ")]
    [Range(0.1f, 10f)]
    public float blockHardness = 1.0f;
    
    [Tooltip("Blok prefab'Ä± (yerleÅŸtirildiÄŸinde oluÅŸacak 3D model)")]
    public GameObject blockPrefab;
    
    [Header("Tool Ã–zellikleri (AraÃ§lar Ä°Ã§in)")]
    [Tooltip("Bu eÅŸya bir tool mu? (kazma, kÃ¼rek, balta)")]
    public bool isTool = false;
    
    [Tooltip("Tool efficiency (kÄ±rma hÄ±zÄ± Ã§arpanÄ±) - 1.0 = normal, 2.0 = 2x hÄ±zlÄ±")]
    [Range(0.5f, 5f)]
    public float toolEfficiency = 1.0f;
    
    [Tooltip("Tool'un etkili olduÄŸu materyal tipleri")]
    public MaterialType[] effectiveMaterials;

    /// <summary>
    /// âœ… EÅŸya ID'sini al (veritabanÄ± iÃ§in)
    /// </summary>
    public string GetItemID() {
        return string.IsNullOrEmpty(itemID) ? name : itemID;
    }
    
    /// <summary>
    /// âœ… Tool bu materyal tipine etkili mi?
    /// </summary>
    public bool IsEffectiveAgainst(MaterialType materialType) {
        if (!isTool || effectiveMaterials == null) return false;
        foreach (var mat in effectiveMaterials) {
            if (mat == materialType) return true;
        }
        return false;
    }

    /// <summary>
    /// âœ… EÅŸya eÅŸit mi kontrol et (ID bazlÄ±)
    /// </summary>
    public bool Equals(ItemDefinition other) {
        if (other == null) return false;
        return GetItemID() == other.GetItemID();
    }
}
```

**KullanÄ±m:**
1. Unity'de `Assets/_Stratocraft/Data/Items/` klasÃ¶rÃ¼ne saÄŸ tÄ±kla
2. `Create` â†’ `Stratocraft/Data/Item`
3. **Titanium Ore:** ID: "titanium_ore", Type: Material, MaxStack: 64
4. **Clan Crystal:** ID: "clan_crystal", Type: Structure, MaxStack: 1

---

### 1.2 ItemDatabase.cs

**Dosya:** `_Stratocraft/Scripts/Core/ItemDatabase.cs`

**AmaÃ§:** TÃ¼m ItemDefinition'larÄ± yÃ¶netmek ve ID bazlÄ± arama yapmak (Java'daki ItemManager eÅŸdeÄŸeri)

**Kod:**

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: EÅŸya veritabanÄ± - TÃ¼m ItemDefinition'larÄ± yÃ¶netir
/// Java'daki ItemManager'Ä±n Unity eÅŸdeÄŸeri
/// </summary>
public class ItemDatabase : MonoBehaviour {
    [Header("EÅŸya TanÄ±mlarÄ±")]
    [Tooltip("TÃ¼m eÅŸya ScriptableObject'leri (otomatik yÃ¼klenecek)")]
    public List<ItemDefinition> allItems = new List<ItemDefinition>();

    // âœ… OPTÄ°MÄ°ZE: Dictionary cache (O(1) lookup)
    private Dictionary<string, ItemDefinition> _itemCache = new Dictionary<string, ItemDefinition>();

    private static ItemDatabase _instance;
    public static ItemDatabase Instance {
        get {
            if (_instance == null) {
                _instance = FindObjectOfType<ItemDatabase>();
            }
            return _instance;
        }
    }

    void Awake() {
        if (_instance == null) {
            _instance = this;
            DontDestroyOnLoad(gameObject);
            
            // âœ… TÃ¼m eÅŸyalarÄ± cache'le
            BuildCache();
            
            // âœ… ServiceLocator'a kaydet
            ServiceLocator.Instance?.Register<ItemDatabase>(this);
        } else if (_instance != this) {
            Destroy(gameObject);
        }
    }

    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: Cache oluÅŸtur (baÅŸlangÄ±Ã§ta bir kez)
    /// </summary>
    void BuildCache() {
        _itemCache.Clear();
        
        foreach (var item in allItems) {
            if (item == null) continue;
            
            string id = item.GetItemID();
            if (!string.IsNullOrEmpty(id)) {
                _itemCache[id] = item;
            }
        }
        
        Debug.Log($"[ItemDatabase] {_itemCache.Count} eÅŸya yÃ¼klendi");
    }

    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: ID'den eÅŸya al (O(1) lookup)
    /// </summary>
    public ItemDefinition GetItem(string itemID) {
        if (string.IsNullOrEmpty(itemID)) return null;
        
        if (_itemCache.TryGetValue(itemID, out ItemDefinition item)) {
            return item;
        }
        
        Debug.LogWarning($"[ItemDatabase] EÅŸya bulunamadÄ±: {itemID}");
        return null;
    }

    /// <summary>
    /// âœ… Tipe gÃ¶re eÅŸyalarÄ± al
    /// </summary>
    public List<ItemDefinition> GetItemsByType(ItemType type) {
        return allItems.Where(item => item != null && item.type == type).ToList();
    }

    /// <summary>
    /// âœ… EÅŸya var mÄ± kontrol et
    /// </summary>
    public bool HasItem(string itemID) {
        return _itemCache.ContainsKey(itemID);
    }

    /// <summary>
    /// âœ… TÃ¼m eÅŸyalarÄ± al
    /// </summary>
    public List<ItemDefinition> GetAllItems() {
        return new List<ItemDefinition>(allItems);
    }
}
```

---

### 1.3 PhysicalItem.cs (NetworkBehaviour)

**Dosya:** `_Stratocraft/Scripts/Systems/Interaction/PhysicalItem.cs`

**AmaÃ§:** Yere atÄ±lan eÅŸyalarÄ±n fiziksel temsili (Java'daki yere atÄ±lan item'larÄ±n Unity eÅŸdeÄŸeri)

**Kod:**

```csharp
using FishNet.Object;
using FishNet.Object.Synchronizing;
using UnityEngine;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Fiziksel eÅŸya - Yere atÄ±lan eÅŸyalarÄ±n aÄŸ senkronizasyonu
/// Java'daki yere atÄ±lan ItemStack'lerin Unity eÅŸdeÄŸeri
/// </summary>
public class PhysicalItem : NetworkBehaviour {
    [Header("EÅŸya Verisi")]
    [Tooltip("EÅŸyanÄ±n ID'si (aÄŸ Ã¼zerinden senkronize edilir)")]
    [SyncVar(OnChange = nameof(OnItemChanged))]
    public string itemID = "";
    
    [Tooltip("YÄ±ÄŸÄ±n sayÄ±sÄ±")]
    [SyncVar]
    public int stackSize = 1;

    // âœ… Cache: ItemDefinition (client tarafÄ±nda)
    private ItemDefinition _itemData;
    
    // âœ… Referanslar
    private Rigidbody _rigidbody;
    private Collider _collider;
    private float _spawnTime;
    
    // âœ… OPTÄ°MÄ°ZE: Voxel terrain entegrasyonu
    private ChunkManager _chunkManager;
    private bool _isGrounded = false;
    private float _groundCheckInterval = 0.1f; // 10 kez/saniye kontrol
    private float _lastGroundCheck = 0f;

    void Awake() {
        _rigidbody = GetComponent<Rigidbody>();
        _collider = GetComponent<Collider>();
        
        // âœ… Fizik ayarlarÄ±
        if (_rigidbody != null) {
            _rigidbody.useGravity = true;
            _rigidbody.drag = 2f; // Hava direnci
            _rigidbody.mass = 0.1f; // Hafif eÅŸyalar
        }
        
        if (_collider != null) {
            _collider.isTrigger = false; // Fiziksel Ã§arpÄ±ÅŸma
        }
    }
    
    void Start() {
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
    }

    public override void OnStartServer() {
        base.OnStartServer();
        _spawnTime = Time.time;
        
        // âœ… Otomatik despawn kontrolÃ¼ (server tarafÄ±nda)
        if (!string.IsNullOrEmpty(itemID)) {
            ItemDefinition item = ItemDatabase.Instance?.GetItem(itemID);
            if (item != null && item.autoDespawnTime > 0) {
                Invoke(nameof(DespawnItem), item.autoDespawnTime);
            }
        }
    }

    public override void OnStartClient() {
        base.OnStartClient();
        
        // âœ… Client tarafÄ±nda item verisini yÃ¼kle
        if (!string.IsNullOrEmpty(itemID)) {
            LoadItemData(itemID);
        }
    }

    /// <summary>
    /// âœ… SyncVar deÄŸiÅŸtiÄŸinde Ã§aÄŸrÄ±lÄ±r (client tarafÄ±nda)
    /// </summary>
    void OnItemChanged(string oldID, string newID, bool asServer) {
        if (asServer) return; // Sunucuda Ã§alÄ±ÅŸtÄ±rma
        
        LoadItemData(newID);
    }

    /// <summary>
    /// âœ… EÅŸya verisini yÃ¼kle (client tarafÄ±nda)
    /// </summary>
    void LoadItemData(string id) {
        if (string.IsNullOrEmpty(id)) return;
        
        _itemData = ItemDatabase.Instance?.GetItem(id);
        if (_itemData == null) {
            Debug.LogWarning($"[PhysicalItem] EÅŸya bulunamadÄ±: {id}");
            return;
        }
        
        // âœ… Modeli yÃ¼kle (worldPrefab'dan)
        if (_itemData.worldPrefab != null) {
            // âœ… Mevcut modeli sil
            foreach (Transform child in transform) {
                if (Application.isPlaying) {
                    Destroy(child.gameObject);
                }
            }
            
            // âœ… Yeni modeli spawn et
            GameObject model = Instantiate(_itemData.worldPrefab, transform);
            model.transform.localPosition = Vector3.zero;
            model.transform.localRotation = Quaternion.identity;
        }
        
        // âœ… UI gÃ¼ncelle (stack size gÃ¶ster)
        UpdateVisuals();
    }

    /// <summary>
    /// âœ… GÃ¶rsel gÃ¼ncelle (stack size, icon vb.)
    /// </summary>
    void UpdateVisuals() {
        // âœ… Stack size gÃ¶ster (TextMesh veya Canvas)
        // Bu kÄ±sÄ±m UI sistemine baÄŸlÄ± olacak
    }

    /// <summary>
    /// âœ… EÅŸyayÄ± al (oyuncu topladÄ±ÄŸÄ±nda)
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void CmdPickup(NetworkObject player) {
        if (player == null) return;
        
        // âœ… Oyuncu envanterine ekle (InventoryManager'dan)
        // InventoryManager.AddItem(itemID, stackSize);
        
        // âœ… EÅŸyayÄ± despawn et
        DespawnItem();
    }

    /// <summary>
    /// âœ… EÅŸyayÄ± despawn et
    /// </summary>
    void DespawnItem() {
        if (IsServer) {
            Despawn();
        }
    }

    /// <summary>
    /// âœ… EÅŸya verisini al
    /// </summary>
    public ItemDefinition GetItemData() {
        return _itemData;
    }

    /// <summary>
    /// âœ… EÅŸya ID'sini al
    /// </summary>
    public string GetItemID() {
        return itemID;
    }
    
    void FixedUpdate() {
        if (!IsServer) return; // Sadece server tarafÄ±nda
        
        // âœ… OPTÄ°MÄ°ZE: Voxel terrain Ã¼zerinde zemin kontrolÃ¼ (cooldown ile)
        if (Time.time - _lastGroundCheck >= _groundCheckInterval) {
            _lastGroundCheck = Time.time;
            CheckGroundedOnVoxelTerrain();
        }
    }
    
    /// <summary>
    /// âœ… Voxel terrain Ã¼zerinde zemin kontrolÃ¼
    /// </summary>
    void CheckGroundedOnVoxelTerrain() {
        if (_chunkManager == null || _rigidbody == null) return;
        
        // âœ… Raycast ile voxel terrain'e bak
        RaycastHit hit;
        float checkDistance = 0.2f; // 20cm altÄ±na bak
        Vector3 rayStart = transform.position;
        
        if (Physics.Raycast(rayStart, Vector3.down, out hit, checkDistance)) {
            // âœ… Voxel terrain Ã¼zerinde mi?
            if (hit.collider.gameObject.GetComponent<MarchingCubesGPU>() != null) {
                _isGrounded = true;
                
                // âœ… EÄŸer Ã§ok hÄ±zlÄ± dÃ¼ÅŸÃ¼yorsa, hÄ±zÄ± sÄ±nÄ±rla (voxel terrain korumasÄ±)
                if (_rigidbody.velocity.y < -10f) {
                    _rigidbody.velocity = new Vector3(
                        _rigidbody.velocity.x,
                        -5f, // Maksimum dÃ¼ÅŸÃ¼ÅŸ hÄ±zÄ±
                        _rigidbody.velocity.z
                    );
                }
            } else {
                _isGrounded = false;
            }
        } else {
            _isGrounded = false;
        }
        
        // âœ… Alternatif: ChunkManager'dan density kontrolÃ¼ (daha hassas)
        if (!_isGrounded && _chunkManager != null) {
            Vector3Int chunkCoord = _chunkManager.GetChunkCoord(transform.position);
            float[] densityData = _chunkManager.GetDensityDataForChunk(chunkCoord);
            
            if (densityData != null) {
                // âœ… Local voxel koordinatÄ±nÄ± hesapla
                Vector3Int localPos = new Vector3Int(
                    Mathf.FloorToInt(transform.position.x) % 32,
                    Mathf.FloorToInt(transform.position.y) % 32,
                    Mathf.FloorToInt(transform.position.z) % 32
                );
                
                // âœ… Density kontrolÃ¼ (basit yaklaÅŸÄ±m)
                // Ä°leride daha geliÅŸmiÅŸ kontrol yapÄ±labilir
            }
        }
    }
}
```

---

### 1.4 ItemSpawner.cs

**Dosya:** `_Stratocraft/Scripts/Systems/Interaction/ItemSpawner.cs`

**AmaÃ§:** EÅŸyalarÄ± dÃ¼nyaya spawn etmek (kazÄ±, Ã¶lÃ¼m, vb. durumlarda)

**Kod:**

```csharp
using FishNet.Object;
using UnityEngine;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: EÅŸya spawn sistemi - Voxel terrain Ã¼zerinde dÃ¼nyaya eÅŸya yerleÅŸtirme
/// ChunkManager entegrasyonu ile voxel terrain Ã¼zerinde gÃ¼venli spawn
/// </summary>
public class ItemSpawner : NetworkBehaviour {
    [Header("Ayarlar")]
    [Tooltip("Fiziksel eÅŸya prefab'Ä± (PhysicalItem component'i olmalÄ±)")]
    public GameObject physicalItemPrefab;
    
    [Tooltip("Spawn mesafesi (oyuncudan uzakta spawn etme)")]
    public float spawnDistance = 2f;
    
    [Tooltip("Voxel terrain layer mask")]
    public LayerMask voxelTerrainLayer;
    
    [Tooltip("Zemin bulma raycast mesafesi")]
    [Range(1f, 50f)]
    public float groundRaycastDistance = 20f;

    // âœ… OPTÄ°MÄ°ZE: ChunkManager referansÄ±
    private ChunkManager _chunkManager;

    void Awake() {
        // âœ… ServiceLocator'a kaydet
        ServiceLocator.Instance?.Register<ItemSpawner>(this);
    }

    void Start() {
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        if (_chunkManager == null) {
            Debug.LogError("[ItemSpawner] ChunkManager bulunamadÄ±!");
        }
    }

    /// <summary>
    /// âœ… EÅŸyayÄ± dÃ¼nyaya spawn et (server tarafÄ±nda) - Voxel terrain uyumlu
    /// </summary>
    [Server]
    public void SpawnItem(string itemID, int stackSize, Vector3 position) {
        if (string.IsNullOrEmpty(itemID)) return;
        
        ItemDefinition item = ItemDatabase.Instance?.GetItem(itemID);
        if (item == null) {
            Debug.LogWarning($"[ItemSpawner] EÅŸya bulunamadÄ±: {itemID}");
            return;
        }
        
        // âœ… Voxel terrain Ã¼zerinde zemin pozisyonunu bul
        Vector3 groundPosition = GetGroundPositionOnVoxelTerrain(position);
        if (groundPosition == Vector3.zero) {
            Debug.LogWarning($"[ItemSpawner] Voxel terrain Ã¼zerinde zemin bulunamadÄ±: {position}");
            return;
        }
        
        // âœ… Chunk kontrolÃ¼ (voxel terrain iÃ§in)
        Vector3Int chunkCoord = _chunkManager?.GetChunkCoord(groundPosition) ?? Vector3Int.zero;
        GameObject chunk = _chunkManager?.GetChunk(chunkCoord);
        if (chunk == null) {
            Debug.LogWarning($"[ItemSpawner] Chunk henÃ¼z yÃ¼klenmedi: {chunkCoord}");
            return;
        }
        
        // âœ… Fiziksel eÅŸya oluÅŸtur
        GameObject itemObj = Instantiate(physicalItemPrefab, groundPosition, Quaternion.identity);
        PhysicalItem physicalItem = itemObj.GetComponent<PhysicalItem>();
        
        if (physicalItem != null) {
            physicalItem.itemID = itemID;
            physicalItem.stackSize = stackSize;
        }
        
        // âœ… AÄŸ Ã¼zerinden spawn et (tÃ¼m clientlara gÃ¶nder)
        NetworkObject itemNet = itemObj.GetComponent<NetworkObject>();
        if (itemNet == null) {
            itemNet = itemObj.AddComponent<NetworkObject>();
        }
        Spawn(itemNet);
    }

    /// <summary>
    /// âœ… EÅŸyayÄ± rastgele yÃ¶n ve hÄ±zla fÄ±rlat (kazÄ± sonrasÄ±) - Voxel terrain uyumlu
    /// </summary>
    [Server]
    public void SpawnItemWithForce(string itemID, int stackSize, Vector3 position, Vector3 force) {
        // âœ… Ã–nce normal spawn et
        SpawnItem(itemID, stackSize, position);
        
        // âœ… Fiziksel eÅŸyayÄ± bul ve force uygula
        Collider[] colliders = Physics.OverlapSphere(position, 1f);
        foreach (var col in colliders) {
            PhysicalItem item = col.GetComponent<PhysicalItem>();
            if (item != null && item.itemID == itemID) {
                Rigidbody rb = item.GetComponent<Rigidbody>();
                if (rb != null) {
                    rb.AddForce(force, ForceMode.Impulse);
                }
                break;
            }
        }
    }

    /// <summary>
    /// âœ… Voxel terrain Ã¼zerinde zemin pozisyonunu bul (raycast + ChunkManager)
    /// </summary>
    Vector3 GetGroundPositionOnVoxelTerrain(Vector3 position) {
        // âœ… 1. Raycast ile voxel terrain'e bak
        RaycastHit hit;
        Vector3 rayStart = position + Vector3.up * 10f;
        
        if (Physics.Raycast(rayStart, Vector3.down, out hit, groundRaycastDistance, voxelTerrainLayer)) {
            // âœ… Voxel terrain Ã¼zerinde mi? (MarchingCubesGPU component'i kontrolÃ¼)
            if (hit.collider.gameObject.GetComponent<MarchingCubesGPU>() != null) {
                return hit.point + Vector3.up * 0.1f; // Zemin Ã¼zerinde biraz yukarÄ±da
            }
        }
        
        // âœ… 2. Alternatif: ChunkManager'dan density kontrolÃ¼ ile yÃ¼kseklik hesapla
        if (_chunkManager != null) {
            Vector3Int chunkCoord = _chunkManager.GetChunkCoord(position);
            float[] densityData = _chunkManager.GetDensityDataForChunk(chunkCoord);
            
            if (densityData != null) {
                // âœ… Local voxel koordinatÄ±nÄ± hesapla
                Vector3Int localPos = new Vector3Int(
                    Mathf.FloorToInt(position.x) % 32,
                    Mathf.FloorToInt(position.y) % 32,
                    Mathf.FloorToInt(position.z) % 32
                );
                
                // âœ… Density'den yÃ¼kseklik bul (density > 0 ise dolu)
                // Basit yaklaÅŸÄ±m: Y pozisyonunu ayarla
                // Ä°leride daha geliÅŸmiÅŸ yÃ¼kseklik hesaplama yapÄ±labilir
                return new Vector3(position.x, position.y, position.z);
            }
        }
        
        // âœ… 3. Son Ã§are: Orijinal pozisyonu kullan
        return position;
    }
}
```



## ğŸ› ï¸ ADIM 1.5: BLOK ÅEKÄ°LLENDÄ°RME SÄ°STEMÄ° (BLOCK SHAPING SYSTEM)

> **âœ… YENÄ° SÄ°STEM:** OyuncularÄ±n voxel bloklarÄ± (odun, taÅŸ, metal vb.) ÅŸekillendirmesini saÄŸlayan geliÅŸmiÅŸ alet sistemi.  
> **Entegrasyon:** NetworkMining, VariantMeshGenerator, ChunkManager, GridPlacementSystem  
> **Faz:** 4 (Oyun Mekanikleri)

### 1.5.1 Sistem Genel BakÄ±ÅŸ

**AmaÃ§:**
OyuncularÄ±n voxel bloklarÄ± (odun, taÅŸ, metal vb.) ÅŸekillendirmesini saÄŸlamak. Marangoz gibi Ã¶nce iÅŸaretle, sonra kes mantÄ±ÄŸÄ±yla Ã§alÄ±ÅŸan, kolay kullanÄ±mlÄ± bir sistem.

**Temel Ã–zellikler:**
1. **Malzeme BazlÄ± Aletler**: Her malzeme iÃ§in Ã¶zel alet (Odun Kesici, TaÅŸ Kesici, Metal Kesici)
2. **3 Kesim Modu**: KÃ¼p kesiÅŸ, Yuvarlayarak kesiÅŸ, Ã‡apraz kesiÅŸ
3. **Ä°ki Nokta SeÃ§imi**: BaÅŸlangÄ±Ã§ ve bitiÅŸ noktasÄ± seÃ§imi
4. **GÃ¶rsel Ã–nizleme**: Kesim Ã¶ncesi gÃ¶rsel geri bildirim
5. **Kaydetme Sistemi**: KesilmiÅŸ ÅŸekilleri kaydet ve diÄŸer bloklara uygula
6. **Kolay KullanÄ±m**: Mouse ile Ã¼zerine gelip seÃ§im yapma

**KullanÄ±m Senaryosu:**
1. Oyuncu aleti eline alÄ±r (Ã¶r: Odun Kesici)
2. Alet modunu seÃ§er (KÃ¼p/Yuvarlak/Ã‡apraz)
3. Blok Ã¼zerine gelir, baÅŸlangÄ±Ã§ noktasÄ±nÄ± seÃ§er (sol tÄ±k)
4. BitiÅŸ noktasÄ±nÄ± seÃ§er (sol tÄ±k)
5. Kesim Ã§izgileri gÃ¶rsel olarak gÃ¶sterilir
6. Kesimi onaylar (E tuÅŸu) veya iptal eder (ESC)
7. Kesim yapÄ±lÄ±r, variant mesh oluÅŸturulur
8. Ä°stenirse ÅŸekli kaydeder (K tuÅŸu)
9. KaydedilmiÅŸ ÅŸekli diÄŸer bloklara uygular (saÄŸ tÄ±k)

---

### 1.5.2 Aletler ve Malzemeler

**Alet Tipleri:**

#### 1. **Odun Kesici (Wood Chisel)**
- **Malzeme:** Odun (wood)
- **Item ID:** `WOOD_CHISEL`
- **GÃ¶rÃ¼nÃ¼m:** Marangoz keskisi benzeri
- **KullanÄ±m:** Sadece odun bloklarÄ±nÄ± keser

#### 2. **TaÅŸ Kesici (Stone Chisel)**
- **Malzeme:** TaÅŸ (stone, cobblestone, deep_stone)
- **Item ID:** `STONE_CHISEL`
- **GÃ¶rÃ¼nÃ¼m:** TaÅŸ keskisi benzeri
- **KullanÄ±m:** Sadece taÅŸ bloklarÄ±nÄ± keser

#### 3. **Metal Kesici (Metal Chisel)**
- **Malzeme:** Metal (iron, gold, copper, titanium)
- **Item ID:** `METAL_CHISEL`
- **GÃ¶rÃ¼nÃ¼m:** Metal keskisi benzeri
- **KullanÄ±m:** Sadece metal bloklarÄ±nÄ± keser

**Alet Seviyeleri:**
- **Temel (Basic)**: Basit kesimler, dÃ¼ÅŸÃ¼k hassasiyet
- **GeliÅŸmiÅŸ (Advanced)**: Daha hassas kesimler, daha fazla variant
- **Usta (Master)**: TÃ¼m variant'lar, maksimum hassasiyet

---

### 1.5.3 ChiselDefinition.cs (ScriptableObject)

**Dosya:** `_Stratocraft/Scripts/Data/ScriptableObjects/ChiselDefinition.cs`

**AmaÃ§:** Chisel aletlerinin Ã¶zelliklerini tanÄ±mlayan ScriptableObject

**Kod:**

```csharp
using UnityEngine;

[CreateAssetMenu(fileName = "ChiselDefinition", menuName = "Stratocraft/Chisel Definition")]
[System.Serializable]
public class ChiselDefinition : ScriptableObject {
    [Header("Kimlik")]
    public string chiselId;
    public string chiselName;
    
    [Header("Malzeme UyumluluÄŸu")]
    public MaterialType[] supportedMaterials; // Hangi malzemeleri kesebilir
    
    [Header("GÃ¶rsel")]
    public Sprite icon;
    public GameObject toolModel; // 3D model
    
    [Header("Kesim Ã–zellikleri")]
    [Tooltip("Kesim hassasiyeti (0.1 = 1/10 blok)")]
    [Range(0.01f, 0.2f)]
    public float precision = 0.1f;
    
    [Tooltip("DayanÄ±klÄ±lÄ±k (kullanÄ±m sayÄ±sÄ±)")]
    [Range(1, 1000)]
    public int durability = 100;
    
    [Tooltip("Kesim hÄ±zÄ± (saniye)")]
    [Range(0.1f, 5f)]
    public float cuttingSpeed = 1.0f;
}
```

---

### 1.5.4 ItemDefinition.cs GÃ¼ncellemesi

**Dosya:** `_Stratocraft/Scripts/Data/ScriptableObjects/ItemDefinition.cs`

**Eklenecek Kod:**

```csharp
// ItemDefinition.cs'e eklenecek (mevcut kodun sonuna)

[Header("Chisel Ã–zellikleri (Kesici Aletler Ä°Ã§in)")]
[Tooltip("Bu eÅŸya bir chisel (kesici alet) mi?")]
public bool isChisel = false;

[Tooltip("Chisel tanÄ±mÄ± (kesim Ã¶zellikleri)")]
public ChiselDefinition chiselDefinition;

[Tooltip("Chisel seviyesi (Basic, Advanced, Master)")]
public ChiselLevel chiselLevel = ChiselLevel.Basic;

/// <summary>
/// âœ… Chisel seviyesi enum
/// </summary>
public enum ChiselLevel {
    Basic,      // Temel - DÃ¼ÅŸÃ¼k hassasiyet, sÄ±nÄ±rlÄ± variant'lar
    Advanced,   // GeliÅŸmiÅŸ - Orta hassasiyet, daha fazla variant
    Master      // Usta - Maksimum hassasiyet, tÃ¼m variant'lar
}

/// <summary>
/// âœ… Chisel mi kontrol et
/// </summary>
public bool IsChisel() {
    return isChisel && chiselDefinition != null;
}
```

---

### 1.5.5 Kesim ModlarÄ±

**3 FarklÄ± Kesim Modu:**

#### 1. **KÃ¼p KesiÅŸ Modu (Cube Cut Mode)**
- **AÃ§Ä±klama:** Dik aÃ§Ä±lÄ±, dÃ¼zgÃ¼n kesimler. Minecraft'taki gibi.
- **Variant'lar:**
  - YarÄ± blok (1/2)
  - Ã‡eyrek blok (1/4)
  - 1/5, 2/5, 3/5, 4/5 bloklar
  - Ä°ki yÃ¶n kombinasyonlarÄ±
  - ÃœÃ§ yÃ¶n kombinasyonlarÄ±
- **KullanÄ±m:** Blok Ã¼zerinde iki nokta seÃ§ilir, seÃ§ilen noktalar arasÄ±ndaki alan kÃ¼p ÅŸeklinde kesilir

#### 2. **Yuvarlayarak KesiÅŸ Modu (Rounded Cut Mode)**
- **AÃ§Ä±klama:** YuvarlatÄ±lmÄ±ÅŸ kÃ¶ÅŸeler ve eÄŸriler.
- **Variant'lar:**
  - YuvarlatÄ±lmÄ±ÅŸ kÃ¶ÅŸeler (5 seviye)
  - YuvarlatÄ±lmÄ±ÅŸ kenarlar (5 seviye)
  - EÄŸrisel kesimler
  - Bezier curve kesimler
- **KullanÄ±m:** Ä°ki nokta seÃ§ilir, aralarÄ±ndaki kesim yuvarlatÄ±lmÄ±ÅŸ olur

#### 3. **Ã‡apraz KesiÅŸ Modu (Diagonal Cut Mode)**
- **AÃ§Ä±klama:** Ã‡apraz, eÄŸik kesimler. Ramp ve merdiven benzeri.
- **Variant'lar:**
  - Ã‡apraz kenar kesimler (12 kenar Ã— 5 seviye)
  - Ã‡apraz kÃ¶ÅŸe kesimler (8 kÃ¶ÅŸe Ã— 5 seviye)
  - Ramp ÅŸekilleri (6 yÃ¶n Ã— 5 seviye)
  - Merdiven benzeri ÅŸekiller
- **KullanÄ±m:** Ä°ki nokta seÃ§ilir, aralarÄ±ndaki kesim Ã§apraz/eÄŸik olur

**Mod DeÄŸiÅŸtirme:**
- **Q TuÅŸu:** Mod deÄŸiÅŸtir (KÃ¼p â†’ Yuvarlak â†’ Ã‡apraz â†’ KÃ¼p)
- **UI GÃ¶stergesi:** EkranÄ±n Ã¼stÃ¼nde aktif mod gÃ¶sterilir

---

### 1.5.6 Enum'lar ve Data YapÄ±larÄ±

**Dosya:** `_Stratocraft/Scripts/Systems/Building/CutMode.cs`

**Kod:**

```csharp
/// <summary>
/// âœ… Kesim modu
/// </summary>
public enum CutMode {
    Cube,      // KÃ¼p kesiÅŸ
    Rounded,   // Yuvarlayarak kesiÅŸ
    Diagonal   // Ã‡apraz kesiÅŸ
}

/// <summary>
/// âœ… Malzeme tipi
/// </summary>
public enum MaterialType {
    Wood,
    Stone,
    Metal
}

/// <summary>
/// âœ… Kesim parametreleri
/// </summary>
[System.Serializable]
public class CutParameters {
    public CutMode mode;
    public Vector3 startPoint;      // Local koordinat
    public Vector3 endPoint;        // Local koordinat
    public Vector3 cutDirection;    // Kesim yÃ¶nÃ¼
    public float cutRatio;          // Kesim oranÄ± (0-1)
    public int roundnessLevel;      // Yuvarlatma seviyesi (1-5)
    public float slopeAngle;        // EÄŸim aÃ§Ä±sÄ± (Ã§apraz mod iÃ§in)
    public string[] affectedFaces;  // Etkilenen yÃ¼zler
}
```

---

### 1.5.7 ChiselRaycast.cs - Raycast Sistemi (Voxel Terrain Entegrasyonu)

**Dosya:** `_Stratocraft/Scripts/Systems/Building/ChiselRaycast.cs`

**AmaÃ§:** Chisel iÃ§in voxel terrain uyumlu raycast sistemi

**Kod:**

```csharp
using UnityEngine;

/// <summary>
/// âœ… Chisel iÃ§in raycast sistemi - Voxel terrain uyumlu
/// </summary>
public class ChiselRaycast : MonoBehaviour {
    private Camera _playerCamera;
    private float _maxDistance = 5f;
    private LayerMask _blockLayer;
    private ChunkManager _chunkManager;
    private GridPlacementSystem _gridSystem;
    
    // âœ… OPTÄ°MÄ°ZE: Raycast cache
    private RaycastHit _lastHit;
    private float _lastRaycastTime = 0f;
    private const float RAYCAST_CACHE_DURATION = 0.05f; // 50ms cache
    
    void Start() {
        _playerCamera = Camera.main;
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        _gridSystem = ServiceLocator.Instance?.Get<GridPlacementSystem>();
        _blockLayer = LayerMask.GetMask("Default", "Terrain"); // Voxel terrain layer'Ä±
    }
    
    /// <summary>
    /// âœ… Blok Ã¼zerinde nokta seÃ§ (voxel terrain uyumlu)
    /// </summary>
    public bool SelectPointOnBlock(out Vector3 point, out Vector3 normal, out string blockType, out Vector3 blockWorldPos) {
        // âœ… Cache kontrolÃ¼
        if (Time.time - _lastRaycastTime < RAYCAST_CACHE_DURATION && _lastHit.collider != null) {
            point = CalculatePrecisePoint(_lastHit);
            normal = _lastHit.normal;
            blockType = GetBlockTypeFromHit(_lastHit);
            blockWorldPos = GetBlockWorldPosition(_lastHit.point);
            return true;
        }
        
        Ray ray = _playerCamera.ScreenPointToRay(Input.mousePosition);
        RaycastHit hit;
        
        // âœ… Voxel terrain iÃ§in raycast (chunk mesh'lerine)
        if (Physics.Raycast(ray, out hit, _maxDistance, _blockLayer)) {
            // âœ… Chunk kontrolÃ¼
            if (_chunkManager == null) {
                point = Vector3.zero;
                normal = Vector3.zero;
                blockType = "";
                blockWorldPos = Vector3.zero;
                return false;
            }
            
            Vector3Int chunkCoord = _chunkManager.GetChunkCoord(hit.point);
            GameObject chunk = _chunkManager.GetChunk(chunkCoord);
            
            if (chunk == null) {
                point = Vector3.zero;
                normal = Vector3.zero;
                blockType = "";
                blockWorldPos = Vector3.zero;
                return false;
            }
            
            // âœ… Blok yÃ¼zeyinde kesin nokta hesapla
            point = CalculatePrecisePoint(hit);
            normal = hit.normal;
            
            // âœ… Blok tipini al (ChunkManager'dan)
            blockType = _chunkManager.GetBlockType(hit.point) ?? "";
            
            // âœ… Blok world pozisyonunu hesapla (grid'e yapÄ±ÅŸtÄ±rÄ±lmÄ±ÅŸ)
            blockWorldPos = GetBlockWorldPosition(hit.point);
            
            // âœ… Cache'e kaydet
            _lastHit = hit;
            _lastRaycastTime = Time.time;
            
            return true;
        }
        
        point = Vector3.zero;
        normal = Vector3.zero;
        blockType = "";
        blockWorldPos = Vector3.zero;
        return false;
    }
    
    /// <summary>
    /// âœ… Blok yÃ¼zeyinde hassas nokta hesapla (grid'e yapÄ±ÅŸtÄ±r)
    /// Voxel terrain iÃ§in: hit.point'i kullan, transform yok
    /// </summary>
    Vector3 CalculatePrecisePoint(RaycastHit hit) {
        if (_gridSystem == null) {
            return hit.point; // Grid sistemi yoksa direkt noktayÄ± dÃ¶ndÃ¼r
        }
        
        // âœ… Grid'e yapÄ±ÅŸtÄ±r (alet hassasiyetine gÃ¶re)
        float gridSize = 0.1f; // VarsayÄ±lan hassasiyet (alet seviyesine gÃ¶re deÄŸiÅŸebilir)
        Vector3 snappedPoint = _gridSystem.SnapToGrid(hit.point);
        
        // âœ… Blok local koordinatlarÄ±na Ã§evir (0-1 arasÄ±)
        Vector3 blockWorldPos = GetBlockWorldPosition(hit.point);
        Vector3 localPoint = hit.point - blockWorldPos;
        
        // âœ… Grid'e yapÄ±ÅŸtÄ±r
        localPoint.x = Mathf.Round(localPoint.x / gridSize) * gridSize;
        localPoint.y = Mathf.Round(localPoint.y / gridSize) * gridSize;
        localPoint.z = Mathf.Round(localPoint.z / gridSize) * gridSize;
        
        // âœ… Blok sÄ±nÄ±rlarÄ± iÃ§inde tut (0-1 arasÄ±)
        localPoint.x = Mathf.Clamp(localPoint.x, 0f, 1f);
        localPoint.y = Mathf.Clamp(localPoint.y, 0f, 1f);
        localPoint.z = Mathf.Clamp(localPoint.z, 0f, 1f);
        
        // âœ… World pozisyonuna geri Ã§evir
        return blockWorldPos + localPoint;
    }
    
    /// <summary>
    /// âœ… Blok world pozisyonunu al (grid'e yapÄ±ÅŸtÄ±rÄ±lmÄ±ÅŸ)
    /// </summary>
    Vector3 GetBlockWorldPosition(Vector3 hitPoint) {
        if (_gridSystem != null) {
            return _gridSystem.SnapToGrid(hitPoint);
        }
        
        // Grid sistemi yoksa, blok merkezini hesapla
        return new Vector3(
            Mathf.Floor(hitPoint.x) + 0.5f,
            Mathf.Floor(hitPoint.y) + 0.5f,
            Mathf.Floor(hitPoint.z) + 0.5f
        );
    }
    
    /// <summary>
    /// âœ… Hit'ten blok tipini al
    /// </summary>
    string GetBlockTypeFromHit(RaycastHit hit) {
        if (_chunkManager == null) return "";
        return _chunkManager.GetBlockType(hit.point) ?? "";
    }
}
```

---

### 1.5.8 ChiselTool.cs - Ana Alet Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Building/ChiselTool.cs`

**AmaÃ§:** Blok ÅŸekillendirme aleti - NetworkMining entegrasyonu ile

**Kod:**

```csharp
using UnityEngine;
using FishNet.Object;

/// <summary>
/// âœ… IEquippable interface (NetworkMining entegrasyonu iÃ§in)
/// </summary>
public interface IEquippable {
    void OnEquip();
    void OnUnequip();
    bool CanUse();
}

/// <summary>
/// âœ… ChiselTool - NetworkMining entegrasyonu
/// </summary>
public class ChiselTool : NetworkBehaviour, IEquippable {
    [Header("Alet AyarlarÄ±")]
    public ChiselDefinition chiselDefinition;
    public CutMode currentMode = CutMode.Cube;
    
    [Header("SeÃ§im Sistemi")]
    public ChiselRaycast raycastSystem;
    public BlockSelectionVisualizer visualizer;
    
    [Header("Kesim Sistemi")]
    public BlockCuttingSystem cuttingSystem;
    
    [Header("KayÄ±t Sistemi")]
    public ShapeApplicationSystem shapeSystem;
    
    // SeÃ§im durumu
    private Vector3? _startPoint = null;
    private Vector3? _endPoint = null;
    private Vector3 _currentBlockPos = Vector3.zero;
    private string _currentBlockType = "";
    private bool _isEquipped = false;
    
    // âœ… NetworkMining entegrasyonu
    private NetworkMining _networkMining;
    private ItemDefinition _itemDefinition;
    
    void Start() {
        // âœ… NetworkMining'i al (eÄŸer varsa)
        _networkMining = GetComponent<NetworkMining>();
        
        // âœ… ItemDefinition'Ä± al (eÄŸer varsa)
        // TODO: PlayerInventory'den aktif item'Ä± al
    }
    
    void Update() {
        if (!IsOwner) return;
        if (!_isEquipped) return;
        
        // Mod deÄŸiÅŸtirme
        if (Input.GetKeyDown(KeyCode.Q)) {
            CycleMode();
        }
        
        // Nokta seÃ§imi
        if (Input.GetMouseButtonDown(0)) {
            SelectPoint();
        }
        
        // Kesim onayÄ±
        if (Input.GetKeyDown(KeyCode.E)) {
            ConfirmCut();
        }
        
        // Ä°ptal
        if (Input.GetKeyDown(KeyCode.Escape)) {
            CancelSelection();
        }
        
        // Åekil kaydetme
        if (Input.GetKeyDown(KeyCode.K)) {
            SaveCurrentShape();
        }
        
        // Åekil uygulama
        if (Input.GetMouseButtonDown(1)) {
            ApplySavedShape();
        }
        
        // GÃ¶rsel gÃ¼ncelleme
        UpdateVisuals();
    }
    
    // ========== IEQUIPPABLE INTERFACE ==========
    
    /// <summary>
    /// âœ… Alet kuÅŸanÄ±ldÄ±ÄŸÄ±nda
    /// </summary>
    public void OnEquip() {
        _isEquipped = true;
        
        // âœ… ChiselDefinition'Ä± ItemDefinition'dan al
        if (_itemDefinition != null && _itemDefinition.isChisel) {
            chiselDefinition = _itemDefinition.chiselDefinition;
        }
        
        // âœ… UI'Ä± gÃ¶ster
        ShowChiselUI();
    }
    
    /// <summary>
    /// âœ… Alet Ã§Ä±karÄ±ldÄ±ÄŸÄ±nda
    /// </summary>
    public void OnUnequip() {
        _isEquipped = false;
        
        // âœ… SeÃ§imi temizle
        CancelSelection();
        
        // âœ… UI'Ä± gizle
        HideChiselUI();
    }
    
    /// <summary>
    /// âœ… Alet kullanÄ±labilir mi?
    /// </summary>
    public bool CanUse() {
        if (!_isEquipped) return false;
        if (chiselDefinition == null) return false;
        if (chiselDefinition.durability <= 0) return false;
        return true;
    }
    
    /// <summary>
    /// âœ… Alet kuÅŸanÄ±lmÄ±ÅŸ mÄ±?
    /// </summary>
    public bool IsEquipped() {
        return _isEquipped;
    }
    
    /// <summary>
    /// âœ… Mod deÄŸiÅŸtir
    /// </summary>
    void CycleMode() {
        currentMode = (CutMode)(((int)currentMode + 1) % 3);
        CancelSelection(); // SeÃ§imi sÄ±fÄ±rla
    }
    
    /// <summary>
    /// âœ… Nokta seÃ§
    /// </summary>
    void SelectPoint() {
        Vector3 point;
        Vector3 normal;
        string blockType;
        Vector3 blockWorldPos;
        
        if (raycastSystem.SelectPointOnBlock(out point, out normal, out blockType, out blockWorldPos)) {
            // âœ… Alet uyumluluÄŸu kontrolÃ¼
            if (!IsMaterialCompatible(blockType)) {
                ShowErrorMessage("Bu malzeme iÃ§in uygun alet deÄŸil!");
                return;
            }
            
            if (_startPoint == null) {
                // Ä°lk nokta
                _startPoint = point;
                _currentBlockPos = blockWorldPos;
                _currentBlockType = blockType;
                visualizer.ShowStartPoint(point);
            } else {
                // âœ… AynÄ± blok Ã¼zerinde mi kontrol et
                if (blockWorldPos != _currentBlockPos) {
                    ShowErrorMessage("Ä°ki nokta aynÄ± blok Ã¼zerinde olmalÄ±!");
                    return;
                }
                
                // Ä°kinci nokta
                _endPoint = point;
                visualizer.ShowEndPoint(point);
                visualizer.ShowCutLine(_startPoint.Value, _endPoint.Value, currentMode);
                
                // âœ… Ã–nizleme mesh'ini gÃ¶ster
                ShowPreviewMesh();
            }
        }
    }
    
    /// <summary>
    /// âœ… Malzeme uyumluluÄŸu kontrolÃ¼
    /// </summary>
    bool IsMaterialCompatible(string blockType) {
        if (chiselDefinition == null) return false;
        
        MaterialType material = GetMaterialType(blockType);
        return System.Array.Exists(chiselDefinition.supportedMaterials, m => m == material);
    }
    
    /// <summary>
    /// âœ… Blok tipinden malzeme tipini al
    /// </summary>
    MaterialType GetMaterialType(string blockType) {
        if (string.IsNullOrEmpty(blockType)) return MaterialType.Stone;
        
        if (blockType.Contains("wood")) return MaterialType.Wood;
        if (blockType.Contains("stone") || blockType.Contains("cobblestone") || blockType.Contains("deep_stone")) return MaterialType.Stone;
        if (blockType.Contains("iron") || blockType.Contains("gold") || blockType.Contains("copper") || blockType.Contains("titanium") || blockType.Contains("metal")) return MaterialType.Metal;
        
        return MaterialType.Stone; // Default
    }
    
    /// <summary>
    /// âœ… Ã–nizleme mesh'ini gÃ¶ster
    /// </summary>
    void ShowPreviewMesh() {
        if (_startPoint == null || _endPoint == null) return;
        
        // âœ… Kesim parametrelerini hesapla
        CutParameters parameters = cuttingSystem.CalculateCutParameters(_currentBlockPos, _startPoint.Value, _endPoint.Value, currentMode);
        
        // âœ… Variant ID oluÅŸtur
        string variantId = cuttingSystem.GenerateVariantId(_currentBlockType, parameters);
        
        // âœ… Variant mesh al
        Mesh previewMesh = cuttingSystem.GetPreviewMesh(variantId);
        if (previewMesh != null) {
            visualizer.ShowPreviewMesh(previewMesh, _currentBlockPos);
        }
    }
    
    /// <summary>
    /// âœ… Kesimi onayla
    /// </summary>
    [ServerRpc]
    void ConfirmCut() {
        if (_startPoint == null || _endPoint == null) return;
        
        // âœ… Alet dayanÄ±klÄ±lÄ±ÄŸÄ± kontrolÃ¼
        if (chiselDefinition != null && chiselDefinition.durability <= 0) {
            ShowErrorMessage("Alet Ã§ok yÄ±pranmÄ±ÅŸ!");
            return;
        }
        
        // âœ… Kesim yap
        cuttingSystem.CutBlock(_currentBlockPos, _startPoint.Value, _endPoint.Value, currentMode, chiselDefinition);
        
        // âœ… Alet dayanÄ±klÄ±lÄ±ÄŸÄ±nÄ± azalt
        if (chiselDefinition != null) {
            chiselDefinition.durability--;
        }
        
        // SeÃ§imi temizle
        CancelSelection();
    }
    
    /// <summary>
    /// âœ… SeÃ§imi iptal et
    /// </summary>
    void CancelSelection() {
        _startPoint = null;
        _endPoint = null;
        visualizer.ClearSelection();
    }
    
    /// <summary>
    /// âœ… Åekil kaydet
    /// </summary>
    void SaveCurrentShape() {
        if (_startPoint == null || _endPoint == null) {
            ShowErrorMessage("Ã–nce bir kesim seÃ§in!");
            return;
        }
        
        // Slot seÃ§imi (1-9 tuÅŸlarÄ±)
        int slot = GetSelectedSlot();
        if (slot < 0) {
            ShowErrorMessage("Slot seÃ§in (1-9)!");
            return;
        }
        
        CutParameters parameters = cuttingSystem.CalculateCutParameters(_currentBlockPos, _startPoint.Value, _endPoint.Value, currentMode);
        shapeSystem.SaveShape(slot, _currentBlockPos, parameters);
    }
    
    /// <summary>
    /// âœ… KaydedilmiÅŸ ÅŸekli uygula
    /// </summary>
    void ApplySavedShape() {
        int slot = GetSelectedSlot();
        if (slot < 0) {
            ShowErrorMessage("Slot seÃ§in (1-9)!");
            return;
        }
        
        Vector3 point;
        Vector3 normal;
        string blockType;
        Vector3 blockWorldPos;
        
        if (raycastSystem.SelectPointOnBlock(out point, out normal, out blockType, out blockWorldPos)) {
            shapeSystem.ApplySavedShape(slot, blockWorldPos);
        }
    }
    
    /// <summary>
    /// âœ… SeÃ§ili slot'u al (1-9 tuÅŸlarÄ±)
    /// </summary>
    int GetSelectedSlot() {
        for (int i = 1; i <= 9; i++) {
            if (Input.GetKeyDown(KeyCode.Alpha0 + i)) {
                return i - 1;
            }
        }
        return -1; // Slot seÃ§ilmedi
    }
    
    /// <summary>
    /// âœ… Hata mesajÄ± gÃ¶ster
    /// </summary>
    void ShowErrorMessage(string message) {
        // TODO: UI'da hata mesajÄ± gÃ¶ster
        Debug.LogWarning($"[ChiselTool] {message}");
    }
    
    /// <summary>
    /// âœ… Chisel UI'Ä± gÃ¶ster
    /// </summary>
    void ShowChiselUI() {
        // TODO: UI gÃ¶ster
    }
    
    /// <summary>
    /// âœ… Chisel UI'Ä± gizle
    /// </summary>
    void HideChiselUI() {
        // TODO: UI gizle
    }
    
    /// <summary>
    /// âœ… GÃ¶rsel gÃ¼ncelleme
    /// </summary>
    void UpdateVisuals() {
        if (!_isEquipped) return;
        
        // âœ… Mouse Ã¼zerine gelince grid Ã§izgilerini gÃ¶ster
        Vector3 point;
        Vector3 normal;
        string blockType;
        Vector3 blockWorldPos;
        
        if (raycastSystem.SelectPointOnBlock(out point, out normal, out blockType, out blockWorldPos)) {
            // Grid Ã§izgilerini gÃ¶ster
            visualizer.ShowGridLines(blockWorldPos, chiselDefinition?.precision ?? 0.1f);
        }
    }
}
```

---

### 1.5.9 BlockSelectionVisualizer.cs - GÃ¶rselleÅŸtirme

**Dosya:** `_Stratocraft/Scripts/Systems/Building/BlockSelectionVisualizer.cs`

**AmaÃ§:** Blok seÃ§im gÃ¶rselleÅŸtirme sistemi

**Kod:**

```csharp
using UnityEngine;

/// <summary>
/// âœ… Blok seÃ§im gÃ¶rselleÅŸtirme sistemi
/// </summary>
public class BlockSelectionVisualizer : MonoBehaviour {
    [Header("Marker'lar")]
    public GameObject startPointMarkerPrefab;
    public GameObject endPointMarkerPrefab;
    
    [Header("Ã‡izgiler")]
    public LineRenderer cutLineRenderer;
    public LineRenderer[] gridLineRenderers;
    
    [Header("Ã–nizleme")]
    public MeshRenderer previewMeshRenderer;
    public Material previewMaterial;
    
    private GameObject _startMarker;
    private GameObject _endMarker;
    private MeshFilter _previewMeshFilter;
    
    void Start() {
        // Marker'larÄ± oluÅŸtur
        _startMarker = Instantiate(startPointMarkerPrefab);
        _startMarker.SetActive(false);
        
        _endMarker = Instantiate(endPointMarkerPrefab);
        _endMarker.SetActive(false);
        
        // Ã–nizleme mesh'i hazÄ±rla
        _previewMeshFilter = previewMeshRenderer.GetComponent<MeshFilter>();
        if (_previewMeshFilter == null) {
            _previewMeshFilter = previewMeshRenderer.gameObject.AddComponent<MeshFilter>();
        }
    }
    
    /// <summary>
    /// âœ… BaÅŸlangÄ±Ã§ noktasÄ±nÄ± gÃ¶ster
    /// </summary>
    public void ShowStartPoint(Vector3 point) {
        _startMarker.transform.position = point;
        _startMarker.SetActive(true);
    }
    
    /// <summary>
    /// âœ… BitiÅŸ noktasÄ±nÄ± gÃ¶ster
    /// </summary>
    public void ShowEndPoint(Vector3 point) {
        _endMarker.transform.position = point;
        _endMarker.SetActive(true);
    }
    
    /// <summary>
    /// âœ… Kesim Ã§izgisini gÃ¶ster
    /// </summary>
    public void ShowCutLine(Vector3 start, Vector3 end, CutMode mode) {
        cutLineRenderer.positionCount = 2;
        cutLineRenderer.SetPosition(0, start);
        cutLineRenderer.SetPosition(1, end);
        
        // Moda gÃ¶re renk
        switch (mode) {
            case CutMode.Cube:
                cutLineRenderer.color = Color.blue;
                break;
            case CutMode.Rounded:
                cutLineRenderer.color = Color.green;
                break;
            case CutMode.Diagonal:
                cutLineRenderer.color = Color.red;
                break;
        }
        
        cutLineRenderer.enabled = true;
    }
    
    /// <summary>
    /// âœ… Ã–nizleme mesh'ini gÃ¶ster
    /// </summary>
    public void ShowPreviewMesh(Mesh mesh, Vector3 position) {
        _previewMeshFilter.mesh = mesh;
        previewMeshRenderer.transform.position = position;
        previewMeshRenderer.enabled = true;
    }
    
    /// <summary>
    /// âœ… Grid Ã§izgilerini gÃ¶ster
    /// </summary>
    public void ShowGridLines(Vector3 blockWorldPos, float gridSize) {
        // TODO: Grid Ã§izgilerini hesapla ve gÃ¶ster
        // LineRenderer veya Gizmos ile yapÄ±labilir
    }
    
    /// <summary>
    /// âœ… SeÃ§imi temizle
    /// </summary>
    public void ClearSelection() {
        _startMarker.SetActive(false);
        _endMarker.SetActive(false);
        cutLineRenderer.enabled = false;
        previewMeshRenderer.enabled = false;
    }
}
```

---

### 1.5.10 BlockCuttingSystem.cs - Kesim Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Building/BlockCuttingSystem.cs`

**AmaÃ§:** Blok kesim sistemi - VariantMeshGenerator entegrasyonu ile

**Kod:**

```csharp
using UnityEngine;
using FishNet.Object;
using System.Collections;
using System.Collections.Generic;

/// <summary>
/// âœ… Blok kesim sistemi
/// </summary>
public class BlockCuttingSystem : NetworkBehaviour {
    private VariantMeshGenerator _variantGenerator;
    private ChunkManager _chunkManager;
    private GridPlacementSystem _gridSystem;
    
    void Start() {
        _variantGenerator = ServiceLocator.Instance?.Get<VariantMeshGenerator>();
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        _gridSystem = ServiceLocator.Instance?.Get<GridPlacementSystem>();
    }
    
    /// <summary>
    /// âœ… Blok kes ve variant mesh oluÅŸtur
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void CutBlock(Vector3 blockPos, Vector3 startPoint, Vector3 endPoint, CutMode mode, ChiselDefinition chisel) {
        // 1. Blok tipini kontrol et
        string blockType = _chunkManager.GetBlockType(blockPos);
        if (string.IsNullOrEmpty(blockType)) {
            Debug.LogWarning($"[BlockCuttingSystem] Blok bulunamadÄ±: {blockPos}");
            return;
        }
        
        // 2. Alet uyumluluÄŸu kontrolÃ¼
        if (chisel != null) {
            MaterialType material = GetMaterialType(blockType);
            if (!System.Array.Exists(chisel.supportedMaterials, m => m == material)) {
                Debug.LogWarning($"[BlockCuttingSystem] Alet bu malzeme iÃ§in uygun deÄŸil: {blockType}");
                return;
            }
        }
        
        // 3. Eski variant ID'yi kaydet (undo iÃ§in)
        string oldVariantId = blockType;
        
        // 4. Kesim parametrelerini hesapla
        CutParameters parameters = CalculateCutParameters(blockPos, startPoint, endPoint, mode);
        
        // 5. Variant ID oluÅŸtur (VariantMeshGenerator ile uyumlu format)
        string variantId = GenerateVariantId(blockType, parameters);
        
        // 6. Variant mesh al veya oluÅŸtur
        Mesh variantMesh = _variantGenerator.GetVariantMesh(variantId);
        if (variantMesh == null) {
            Debug.LogWarning($"[BlockCuttingSystem] Variant mesh oluÅŸturulamadÄ±: {variantId}");
            return;
        }
        
        // 7. Blok tipini gÃ¼ncelle
        _chunkManager.SetBlockType(blockPos, variantId);
        
        // 8. Chunk'Ä± yeniden generate et (coroutine)
        Vector3Int chunkCoord = _chunkManager.GetChunkCoord(blockPos);
        StartCoroutine(RegenerateChunkCoroutine(chunkCoord));
        
        // 9. Kesim geÃ§miÅŸine ekle (undo iÃ§in)
        AddToCutHistory(blockPos, oldVariantId, variantId, parameters);
        
        // 10. Client'lara senkronize et
        RpcUpdateBlock(blockPos, variantId);
    }
    
    /// <summary>
    /// âœ… Chunk regeneration coroutine wrapper
    /// </summary>
    IEnumerator RegenerateChunkCoroutine(Vector3Int chunkCoord) {
        yield return StartCoroutine(_chunkManager.RegenerateChunk(chunkCoord));
    }
    
    /// <summary>
    /// âœ… Kesim parametrelerini hesapla (public - ChiselTool'dan Ã§aÄŸrÄ±labilir)
    /// </summary>
    public CutParameters CalculateCutParameters(Vector3 blockPos, Vector3 start, Vector3 end, CutMode mode) {
        CutParameters param = new CutParameters {
            mode = mode
        };
        
        // Blok local koordinatlarÄ±na Ã§evir
        Vector3 blockWorldPos = _gridSystem != null ? _gridSystem.SnapToGrid(blockPos) : GetBlockWorldPosition(blockPos);
        Vector3 localStart = WorldToLocal(start, blockWorldPos);
        Vector3 localEnd = WorldToLocal(end, blockWorldPos);
        
        // Moda gÃ¶re parametreleri hesapla
        switch (mode) {
            case CutMode.Cube:
                param = CalculateCubeCut(localStart, localEnd);
                break;
            case CutMode.Rounded:
                param = CalculateRoundedCut(localStart, localEnd);
                break;
            case CutMode.Diagonal:
                param = CalculateDiagonalCut(localStart, localEnd);
                break;
        }
        
        return param;
    }
    
    /// <summary>
    /// âœ… Variant ID oluÅŸtur (VariantMeshGenerator ile uyumlu format)
    /// </summary>
    public string GenerateVariantId(string baseMaterial, CutParameters parameters) {
        string materialId = ExtractMaterialId(baseMaterial);
        string variantId = "";
        
        // Moda gÃ¶re variant ID oluÅŸtur
        switch (parameters.mode) {
            case CutMode.Cube:
                variantId = GenerateCubeVariantId(materialId, parameters);
                break;
            case CutMode.Rounded:
                variantId = GenerateRoundedVariantId(materialId, parameters);
                break;
            case CutMode.Diagonal:
                variantId = GenerateDiagonalVariantId(materialId, parameters);
                break;
        }
        
        return variantId;
    }
    
    /// <summary>
    /// âœ… Ã–nizleme mesh'ini al
    /// </summary>
    public Mesh GetPreviewMesh(string variantId) {
        return _variantGenerator.GetVariantMesh(variantId);
    }
    
    // ========== PRIVATE HELPER METHODS ==========
    
    Vector3 WorldToLocal(Vector3 worldPos, Vector3 blockWorldPos) {
        return worldPos - blockWorldPos;
    }
    
    Vector3 GetBlockWorldPosition(Vector3 pos) {
        if (_gridSystem != null) {
            return _gridSystem.SnapToGrid(pos);
        }
        return new Vector3(
            Mathf.Floor(pos.x) + 0.5f,
            Mathf.Floor(pos.y) + 0.5f,
            Mathf.Floor(pos.z) + 0.5f
        );
    }
    
    CutParameters CalculateCubeCut(Vector3 localStart, Vector3 localEnd) {
        CutParameters param = new CutParameters {
            mode = CutMode.Cube,
            startPoint = localStart,
            endPoint = localEnd
        };
        param.affectedFaces = GetAffectedFaces(localStart, localEnd);
        param.cutRatio = CalculateCutRatio(localStart, localEnd);
        return param;
    }
    
    CutParameters CalculateRoundedCut(Vector3 localStart, Vector3 localEnd) {
        CutParameters param = CalculateCubeCut(localStart, localEnd);
        param.mode = CutMode.Rounded;
        float distance = Vector3.Distance(localStart, localEnd);
        param.roundnessLevel = Mathf.Clamp(Mathf.RoundToInt(distance * 5f), 1, 5);
        return param;
    }
    
    CutParameters CalculateDiagonalCut(Vector3 localStart, Vector3 localEnd) {
        CutParameters param = new CutParameters {
            mode = CutMode.Diagonal,
            startPoint = localStart,
            endPoint = localEnd
        };
        Vector3 direction = (localEnd - localStart).normalized;
        param.slopeAngle = Vector3.Angle(direction, Vector3.up);
        param.cutDirection = direction;
        return param;
    }
    
    string ExtractMaterialId(string blockType) {
        if (string.IsNullOrEmpty(blockType)) return "stone";
        string[] parts = blockType.Split('_');
        if (parts.Length > 0) {
            string firstPart = parts[0].ToLower();
            if (firstPart == "wood" || firstPart == "stone" || firstPart == "iron" || firstPart == "gold" || firstPart == "copper" || firstPart == "titanium") {
                return firstPart;
            }
        }
        if (blockType.Contains("wood")) return "wood";
        if (blockType.Contains("stone") || blockType.Contains("cobblestone") || blockType.Contains("deep_stone")) return "stone";
        if (blockType.Contains("iron") || blockType.Contains("gold") || blockType.Contains("copper") || blockType.Contains("titanium") || blockType.Contains("metal")) return "iron";
        return "stone";
    }
    
    string GenerateCubeVariantId(string materialId, CutParameters parameters) {
        string[] faces = parameters.affectedFaces;
        if (faces.Length == 1) {
            return $"{materialId}_half_{faces[0]}";
        } else if (faces.Length == 2) {
            return $"{materialId}_quarter_{faces[0]}_{faces[1]}";
        } else if (faces.Length == 3) {
            return $"{materialId}_eighth_{faces[0]}_{faces[1]}_{faces[2]}";
        }
        int fifthLevel = Mathf.RoundToInt(parameters.cutRatio * 5f);
        if (fifthLevel > 0 && fifthLevel < 5) {
            return $"{materialId}_fifth_{faces[0]}_{fifthLevel}";
        }
        return $"{materialId}_half_{faces[0]}";
    }
    
    string GenerateRoundedVariantId(string materialId, CutParameters parameters) {
        string[] faces = parameters.affectedFaces;
        int roundnessLevel = parameters.roundnessLevel;
        if (faces.Length >= 3) {
            return $"{materialId}_rounded_corner_{faces[0]}_{faces[1]}_{faces[2]}_{roundnessLevel}";
        } else if (faces.Length == 2) {
            return $"{materialId}_rounded_edge_{faces[0]}_{faces[1]}_{roundnessLevel}";
        }
        return $"{materialId}_rounded_{faces[0]}_{roundnessLevel}";
    }
    
    string GenerateDiagonalVariantId(string materialId, CutParameters parameters) {
        string[] faces = parameters.affectedFaces;
        float slopeAngle = parameters.slopeAngle;
        if (slopeAngle < 45f) {
            int rampLevel = Mathf.RoundToInt(slopeAngle / 9f);
            rampLevel = Mathf.Clamp(rampLevel, 1, 5);
            return $"{materialId}_ramp_{faces[0]}_{rampLevel}";
        } else {
            int diagonalLevel = Mathf.RoundToInt((slopeAngle - 45f) / 9f);
            diagonalLevel = Mathf.Clamp(diagonalLevel, 1, 5);
            if (faces.Length >= 2) {
                return $"{materialId}_diagonal_edge_{faces[0]}_{faces[1]}_{diagonalLevel}";
            } else {
                return $"{materialId}_diagonal_{faces[0]}_{diagonalLevel}";
            }
        }
    }
    
    MaterialType GetMaterialType(string blockType) {
        if (string.IsNullOrEmpty(blockType)) return MaterialType.Stone;
        if (blockType.Contains("wood")) return MaterialType.Wood;
        if (blockType.Contains("stone") || blockType.Contains("cobblestone") || blockType.Contains("deep_stone")) return MaterialType.Stone;
        if (blockType.Contains("iron") || blockType.Contains("gold") || blockType.Contains("copper") || blockType.Contains("titanium") || blockType.Contains("metal")) return MaterialType.Metal;
        return MaterialType.Stone;
    }
    
    string[] GetAffectedFaces(Vector3 start, Vector3 end) {
        List<string> faces = new List<string>();
        if (start.y > 0.8f || end.y > 0.8f) faces.Add("top");
        if (start.y < 0.2f || end.y < 0.2f) faces.Add("bottom");
        if (start.x < 0.2f || end.x < 0.2f) faces.Add("left");
        if (start.x > 0.8f || end.x > 0.8f) faces.Add("right");
        if (start.z < 0.2f || end.z < 0.2f) faces.Add("front");
        if (start.z > 0.8f || end.z > 0.8f) faces.Add("back");
        return faces.ToArray();
    }
    
    float CalculateCutRatio(Vector3 start, Vector3 end) {
        float distance = Vector3.Distance(start, end);
        return Mathf.Clamp01(distance / 1.414f);
    }
    
    void AddToCutHistory(Vector3 blockPos, string oldVariantId, string newVariantId, CutParameters parameters) {
        // TODO: CutHistory sistemine ekle
    }
    
    [ObserversRpc]
    void RpcUpdateBlock(Vector3 blockPos, string variantId) {
        Vector3Int chunkCoord = _chunkManager.GetChunkCoord(blockPos);
        StartCoroutine(RegenerateChunkCoroutine(chunkCoord));
    }
}
```

---

### 1.5.11 ShapeApplicationSystem.cs - KayÄ±t ve Uygulama Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Building/ShapeApplicationSystem.cs`

**AmaÃ§:** KesilmiÅŸ ÅŸekilleri kaydetme ve uygulama sistemi

**Kod:**

```csharp
using UnityEngine;
using FishNet.Object;
using System.Collections;
using System.Collections.Generic;
using System.IO;

/// <summary>
/// âœ… Åekil kaydetme ve uygulama sistemi
/// </summary>
public class ShapeApplicationSystem : MonoBehaviour {
    private Dictionary<int, SavedBlockShape> _savedShapes = new Dictionary<int, SavedBlockShape>();
    private ChunkManager _chunkManager;
    private VariantMeshGenerator _variantGenerator;
    private BlockCuttingSystem _cuttingSystem;
    private int _selectedSlot = -1;
    
    void Start() {
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        _variantGenerator = ServiceLocator.Instance?.Get<VariantMeshGenerator>();
        _cuttingSystem = ServiceLocator.Instance?.Get<BlockCuttingSystem>();
        
        // âœ… KaydedilmiÅŸ ÅŸekilleri yÃ¼kle
        LoadSavedShapes();
    }
    
    void Update() {
        // âœ… Slot seÃ§imi (1-9 tuÅŸlarÄ±)
        for (int i = 1; i <= 9; i++) {
            if (Input.GetKeyDown(KeyCode.Alpha0 + i)) {
                _selectedSlot = i - 1;
                Debug.Log($"[ShapeApplicationSystem] Slot {_selectedSlot} seÃ§ildi");
            }
        }
    }
    
    /// <summary>
    /// âœ… KaydedilmiÅŸ ÅŸekli uygula (saÄŸ tÄ±k)
    /// </summary>
    [ServerRpc]
    public void ApplySavedShape(int slotIndex, Vector3 blockPos) {
        if (!_savedShapes.ContainsKey(slotIndex)) {
            Debug.LogWarning($"[ShapeApplicationSystem] Slot {slotIndex} boÅŸ!");
            return;
        }
        
        SavedBlockShape shape = _savedShapes[slotIndex];
        
        // âœ… Blok tipini kontrol et
        string blockType = _chunkManager.GetBlockType(blockPos);
        if (string.IsNullOrEmpty(blockType)) {
            Debug.LogWarning($"[ShapeApplicationSystem] Blok bulunamadÄ±: {blockPos}");
            return;
        }
        
        if (!IsCompatible(blockType, shape.baseMaterial)) {
            Debug.LogWarning($"[ShapeApplicationSystem] Uyumsuz malzeme! Blok: {blockType}, Åekil: {shape.baseMaterial}");
            return;
        }
        
        // âœ… Variant mesh'i uygula
        Mesh variantMesh = _variantGenerator.GetVariantMesh(shape.variantId);
        if (variantMesh == null) {
            Debug.LogWarning($"[ShapeApplicationSystem] Variant mesh bulunamadÄ±: {shape.variantId}");
            return;
        }
        
        // âœ… Blok tipini gÃ¼ncelle
        _chunkManager.SetBlockType(blockPos, shape.variantId);
        
        // âœ… Chunk'Ä± yeniden generate et
        Vector3Int chunkCoord = _chunkManager.GetChunkCoord(blockPos);
        StartCoroutine(RegenerateChunkCoroutine(chunkCoord));
        
        // âœ… Client'lara senkronize et
        RpcApplyShape(blockPos, shape.variantId);
    }
    
    /// <summary>
    /// âœ… Åekli kaydet (K tuÅŸu)
    /// </summary>
    public void SaveShape(int slotIndex, Vector3 blockPos, CutParameters parameters) {
        if (slotIndex < 0 || slotIndex >= 9) {
            Debug.LogWarning($"[ShapeApplicationSystem] GeÃ§ersiz slot: {slotIndex}");
            return;
        }
        
        // âœ… Base material'Ä± al
        string baseMaterial = GetMaterialFromBlock(blockPos);
        if (string.IsNullOrEmpty(baseMaterial)) {
            Debug.LogWarning($"[ShapeApplicationSystem] Malzeme bulunamadÄ±: {blockPos}");
            return;
        }
        
        // âœ… Variant ID oluÅŸtur
        string variantId = _cuttingSystem.GenerateVariantId(baseMaterial, parameters);
        
        SavedBlockShape shape = new SavedBlockShape {
            shapeId = System.Guid.NewGuid().ToString(),
            shapeName = $"Shape_{slotIndex + 1}",
            baseMaterial = baseMaterial,
            parameters = parameters,
            variantId = variantId,
            savedDate = System.DateTime.Now.ToString()
        };
        
        // âœ… Ã–nizleme mesh'i oluÅŸtur
        shape.previewMesh = _variantGenerator.GetVariantMesh(variantId);
        shape.previewIcon = GeneratePreviewIcon(shape.previewMesh);
        
        _savedShapes[slotIndex] = shape;
        
        // âœ… Dosyaya kaydet (JSON)
        SaveShapeToFile(shape);
        
        Debug.Log($"[ShapeApplicationSystem] Åekil kaydedildi: Slot {slotIndex}, ID: {variantId}");
    }
    
    // ========== PRIVATE HELPER METHODS ==========
    
    bool IsCompatible(string blockType, string shapeMaterial) {
        if (string.IsNullOrEmpty(blockType) || string.IsNullOrEmpty(shapeMaterial)) return false;
        string blockMaterial = ExtractMaterialId(blockType);
        return blockMaterial == shapeMaterial;
    }
    
    string GetMaterialFromBlock(Vector3 blockPos) {
        string blockType = _chunkManager.GetBlockType(blockPos);
        if (string.IsNullOrEmpty(blockType)) return "";
        return ExtractMaterialId(blockType);
    }
    
    string ExtractMaterialId(string blockType) {
        if (string.IsNullOrEmpty(blockType)) return "";
        string[] parts = blockType.Split('_');
        if (parts.Length > 0) {
            string firstPart = parts[0].ToLower();
            if (firstPart == "wood" || firstPart == "stone" || firstPart == "iron" || firstPart == "gold" || firstPart == "copper" || firstPart == "titanium") {
                return firstPart;
            }
        }
        if (blockType.Contains("wood")) return "wood";
        if (blockType.Contains("stone") || blockType.Contains("cobblestone") || blockType.Contains("deep_stone")) return "stone";
        if (blockType.Contains("iron") || blockType.Contains("gold") || blockType.Contains("copper") || blockType.Contains("titanium") || blockType.Contains("metal")) return "iron";
        return "stone";
    }
    
    Sprite GeneratePreviewIcon(Mesh mesh) {
        // TODO: Mesh'ten sprite oluÅŸtur (render texture kullanarak)
        return null;
    }
    
    void SaveShapeToFile(SavedBlockShape shape) {
        string path = Path.Combine(Application.persistentDataPath, "SavedShapes", $"{shape.shapeId}.json");
        Directory.CreateDirectory(Path.GetDirectoryName(path));
        string json = JsonUtility.ToJson(shape, true);
        File.WriteAllText(path, json);
    }
    
    void LoadSavedShapes() {
        string shapesDir = Path.Combine(Application.persistentDataPath, "SavedShapes");
        if (!Directory.Exists(shapesDir)) return;
        string[] files = Directory.GetFiles(shapesDir, "*.json");
        foreach (string file in files) {
            string json = File.ReadAllText(file);
            SavedBlockShape shape = JsonUtility.FromJson<SavedBlockShape>(json);
            // TODO: Slot yÃ¶netimi
        }
    }
    
    IEnumerator RegenerateChunkCoroutine(Vector3Int chunkCoord) {
        yield return StartCoroutine(_chunkManager.RegenerateChunk(chunkCoord));
    }
    
    [ObserversRpc]
    void RpcApplyShape(Vector3 blockPos, string variantId) {
        _chunkManager.SetBlockType(blockPos, variantId);
        Vector3Int chunkCoord = _chunkManager.GetChunkCoord(blockPos);
        StartCoroutine(RegenerateChunkCoroutine(chunkCoord));
    }
}

/// <summary>
/// âœ… KaydedilmiÅŸ blok ÅŸekli
/// </summary>
[System.Serializable]
public class SavedBlockShape {
    public string shapeId;
    public string shapeName;
    public string baseMaterial;
    public CutParameters parameters;
    public string variantId;
    public string previewMeshPath;
    public string previewIconPath;
    public string savedDate;
    
    [System.NonSerialized]
    public Mesh previewMesh;
    
    [System.NonSerialized]
    public Sprite previewIcon;
}
```

---

### 1.5.12 NetworkMining Entegrasyonu

**NetworkMining.cs'e Eklenecek Kod:**

```csharp
// NetworkMining.cs iÃ§ine eklenecek

[Header("Chisel Sistemi")]
private ChiselTool _chiselTool;
private bool _isChiselMode = false;

void Start() {
    // ... mevcut kod ...
    
    // âœ… ChiselTool'u al
    _chiselTool = GetComponent<ChiselTool>();
    if (_chiselTool == null) {
        _chiselTool = gameObject.AddComponent<ChiselTool>();
    }
}

void Update() {
    // ... mevcut kod ...
    
    // âœ… Chisel modu kontrolÃ¼
    if (_chiselTool != null && _chiselTool.IsEquipped()) {
        // Chisel modu aktif, normal mining'i devre dÄ±ÅŸÄ± bÄ±rak
        return;
    }
    
    // Normal mining kodu...
}

/// <summary>
/// âœ… Chisel modunu aktif et
/// </summary>
public void EnableChiselMode(ItemDefinition chiselItem) {
    if (_chiselTool == null) return;
    
    if (chiselItem != null && chiselItem.isChisel) {
        _chiselTool.chiselDefinition = chiselItem.chiselDefinition;
        _chiselTool.OnEquip();
        _isChiselMode = true;
    }
}

/// <summary>
/// âœ… Chisel modunu deaktif et
/// </summary>
public void DisableChiselMode() {
    if (_chiselTool == null) return;
    
    _chiselTool.OnUnequip();
    _isChiselMode = false;
}
```

---

### 1.5.13 Performans OptimizasyonlarÄ±

#### 1.5.13.1 Raycast Optimizasyonu

**Sorun:** Her frame raycast yapmak performans sorunu yaratÄ±r.

**Ã‡Ã¶zÃ¼m:** Raycast cache sistemi

```csharp
// âœ… OPTÄ°MÄ°ZE: Raycast cache
private Dictionary<Vector3Int, RaycastHit> _raycastCache = new Dictionary<Vector3Int, RaycastHit>();
private float _lastRaycastTime = 0f;
private const float RAYCAST_CACHE_DURATION = 0.1f; // 100ms cache

public bool SelectPointOnBlock(out Vector3 point, out Vector3 normal) {
    Vector3Int gridPos = WorldToGrid(_playerCamera.transform.position);
    
    // Cache kontrolÃ¼
    if (Time.time - _lastRaycastTime < RAYCAST_CACHE_DURATION) {
        if (_raycastCache.TryGetValue(gridPos, out RaycastHit cachedHit)) {
            point = cachedHit.point;
            normal = cachedHit.normal;
            return true;
        }
    }
    
    // Raycast yap
    Ray ray = _playerCamera.ScreenPointToRay(Input.mousePosition);
    RaycastHit hit;
    
    if (Physics.Raycast(ray, out hit, maxRaycastDistance, voxelTerrainLayer)) {
        _raycastCache[gridPos] = hit;
        _lastRaycastTime = Time.time;
        point = hit.point;
        normal = hit.normal;
        return true;
    }
    
    point = Vector3.zero;
    normal = Vector3.zero;
    return false;
}
```

#### 1.5.13.2 Mesh Pooling

**Sorun:** Her kesimde yeni mesh oluÅŸturmak GC pressure yaratÄ±r.

**Ã‡Ã¶zÃ¼m:** Mesh pooling sistemi

```csharp
// âœ… OPTÄ°MÄ°ZE: Ã–nizleme mesh pooling
private Queue<Mesh> _previewMeshPool = new Queue<Mesh>();
private const int MAX_POOL_SIZE = 10;

Mesh GetPreviewMesh() {
    if (_previewMeshPool.Count > 0) {
        return _previewMeshPool.Dequeue();
    }
    return new Mesh();
}

void ReturnPreviewMesh(Mesh mesh) {
    if (mesh == null) return;
    
    mesh.Clear();
    
    if (_previewMeshPool.Count < MAX_POOL_SIZE) {
        _previewMeshPool.Enqueue(mesh);
    } else {
        Destroy(mesh);
    }
}
```

#### 1.5.13.3 Variant Cache

**Not:** VariantMeshGenerator zaten cache kullanÄ±yor, sadece kesim parametrelerini cache'le.

```csharp
// âœ… OPTÄ°MÄ°ZE: Kesim parametreleri cache
private Dictionary<string, CutParameters> _cutParametersCache = new Dictionary<string, CutParameters>();

CutParameters GetCachedCutParameters(string variantId) {
    if (_cutParametersCache.TryGetValue(variantId, out CutParameters cached)) {
        return cached;
    }
    
    // Yeni parametre oluÅŸtur ve cache'le
    CutParameters parameters = GenerateCutParameters(variantId);
    _cutParametersCache[variantId] = parameters;
    return parameters;
}
```

#### 1.5.13.4 Chunk Regeneration Batch Optimizasyonu

**Sorun:** Her kesimde chunk regeneration yapmak performans sorunu yaratÄ±r.

**Ã‡Ã¶zÃ¼m:** Batch regeneration sistemi

```csharp
// âœ… OPTÄ°MÄ°ZE: Chunk regeneration batch
private List<Vector3Int> _pendingChunkRegenerations = new List<Vector3Int>();
private float _lastRegenerationTime = 0f;
private const float REGENERATION_BATCH_INTERVAL = 0.5f; // 500ms batch

void QueueChunkRegeneration(Vector3Int chunkCoord) {
    if (!_pendingChunkRegenerations.Contains(chunkCoord)) {
        _pendingChunkRegenerations.Add(chunkCoord);
    }
}

void Update() {
    // Batch regeneration kontrolÃ¼
    if (Time.time - _lastRegenerationTime > REGENERATION_BATCH_INTERVAL) {
        if (_pendingChunkRegenerations.Count > 0) {
            // TÃ¼m bekleyen chunk'larÄ± regenerate et
            foreach (var chunk in _pendingChunkRegenerations) {
                StartCoroutine(_chunkManager.RegenerateChunk(chunk));
            }
            _pendingChunkRegenerations.Clear();
            _lastRegenerationTime = Time.time;
        }
    }
}
```

---

### 1.5.14 Ek Ã–zellikler ve GeliÅŸtirmeler

#### 1.5.14.1 Alet Seviyeleri ve Ä°yileÅŸtirmeleri

**Temel Alet (Basic Chisel)**
- Basit kesimler
- DÃ¼ÅŸÃ¼k hassasiyet (0.2 birim)
- SÄ±nÄ±rlÄ± variant'lar

**GeliÅŸmiÅŸ Alet (Advanced Chisel)**
- Daha hassas kesimler (0.1 birim)
- Daha fazla variant
- Ã–zel kesim modlarÄ±

**Usta Alet (Master Chisel)**
- Maksimum hassasiyet (0.05 birim)
- TÃ¼m variant'lar
- Ã–zel efektler (parÄ±ltÄ±, ses)

#### 1.5.14.2 Kesim Efektleri

**GÃ¶rsel Efektler:**
- Kesim sÄ±rasÄ±nda parÃ§acÄ±k efektleri
- Toz bulutlarÄ± (taÅŸ iÃ§in)
- TalaÅŸ parÃ§acÄ±klarÄ± (odun iÃ§in)
- KÄ±vÄ±lcÄ±m (metal iÃ§in)

**Ses Efektleri:**
- Kesim sesleri (malzemeye gÃ¶re)
- BaÅŸarÄ±lÄ± kesim sesi
- Hata sesi (uyumsuz malzeme)

#### 1.5.14.3 Ã‡oklu Blok Kesimi

**SeÃ§im Modu:**
- **Tek Blok:** Normal mod
- **Ã‡oklu Blok:** Shift + Sol TÄ±k ile seÃ§im
- **BÃ¶lge SeÃ§imi:** Ctrl + Drag ile bÃ¶lge seÃ§

**Toplu Kesim:**
- SeÃ§ilen tÃ¼m bloklara aynÄ± kesimi uygula
- Ä°lerleme Ã§ubuÄŸu gÃ¶ster
- Ä°ptal edilebilir

#### 1.5.14.4 Kesim GeÃ§miÅŸi (Undo/Redo)

**GeÃ§miÅŸ Sistemi:**
- Son 10 kesimi kaydet
- **Ctrl + Z:** Geri al
- **Ctrl + Y:** Ä°leri al

**GeÃ§miÅŸ FormatÄ±:**
```csharp
[System.Serializable]
public class CutHistory {
    public List<CutAction> actions = new List<CutAction>();
    public int currentIndex = -1;
}

[System.Serializable]
public class CutAction {
    public Vector3 blockPos;
    public string oldVariantId;
    public string newVariantId;
    public CutParameters parameters;
}
```

#### 1.5.14.5 Kesim Validasyonu

**Kontrol Sistemi:**
- Kesim mÃ¼mkÃ¼n mÃ¼?
- Malzeme uyumlu mu?
- Alet yeterli mi?
- DayanÄ±klÄ±lÄ±k yeterli mi?

**Hata MesajlarÄ±:**
- "Bu malzeme iÃ§in uygun alet deÄŸil!"
- "Alet Ã§ok yÄ±pranmÄ±ÅŸ!"
- "Kesim mÃ¼mkÃ¼n deÄŸil!"

**Validasyon Fonksiyonu:**
```csharp
/// <summary>
/// âœ… Kesim mÃ¼mkÃ¼n mÃ¼?
/// </summary>
public bool CanCut(Vector3 blockPos, ChiselDefinition chisel, CutMode mode) {
    // 1. Blok var mÄ±?
    string blockType = _chunkManager.GetBlockType(blockPos);
    if (string.IsNullOrEmpty(blockType)) return false;
    
    // 2. Malzeme uyumlu mu?
    MaterialType material = GetMaterialType(blockType);
    if (!chisel.supportedMaterials.Contains(material)) return false;
    
    // 3. Alet yeterli mi?
    if (chisel.durability <= 0) return false;
    
    // 4. Kesim mÃ¼mkÃ¼n mÃ¼? (Ã§ok kÃ¼Ã§Ã¼k deÄŸilse)
    // ...
    
    return true;
}
```

---

### 1.5.15 UI/UX TasarÄ±mÄ±

#### 1.5.15.1 HUD ElemanlarÄ±

**Mod GÃ¶stergesi:**
- EkranÄ±n Ã¼stÃ¼nde aktif mod gÃ¶sterilir (KÃ¼p/Yuvarlak/Ã‡apraz)
- Mod deÄŸiÅŸtirme tuÅŸu gÃ¶sterilir (Q)

**KayÄ±t SlotlarÄ±:**
- EkranÄ±n saÄŸÄ±nda 9 slot gÃ¶sterilir (1-9)
- Her slot iÃ§in Ã¶nizleme ikonu
- BoÅŸ slotlar gri gÃ¶sterilir

**Komut Ä°puÃ§larÄ±:**
- Sol tÄ±k: Nokta seÃ§
- E: Kesimi onayla
- ESC: Ä°ptal et
- K: Åekli kaydet
- 1-9: KaydedilmiÅŸ ÅŸekli uygula

#### 1.5.15.2 GÃ¶rsel Geri Bildirim

**Marker'lar:**
- BaÅŸlangÄ±Ã§ noktasÄ±: YeÅŸil kÃ¼p
- BitiÅŸ noktasÄ±: KÄ±rmÄ±zÄ± kÃ¼p
- SeÃ§im Ã§izgisi: Mavi Ã§izgi

**Ã–nizleme Mesh:**
- Kesim Ã¶ncesi mesh gÃ¶sterilir
- YarÄ± saydam materyal
- Kesim sonrasÄ± gÃ¶rÃ¼nÃ¼mÃ¼ gÃ¶sterir

**Hata GÃ¶stergesi:**
- Uyumsuz malzeme: KÄ±rmÄ±zÄ± Ã§erÃ§eve
- Alet yetersiz: SarÄ± Ã§erÃ§eve
- Kesim mÃ¼mkÃ¼n deÄŸil: Gri Ã§erÃ§eve

---

### 1.5.16 MantÄ±k HatalarÄ± ve DÃ¼zeltmeler

#### 1. âœ… Voxel Terrain Entegrasyonu - DÃœZELTÄ°LDÄ°

**Sorun:** ChiselRaycast'te `hit.transform` kullanÄ±lÄ±yordu, ama voxel terrain'de transform yok.

**Ã‡Ã¶zÃ¼m:**
- ChunkManager'dan chunk al
- GridPlacementSystem ile grid'e yapÄ±ÅŸtÄ±r
- Blok pozisyonunu ChunkManager'dan al

#### 2. âœ… Variant ID FormatÄ± - DÃœZELTÄ°LDÄ°

**Sorun:** Variant ID oluÅŸturma mantÄ±ÄŸÄ± VariantMeshGenerator ile uyumlu deÄŸildi.

**Ã‡Ã¶zÃ¼m:**
- VariantMeshGenerator formatÄ±na uygun ID oluÅŸturma
- "wood_half_top", "stone_quarter_top_left" formatÄ±
- Material ID extraction

#### 3. âœ… Chunk Regeneration - DÃœZELTÄ°LDÄ°

**Sorun:** `RegenerateChunk()` coroutine olarak Ã§aÄŸrÄ±lÄ±yordu ama wrapper yoktu.

**Ã‡Ã¶zÃ¼m:**
- `RegenerateChunkCoroutine()` wrapper eklendi
- ChunkManager'Ä±n coroutine'i doÄŸru Ã§aÄŸrÄ±lÄ±yor
- Batch regeneration sistemi eklendi

#### 4. âœ… Eksik Metodlar - EKLENDÄ°

**Sorun:** `FindBlockPosition()`, `WorldToLocal()` metodlarÄ± eksikti.

**Ã‡Ã¶zÃ¼m:**
- `GetBlockWorldPosition()` eklendi
- `WorldToLocal()` eklendi
- `ExtractMaterialId()` eklendi

#### 5. âœ… Alet UyumluluÄŸu KontrolÃ¼ - EKLENDÄ°

**Sorun:** Alet malzeme uyumluluÄŸu kontrolÃ¼ eksikti.

**Ã‡Ã¶zÃ¼m:**
- `IsMaterialCompatible()` metodu eklendi
- `GetMaterialType()` metodu eklendi
- Hata mesajlarÄ± eklendi

#### 6. âœ… Ã–nizleme Mesh Sistemi - EKLENDÄ°

**Sorun:** Kesim Ã¶ncesi Ã¶nizleme yoktu.

**Ã‡Ã¶zÃ¼m:**
- `ShowPreviewMesh()` metodu eklendi
- `GetPreviewMesh()` metodu BlockCuttingSystem'e eklendi
- Visualizer'da Ã¶nizleme gÃ¶sterimi

---

### 1.5.17 YardÄ±mcÄ± Fonksiyonlar ve Metodlar

#### 1.5.17.1 YardÄ±mcÄ± Fonksiyonlar

```csharp
/// <summary>
/// âœ… Ä°ki nokta arasÄ± mesafe hesapla
/// </summary>
public static float CalculateDistance(Vector3 start, Vector3 end) {
    return Vector3.Distance(start, end);
}

/// <summary>
/// âœ… Kesim aÃ§Ä±sÄ±nÄ± hesapla
/// </summary>
public static float CalculateAngle(Vector3 start, Vector3 end) {
    Vector3 direction = (end - start).normalized;
    return Vector3.Angle(direction, Vector3.up);
}

/// <summary>
/// âœ… Kesim hacmini hesapla
/// </summary>
public static float CalculateVolume(Vector3 start, Vector3 end) {
    Vector3 size = end - start;
    return Mathf.Abs(size.x * size.y * size.z);
}

/// <summary>
/// âœ… Grid'e yapÄ±ÅŸtÄ±r
/// </summary>
public static Vector3 SnapToGrid(Vector3 point, float gridSize) {
    return new Vector3(
        Mathf.Round(point.x / gridSize) * gridSize,
        Mathf.Round(point.y / gridSize) * gridSize,
        Mathf.Round(point.z / gridSize) * gridSize
    );
}

/// <summary>
/// âœ… Malzeme tipini al
/// </summary>
MaterialType GetMaterialType(string blockType) {
    if (string.IsNullOrEmpty(blockType)) return MaterialType.Stone;
    
    string lowerType = blockType.ToLower();
    if (lowerType.Contains("wood")) return MaterialType.Wood;
    if (lowerType.Contains("stone") || lowerType.Contains("cobblestone") || lowerType.Contains("deep_stone")) return MaterialType.Stone;
    if (lowerType.Contains("iron") || lowerType.Contains("gold") || lowerType.Contains("copper") || lowerType.Contains("titanium") || lowerType.Contains("metal")) return MaterialType.Metal;
    return MaterialType.Stone; // Default
}
```

#### 1.5.17.2 Validasyon FonksiyonlarÄ±

```csharp
/// <summary>
/// âœ… Kesim mÃ¼mkÃ¼n mÃ¼? (Tam validasyon)
/// </summary>
public bool CanCut(Vector3 blockPos, ChiselDefinition chisel, CutMode mode) {
    // 1. Blok var mÄ±?
    string blockType = _chunkManager.GetBlockType(blockPos);
    if (string.IsNullOrEmpty(blockType)) {
        ShowErrorMessage("Blok bulunamadÄ±!");
        return false;
    }
    
    // 2. Malzeme uyumlu mu?
    MaterialType material = GetMaterialType(blockType);
    if (!chisel.supportedMaterials.Contains(material)) {
        ShowErrorMessage("Bu malzeme iÃ§in uygun alet deÄŸil!");
        return false;
    }
    
    // 3. Alet yeterli mi?
    if (chisel.durability <= 0) {
        ShowErrorMessage("Alet Ã§ok yÄ±pranmÄ±ÅŸ!");
        return false;
    }
    
    // 4. Kesim mÃ¼mkÃ¼n mÃ¼? (Ã§ok kÃ¼Ã§Ã¼k deÄŸilse)
    if (_startPoint != Vector3.zero && _endPoint != Vector3.zero) {
        float distance = CalculateDistance(_startPoint, _endPoint);
        if (distance < chisel.precision) {
            ShowErrorMessage("Kesim Ã§ok kÃ¼Ã§Ã¼k!");
            return false;
        }
    }
    
    return true;
}

/// <summary>
/// âœ… Hata mesajÄ± gÃ¶ster
/// </summary>
void ShowErrorMessage(string message) {
    // UI'da hata mesajÄ± gÃ¶ster
    Debug.LogWarning($"[ChiselTool] {message}");
    // TODO: UI Manager'a mesaj gÃ¶nder
}
```

---

### 1.5.18 Ek Item'ler ve TanÄ±mlar

#### 1.5.18.1 Alet Item TanÄ±mlarÄ±

**Odun Kesici (Wood Chisel)**
- Item ID: `WOOD_CHISEL`
- Chisel Level: Basic
- Supported Materials: Wood
- Crafting Recipe: 2x Iron Ingot + 1x Stick

**TaÅŸ Kesici (Stone Chisel)**
- Item ID: `STONE_CHISEL`
- Chisel Level: Basic
- Supported Materials: Stone
- Crafting Recipe: 2x Iron Ingot + 1x Stone

**Metal Kesici (Metal Chisel)**
- Item ID: `METAL_CHISEL`
- Chisel Level: Basic
- Supported Materials: Metal (Iron, Gold, Copper, Titanium)
- Crafting Recipe: 2x Titanium Ingot + 1x Iron Ingot

#### 1.5.18.2 Upgrade Item'leri

**GeliÅŸmiÅŸ Odun Kesici (Advanced Wood Chisel)**
- Item ID: `ADVANCED_WOOD_CHISEL`
- Chisel Level: Advanced
- Upgrade Recipe: Basic Wood Chisel + 5x Red Diamond

**Usta Odun Kesici (Master Wood Chisel)**
- Item ID: `MASTER_WOOD_CHISEL`
- Chisel Level: Master
- Upgrade Recipe: Advanced Wood Chisel + 10x Titanium

---



---

## ğŸ› ï¸ ADIM 1.6: CRAFTING SÄ°STEMÄ° (ÃœRETÄ°M SÄ°STEMÄ°)

> **âœ… YENÄ° SÄ°STEM:** OyuncularÄ±n malzemeleri birleÅŸtirerek yeni item'lar Ã¼retmesini saÄŸlayan crafting sistemi.  
> **Entegrasyon:** PlayerInventory, ItemDatabase, ChunkManager, ServiceLocator  
> **Faz:** 4 (Oyun Mekanikleri)

### 1.6.1 Sistem Genel BakÄ±ÅŸ

**AmaÃ§:**
OyuncularÄ±n malzemeleri birleÅŸtirerek yeni item'lar Ã¼retmesini saÄŸlamak.

**Temel Ã–zellikler:**
1. **Crafting Table/Workbench:** FarklÄ± seviyelerde crafting yapÄ±labilir
2. **Recipe Sistemi:** ScriptableObject tabanlÄ± tarifler
3. **Crafting UI:** Grid-based, drag-drop interface
4. **Recipe Book:** Ã–ÄŸrenilen tarifler
5. **Crafting Animasyonu:** Oyuncu animasyonu
6. **Crafting SÃ¼resi:** Zaman bazlÄ± Ã¼retim
7. **Malzeme KontrolÃ¼:** Envanter kontrolÃ¼
8. **Crafting Sonucu:** Item spawn

---

### 1.6.2 CraftingRecipe.cs - Recipe TanÄ±mlarÄ±

**Dosya:** `_Stratocraft/Data/Recipes/Crafting/CraftingRecipe.cs`

**AmaÃ§:** Crafting recipe tanÄ±mlarÄ±nÄ± ScriptableObject olarak saklamak

**Kod:**

```csharp
using UnityEngine;

/// <summary>
/// âœ… Crafting recipe tanÄ±mlarÄ± (ScriptableObject)
/// </summary>
[CreateAssetMenu(fileName = "CraftingRecipe", menuName = "Stratocraft/Crafting Recipe")]
public class CraftingRecipe : ScriptableObject {
    [Header("Kimlik")]
    public string recipeId;
    public string recipeName;
    
    [Header("SonuÃ§")]
    public ItemDefinition resultItem;
    public int resultAmount = 1;
    
    [Header("Malzemeler")]
    public List<RecipeIngredient> ingredients;
    
    [Header("Gereksinimler")]
    public CraftingTableLevel requiredTableLevel;
    public float craftingTime = 1.0f; // saniye
}

/// <summary>
/// âœ… Recipe malzemesi
/// </summary>
[System.Serializable]
public class RecipeIngredient {
    public ItemDefinition item;
    public int amount;
}

/// <summary>
/// âœ… Crafting table seviyeleri
/// </summary>
public enum CraftingTableLevel {
    None,      // El crafting
    Basic,     // Level 1 workbench
    Advanced,  // Level 2 workbench
    Master     // Level 3 workbench
}
```

---

### 1.6.3 CraftingTable.cs - Crafting Table YapÄ±sÄ±

**Dosya:** `_Stratocraft/Scripts/Systems/Crafting/CraftingTable.cs`

**AmaÃ§:** Crafting table yapÄ±sÄ±nÄ± ve etkileÅŸimini yÃ¶netmek

**Kod:**

```csharp
using UnityEngine;
using FishNet.Object;
using System.Collections.Generic;

/// <summary>
/// âœ… Crafting table - OPTÄ°MÄ°ZE: ServiceLocator, Cache, ChunkManager entegrasyonu
/// </summary>
public class CraftingTable : NetworkBehaviour, IInteractable {
    [Header("Crafting Table AyarlarÄ±")]
    public CraftingTableLevel tableLevel = CraftingTableLevel.Basic;
    public float interactionRange = 3f;
    
    // âœ… OPTÄ°MÄ°ZE: ServiceLocator entegrasyonu
    private CraftingManager _craftingManager;
    private ChunkManager _chunkManager;
    
    // âœ… OPTÄ°MÄ°ZE: Recipe cache (O(1) lookup)
    private Dictionary<string, CraftingRecipe> _recipeCache = new Dictionary<string, CraftingRecipe>();
    
    void Awake() {
        // âœ… ServiceLocator'dan sistemleri al
        _craftingManager = ServiceLocator.Instance?.Get<CraftingManager>();
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        
        if (_craftingManager == null) {
            Debug.LogWarning("[CraftingTable] CraftingManager bulunamadÄ±!");
        }
    }
    
    void Start() {
        // âœ… Recipe cache'i doldur
        LoadRecipeCache();
    }
    
    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: Recipe cache yÃ¼kleme
    /// </summary>
    void LoadRecipeCache() {
        CraftingRecipe[] allRecipes = Resources.LoadAll<CraftingRecipe>("CraftingRecipes");
        foreach (var recipe in allRecipes) {
            if (!string.IsNullOrEmpty(recipe.recipeId)) {
                _recipeCache[recipe.recipeId] = recipe;
            }
        }
        Debug.Log($"[CraftingTable] {_recipeCache.Count} recipe cache'lendi");
    }
    
    /// <summary>
    /// âœ… IInteractable interface
    /// </summary>
    public void OnInteract(NetworkObject player) {
        if (!IsServer) return;
        
        // âœ… ChunkManager entegrasyonu (voxel terrain uyumlu)
        Vector3 tablePos = transform.position;
        Vector3Int chunkCoord = _chunkManager?.GetChunkCoord(tablePos) ?? Vector3Int.zero;
        
        // âœ… Crafting UI aÃ§
        RpcOpenCraftingUI(player.Owner, tableLevel);
    }
    
    /// <summary>
    /// âœ… Client'lara crafting UI aÃ§
    /// </summary>
    [ObserversRpc]
    void RpcOpenCraftingUI(NetworkConnection conn, CraftingTableLevel level) {
        // âœ… UI Manager'dan crafting UI aÃ§
        CraftingUI craftingUI = ServiceLocator.Instance?.Get<CraftingUI>();
        craftingUI?.OpenCraftingTable(level, _recipeCache);
    }
    
    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: Recipe lookup (O(1) cache)
    /// </summary>
    public CraftingRecipe GetRecipe(string recipeId) {
        return _recipeCache.TryGetValue(recipeId, out CraftingRecipe recipe) ? recipe : null;
    }
}
```

---

### 1.6.4 CraftingManager.cs - Crafting MantÄ±ÄŸÄ±

**Dosya:** `_Stratocraft/Scripts/Systems/Crafting/CraftingManager.cs`

**AmaÃ§:** Crafting mantÄ±ÄŸÄ±nÄ± yÃ¶netmek

**Kod:**

```csharp
using UnityEngine;
using FishNet.Object;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// âœ… Crafting Manager - OPTÄ°MÄ°ZE: ServiceLocator, Cache, Network optimizasyonu
/// </summary>
public class CraftingManager : NetworkBehaviour {
    // âœ… OPTÄ°MÄ°ZE: ServiceLocator entegrasyonu
    private ItemDatabase _itemDatabase;
    private PlayerInventory _playerInventory;
    
    // âœ… OPTÄ°MÄ°ZE: Recipe database cache (O(1) lookup)
    private Dictionary<string, CraftingRecipe> _recipeDatabase = new Dictionary<string, CraftingRecipe>();
    
    // âœ… OPTÄ°MÄ°ZE: Learned recipes cache (player -> recipes)
    private Dictionary<uint, HashSet<string>> _learnedRecipesCache = new Dictionary<uint, HashSet<string>>();
    
    void Awake() {
        // âœ… ServiceLocator'a kaydet
        ServiceLocator.Instance?.Register<CraftingManager>(this);
    }
    
    void Start() {
        // âœ… Service referanslarÄ±nÄ± al
        _itemDatabase = ServiceLocator.Instance?.Get<ItemDatabase>();
        LoadAllRecipes();
    }
    
    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: TÃ¼m recipe'leri yÃ¼kle ve cache'le
    /// </summary>
    void LoadAllRecipes() {
        CraftingRecipe[] allRecipes = Resources.LoadAll<CraftingRecipe>("CraftingRecipes");
        foreach (var recipe in allRecipes) {
            if (!string.IsNullOrEmpty(recipe.recipeId)) {
                _recipeDatabase[recipe.recipeId] = recipe;
            }
        }
        Debug.Log($"[CraftingManager] {_recipeDatabase.Count} recipe yÃ¼klendi");
    }
    
    /// <summary>
    /// âœ… Craft item (server-authoritative)
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void CmdCraftItem(NetworkObject player, string recipeId, CraftingTableLevel tableLevel) {
        if (!IsServer) return;
        
        // âœ… Recipe lookup (O(1) cache)
        if (!_recipeDatabase.TryGetValue(recipeId, out CraftingRecipe recipe)) {
            Debug.LogWarning($"[CraftingManager] Recipe bulunamadÄ±: {recipeId}");
            return;
        }
        
        // âœ… Table level kontrolÃ¼
        if (tableLevel < recipe.requiredTableLevel) {
            Debug.LogWarning($"[CraftingManager] Yetersiz crafting table seviyesi!");
            return;
        }
        
        // âœ… Player inventory kontrolÃ¼
        _playerInventory = player.GetComponent<PlayerInventory>();
        if (_playerInventory == null) return;
        
        // âœ… Malzeme kontrolÃ¼
        if (!HasRequiredIngredients(player, recipe)) {
            Debug.LogWarning($"[CraftingManager] Yetersiz malzeme!");
            return;
        }
        
        // âœ… Malzemeleri Ã§Ä±kar
        RemoveIngredients(player, recipe);
        
        // âœ… Item'Ä± ekle
        _playerInventory.CmdAddItem(recipe.resultItem.itemID, recipe.resultAmount);
        
        Debug.Log($"[CraftingManager] {recipe.recipeName} craft edildi");
    }
    
    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: Malzeme kontrolÃ¼ (cache ile)
    /// </summary>
    bool HasRequiredIngredients(NetworkObject player, CraftingRecipe recipe) {
        _playerInventory = player.GetComponent<PlayerInventory>();
        if (_playerInventory == null) return false;
        
        foreach (var ingredient in recipe.ingredients) {
            int playerAmount = _playerInventory.GetItemCount(ingredient.item.itemID);
            if (playerAmount < ingredient.amount) {
                return false;
            }
        }
        return true;
    }
    
    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: Malzemeleri Ã§Ä±kar
    /// </summary>
    void RemoveIngredients(NetworkObject player, CraftingRecipe recipe) {
        _playerInventory = player.GetComponent<PlayerInventory>();
        if (_playerInventory == null) return;
        
        foreach (var ingredient in recipe.ingredients) {
            _playerInventory.CmdRemoveItem(ingredient.item.itemID, ingredient.amount);
        }
    }
    
    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: Recipe lookup (O(1))
    /// </summary>
    public CraftingRecipe GetRecipe(string recipeId) {
        return _recipeDatabase.TryGetValue(recipeId, out CraftingRecipe recipe) ? recipe : null;
    }
}
```

---

### 1.6.5 CraftingUI.cs - Crafting ArayÃ¼zÃ¼

**Dosya:** `_Stratocraft/Scripts/UI/CraftingUI.cs`

**AmaÃ§:** Crafting UI'Ä± yÃ¶netmek

**Kod:**

```csharp
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

/// <summary>
/// âœ… Crafting UI - OPTÄ°MÄ°ZE: UI pooling, async loading
/// </summary>
public class CraftingUI : MonoBehaviour {
    [Header("UI ReferanslarÄ±")]
    public GameObject craftingPanel;
    public Transform recipeListParent;
    public GameObject recipeItemPrefab;
    
    // âœ… OPTÄ°MÄ°ZE: UI element pooling
    private Queue<GameObject> _recipeItemPool = new Queue<GameObject>();
    private List<GameObject> _activeRecipeItems = new List<GameObject>();
    
    // âœ… OPTÄ°MÄ°ZE: ServiceLocator entegrasyonu
    private CraftingManager _craftingManager;
    private PlayerInventory _playerInventory;
    
    void Awake() {
        ServiceLocator.Instance?.Register<CraftingUI>(this);
    }
    
    void Start() {
        _craftingManager = ServiceLocator.Instance?.Get<CraftingManager>();
        _playerInventory = ServiceLocator.Instance?.Get<PlayerInventory>();
    }
    
    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: Crafting table aÃ§ (cache ile)
    /// </summary>
    public void OpenCraftingTable(CraftingTableLevel level, Dictionary<string, CraftingRecipe> availableRecipes) {
        craftingPanel.SetActive(true);
        RefreshRecipeList(level, availableRecipes);
    }
    
    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: Recipe listesi yenile (pooling ile)
    /// </summary>
    void RefreshRecipeList(CraftingTableLevel level, Dictionary<string, CraftingRecipe> availableRecipes) {
        // âœ… Mevcut item'larÄ± pool'a geri gÃ¶nder
        foreach (var item in _activeRecipeItems) {
            ReturnToPool(item);
        }
        _activeRecipeItems.Clear();
        
        // âœ… Yeni item'larÄ± gÃ¶ster
        foreach (var recipe in availableRecipes.Values) {
            if (recipe.requiredTableLevel <= level) {
                GameObject item = GetFromPool();
                item.transform.SetParent(recipeListParent);
                item.SetActive(true);
                _activeRecipeItems.Add(item);
                
                // âœ… Recipe bilgilerini gÃ¶ster
                RecipeItemUI itemUI = item.GetComponent<RecipeItemUI>();
                itemUI?.Setup(recipe, _playerInventory);
            }
        }
    }
    
    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: Object pooling
    /// </summary>
    GameObject GetFromPool() {
        if (_recipeItemPool.Count > 0) {
            return _recipeItemPool.Dequeue();
        }
        return Instantiate(recipeItemPrefab);
    }
    
    /// <summary>
    /// âœ… Pool'a geri gÃ¶nder
    /// </summary>
    void ReturnToPool(GameObject item) {
        item.SetActive(false);
        _recipeItemPool.Enqueue(item);
    }
}
```

---

### 1.6.6 Dosya YapÄ±sÄ±

**Yeni Dosyalar:**
```
_Stratocraft/
â”œâ”€â”€ Data/
â”‚   â””â”€â”€ Recipes/
â”‚       â””â”€â”€ Crafting/
â”‚           â””â”€â”€ CraftingRecipe.cs (ScriptableObject)
â”‚
â”œâ”€â”€ Scripts/
â”‚   â”œâ”€â”€ Systems/
â”‚   â”‚   â””â”€â”€ Crafting/
â”‚   â”‚       â”œâ”€â”€ CraftingTable.cs
â”‚   â”‚       â””â”€â”€ CraftingManager.cs
â”‚   â”‚
â”‚   â””â”€â”€ UI/
â”‚       â””â”€â”€ CraftingUI.cs
```

---

### 1.6.7 Entegrasyonlar

**ServiceLocator:**
- `CraftingManager` â†’ `ServiceLocator.Instance.Register<CraftingManager>(this)`
- `CraftingUI` â†’ `ServiceLocator.Instance.Register<CraftingUI>(this)`

**ChunkManager:**
- Crafting table pozisyonu chunk koordinatÄ±na Ã§evrilir
- Voxel terrain uyumlu

**PlayerInventory:**
- Malzeme kontrolÃ¼ iÃ§in `GetItemCount()` kullanÄ±lÄ±r
- Item ekleme/Ã§Ä±karma iÃ§in `CmdAddItem()` / `CmdRemoveItem()` kullanÄ±lÄ±r

**ItemDatabase:**
- Recipe lookup iÃ§in kullanÄ±lÄ±r

---

### 1.6.8 Optimizasyonlar

**âœ… Dictionary Cache:**
- Recipe lookup: O(1) complexity
- Learned recipes cache: Player bazlÄ±

**âœ… UI Pooling:**
- Recipe item UI elementleri pool'lanÄ±r
- Performans optimizasyonu

**âœ… Network Optimizasyonu:**
- Server-authoritative crafting
- `ServerRpc` ve `ObserversRpc` kullanÄ±mÄ±

---

## ğŸ› ï¸ ADIM 1.7: KAPSAMLI ENVANTER SÄ°STEMÄ°

> **âœ… YENÄ° SÄ°STEM:** OyuncularÄ±n item'larÄ± taÅŸÄ±masÄ±, organize etmesi ve kullanmasÄ± iÃ§in kapsamlÄ± envanter sistemi.  
> **Entegrasyon:** ItemDatabase, DatabaseManager, ServiceLocator, CraftingManager  
> **Faz:** 4 (Oyun Mekanikleri)

### 1.7.1 Sistem Genel BakÄ±ÅŸ

**AmaÃ§:**
OyuncularÄ±n item'larÄ± taÅŸÄ±masÄ±, organize etmesi ve kullanmasÄ± iÃ§in kapsamlÄ± envanter sistemi.

**Temel Ã–zellikler:**
1. **Player Inventory:** Grid-based, 27-36 slot
2. **Hotbar:** 9 slot, 1-9 tuÅŸlarÄ±
3. **Envanter UI:** Drag-drop, shift-click
4. **Item Stacking:** maxStack kontrolÃ¼
5. **Item Sorting:** Kategori bazlÄ±
6. **AÄŸÄ±rlÄ±k Sistemi:** Weight limit
7. **Kategoriler:** Material, Weapon, Tool, vb.
8. **Quick Slot:** HÄ±zlÄ± eriÅŸim

---

### 1.7.2 InventorySlot.cs - Slot Veri YapÄ±sÄ±

**Dosya:** `_Stratocraft/Scripts/Systems/Inventory/InventorySlot.cs`

**AmaÃ§:** Inventory slot veri yapÄ±sÄ±

**Kod:**

```csharp
using UnityEngine;

/// <summary>
/// âœ… Inventory slot - OPTÄ°MÄ°ZE: Temiz kod, data structure
/// </summary>
[System.Serializable]
public class InventorySlot {
    public string itemId = "";
    public int amount = 0;
    public int slotIndex = -1;
    
    public bool IsEmpty() => string.IsNullOrEmpty(itemId) || amount <= 0;
    
    public void SetItem(string id, int amt) {
        itemId = id;
        amount = amt;
    }
    
    public void Clear() {
        itemId = "";
        amount = 0;
    }
    
    public void AddAmount(int amt) {
        amount += amt;
    }
    
    public void RemoveAmount(int amt) {
        amount -= amt;
        if (amount <= 0) Clear();
    }
}
```

---

### 1.7.3 PlayerInventory.cs - Envanter MantÄ±ÄŸÄ±

**Dosya:** `_Stratocraft/Scripts/Systems/Inventory/PlayerInventory.cs`

**AmaÃ§:** Player envanter mantÄ±ÄŸÄ±nÄ± yÃ¶netmek

**Kod:**

```csharp
using UnityEngine;
using FishNet.Object;
using FishNet.Object.Synchronizing;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// âœ… Player Inventory - OPTÄ°MÄ°ZE: ServiceLocator, Cache, Network optimizasyonu
/// </summary>
public class PlayerInventory : NetworkBehaviour {
    [Header("Envanter AyarlarÄ±")]
    [SyncVar] private int _inventorySize = 27; // 3x9 grid
    [SyncVar] private int _hotbarSize = 9;
    [SyncVar] private float _currentWeight = 0f;
    [SyncVar] private float _maxWeight = 100f;
    
    // âœ… OPTÄ°MÄ°ZE: SyncList kullan (network synchronization)
    private SyncList<InventorySlot> _slots = new SyncList<InventorySlot>();
    private SyncList<InventorySlot> _hotbar = new SyncList<InventorySlot>();
    
    // âœ… OPTÄ°MÄ°ZE: Item lookup cache (O(1) lookup)
    private Dictionary<string, int> _itemCountCache = new Dictionary<string, int>();
    
    // âœ… OPTÄ°MÄ°ZE: ServiceLocator entegrasyonu
    private ItemDatabase _itemDatabase;
    private DatabaseManager _databaseManager;
    
    // âœ… OPTÄ°MÄ°ZE: Selected hotbar slot
    [SyncVar] private int _selectedHotbarSlot = 0;
    
    void Awake() {
        // âœ… ServiceLocator'a kaydet
        ServiceLocator.Instance?.Register<PlayerInventory>(this);
    }
    
    void Start() {
        // âœ… Service referanslarÄ±nÄ± al
        _itemDatabase = ServiceLocator.Instance?.Get<ItemDatabase>();
        _databaseManager = ServiceLocator.Instance?.Get<DatabaseManager>();
        
        // âœ… Envanteri baÅŸlat
        InitializeInventory();
    }
    
    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: Envanter baÅŸlatma
    /// </summary>
    void InitializeInventory() {
        if (!IsServer) return;
        
        // âœ… Slot'larÄ± oluÅŸtur
        for (int i = 0; i < _inventorySize; i++) {
            _slots.Add(new InventorySlot { slotIndex = i });
        }
        
        for (int i = 0; i < _hotbarSize; i++) {
            _hotbar.Add(new InventorySlot { slotIndex = i });
        }
        
        // âœ… VeritabanÄ±ndan yÃ¼kle (async)
        LoadInventoryFromDatabase();
    }
    
    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: VeritabanÄ±ndan yÃ¼kle (async - UI donmasÄ±nÄ± Ã¶nler)
    /// </summary>
    async void LoadInventoryFromDatabase() {
        if (_databaseManager == null) return;
        
        // âœ… Async database query
        var inventoryData = await _databaseManager.LoadPlayerInventoryAsync(OwnerId);
        if (inventoryData != null) {
            // âœ… Envanteri doldur
            foreach (var item in inventoryData.items) {
                CmdAddItem(item.itemId, item.amount);
            }
        }
    }
    
    /// <summary>
    /// âœ… Item ekle (server-authoritative)
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void CmdAddItem(string itemId, int amount) {
        if (!IsServer) return;
        if (string.IsNullOrEmpty(itemId) || amount <= 0) return;
        
        ItemDefinition itemDef = _itemDatabase?.GetItem(itemId);
        if (itemDef == null) {
            Debug.LogWarning($"[PlayerInventory] Item bulunamadÄ±: {itemId}");
            return;
        }
        
        // âœ… AÄŸÄ±rlÄ±k kontrolÃ¼
        float itemWeight = itemDef.weight * amount;
        if (_currentWeight + itemWeight > _maxWeight) {
            Debug.LogWarning("[PlayerInventory] Envanter aÄŸÄ±rlÄ±k limiti aÅŸÄ±ldÄ±!");
            return;
        }
        
        int remainingAmount = amount;
        
        // âœ… Ã–nce mevcut stack'lere ekle
        remainingAmount = TryStackItem(itemId, remainingAmount);
        
        // âœ… Yeni slot'lara ekle
        while (remainingAmount > 0) {
            InventorySlot emptySlot = FindEmptySlot();
            if (emptySlot == null) {
                Debug.LogWarning("[PlayerInventory] Envanter dolu!");
                break;
            }
            
            int stackAmount = Mathf.Min(remainingAmount, itemDef.maxStack);
            emptySlot.SetItem(itemId, stackAmount);
            remainingAmount -= stackAmount;
        }
        
        // âœ… Cache gÃ¼ncelle
        UpdateItemCountCache();
        UpdateWeight();
        
        // âœ… VeritabanÄ±na kaydet (async)
        SaveInventoryToDatabase();
    }
    
    /// <summary>
    /// âœ… Item Ã§Ä±kar (server-authoritative)
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void CmdRemoveItem(string itemId, int amount) {
        if (!IsServer) return;
        if (string.IsNullOrEmpty(itemId) || amount <= 0) return;
        
        int remainingAmount = amount;
        
        // âœ… Slot'lardan Ã§Ä±kar
        foreach (var slot in _slots) {
            if (slot.itemId == itemId && remainingAmount > 0) {
                int removeAmount = Mathf.Min(remainingAmount, slot.amount);
                slot.RemoveAmount(removeAmount);
                remainingAmount -= removeAmount;
            }
        }
        
        // âœ… Hotbar'dan Ã§Ä±kar
        foreach (var slot in _hotbar) {
            if (slot.itemId == itemId && remainingAmount > 0) {
                int removeAmount = Mathf.Min(remainingAmount, slot.amount);
                slot.RemoveAmount(removeAmount);
                remainingAmount -= removeAmount;
            }
        }
        
        // âœ… Cache gÃ¼ncelle
        UpdateItemCountCache();
        UpdateWeight();
        
        // âœ… VeritabanÄ±na kaydet (async)
        SaveInventoryToDatabase();
    }
    
    /// <summary>
    /// âœ… Item taÅŸÄ±/swap (server-authoritative)
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void CmdMoveItem(int fromSlot, int toSlot, bool isHotbar) {
        if (!IsServer) return;
        
        SyncList<InventorySlot> sourceList = isHotbar ? _hotbar : _slots;
        SyncList<InventorySlot> targetList = (fromSlot < _hotbarSize && toSlot < _hotbarSize) ? _hotbar : _slots;
        
        if (fromSlot < 0 || fromSlot >= sourceList.Count) return;
        if (toSlot < 0 || toSlot >= targetList.Count) return;
        
        InventorySlot source = sourceList[fromSlot];
        InventorySlot target = targetList[toSlot];
        
        // âœ… Swap logic
        if (target.IsEmpty() || target.itemId == source.itemId) {
            // âœ… BoÅŸ slot veya aynÄ± item - taÅŸÄ± veya stack yap
            if (target.itemId == source.itemId) {
                // âœ… Stack yap
                int stackAmount = Mathf.Min(source.amount, GetItemMaxStack(target.itemId) - target.amount);
                target.AddAmount(stackAmount);
                source.RemoveAmount(stackAmount);
            } else {
                // âœ… TaÅŸÄ±
                target.SetItem(source.itemId, source.amount);
                source.Clear();
            }
        } else {
            // âœ… Swap
            string tempId = target.itemId;
            int tempAmount = target.amount;
            target.SetItem(source.itemId, source.amount);
            source.SetItem(tempId, tempAmount);
        }
        
        // âœ… Cache gÃ¼ncelle
        UpdateItemCountCache();
        UpdateWeight();
    }
    
    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: Item count cache (O(1) lookup)
    /// </summary>
    void UpdateItemCountCache() {
        _itemCountCache.Clear();
        
        foreach (var slot in _slots) {
            if (!slot.IsEmpty()) {
                if (_itemCountCache.ContainsKey(slot.itemId)) {
                    _itemCountCache[slot.itemId] += slot.amount;
                } else {
                    _itemCountCache[slot.itemId] = slot.amount;
                }
            }
        }
        
        foreach (var slot in _hotbar) {
            if (!slot.IsEmpty()) {
                if (_itemCountCache.ContainsKey(slot.itemId)) {
                    _itemCountCache[slot.itemId] += slot.amount;
                } else {
                    _itemCountCache[slot.itemId] = slot.amount;
                }
            }
        }
    }
    
    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: AÄŸÄ±rlÄ±k hesaplama
    /// </summary>
    void UpdateWeight() {
        _currentWeight = 0f;
        
        foreach (var slot in _slots) {
            if (!slot.IsEmpty()) {
                ItemDefinition itemDef = _itemDatabase?.GetItem(slot.itemId);
                if (itemDef != null) {
                    _currentWeight += itemDef.weight * slot.amount;
                }
            }
        }
        
        foreach (var slot in _hotbar) {
            if (!slot.IsEmpty()) {
                ItemDefinition itemDef = _itemDatabase?.GetItem(slot.itemId);
                if (itemDef != null) {
                    _currentWeight += itemDef.weight * slot.amount;
                }
            }
        }
    }
    
    // âœ… OPTÄ°MÄ°ZE: Helper metodlar
    int TryStackItem(string itemId, int amount) {
        foreach (var slot in _slots) {
            if (slot.itemId == itemId && amount > 0) {
                ItemDefinition itemDef = _itemDatabase?.GetItem(itemId);
                if (itemDef != null) {
                    int availableSpace = itemDef.maxStack - slot.amount;
                    if (availableSpace > 0) {
                        int stackAmount = Mathf.Min(amount, availableSpace);
                        slot.AddAmount(stackAmount);
                        amount -= stackAmount;
                    }
                }
            }
        }
        
        foreach (var slot in _hotbar) {
            if (slot.itemId == itemId && amount > 0) {
                ItemDefinition itemDef = _itemDatabase?.GetItem(itemId);
                if (itemDef != null) {
                    int availableSpace = itemDef.maxStack - slot.amount;
                    if (availableSpace > 0) {
                        int stackAmount = Mathf.Min(amount, availableSpace);
                        slot.AddAmount(stackAmount);
                        amount -= stackAmount;
                    }
                }
            }
        }
        
        return amount;
    }
    
    InventorySlot FindEmptySlot() {
        foreach (var slot in _slots) {
            if (slot.IsEmpty()) return slot;
        }
        return null;
    }
    
    int GetItemMaxStack(string itemId) {
        ItemDefinition itemDef = _itemDatabase?.GetItem(itemId);
        return itemDef?.maxStack ?? 1;
    }
    
    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: Item count lookup (O(1) cache)
    /// </summary>
    public int GetItemCount(string itemId) {
        return _itemCountCache.TryGetValue(itemId, out int count) ? count : 0;
    }
    
    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: VeritabanÄ±na kaydet (async)
    /// </summary>
    async void SaveInventoryToDatabase() {
        if (_databaseManager == null) return;
        
        List<InventoryItemData> items = new List<InventoryItemData>();
        foreach (var slot in _slots) {
            if (!slot.IsEmpty()) {
                items.Add(new InventoryItemData { itemId = slot.itemId, amount = slot.amount });
            }
        }
        
        await _databaseManager.SavePlayerInventoryAsync(OwnerId, items);
    }
}

/// <summary>
/// âœ… Inventory item data (database iÃ§in)
/// </summary>
[System.Serializable]
public class InventoryItemData {
    public string itemId;
    public int amount;
}
```

---

### 1.7.4 Dosya YapÄ±sÄ±

**Yeni Dosyalar:**
```
_Stratocraft/
â”œâ”€â”€ Scripts/
â”‚   â””â”€â”€ Systems/
â”‚       â””â”€â”€ Inventory/
â”‚           â”œâ”€â”€ InventorySlot.cs
â”‚           â””â”€â”€ PlayerInventory.cs
```

---

### 1.7.5 Entegrasyonlar

**ServiceLocator:**
- `PlayerInventory` â†’ `ServiceLocator.Instance.Register<PlayerInventory>(this)`

**ItemDatabase:**
- Item lookup iÃ§in `GetItem()` kullanÄ±lÄ±r
- Item weight ve maxStack bilgileri alÄ±nÄ±r

**DatabaseManager:**
- Async envanter yÃ¼kleme/kaydetme
- `LoadPlayerInventoryAsync()` / `SavePlayerInventoryAsync()`

**CraftingManager:**
- Malzeme kontrolÃ¼ iÃ§in `GetItemCount()` kullanÄ±lÄ±r
- Item ekleme/Ã§Ä±karma iÃ§in `CmdAddItem()` / `CmdRemoveItem()` kullanÄ±lÄ±r

---

### 1.7.6 Optimizasyonlar

**âœ… Dictionary Cache:**
- Item count lookup: O(1) complexity
- Cache her item ekleme/Ã§Ä±karma iÅŸleminde gÃ¼ncellenir

**âœ… SyncList:**
- Network synchronization iÃ§in SyncList kullanÄ±lÄ±r
- Otomatik client synchronization

**âœ… Async Database Operations:**
- UI donmasÄ±nÄ± Ã¶nlemek iÃ§in async/await kullanÄ±lÄ±r
- `LoadPlayerInventoryAsync()` / `SavePlayerInventoryAsync()`

**âœ… Weight Calculation:**
- Her item ekleme/Ã§Ä±karma iÅŸleminde aÄŸÄ±rlÄ±k gÃ¼ncellenir
- AÄŸÄ±rlÄ±k limiti kontrolÃ¼

---

## ğŸ› ï¸ ADIM 1.8: FURNITURE SÄ°STEMÄ° (Mobilya YerleÅŸtirme)

> **âœ… YENÄ° SÄ°STEM:** OyuncularÄ±n dekoratif ve iÅŸlevsel mobilyalarÄ± yerleÅŸtirmesini saÄŸlayan sistem.  
> **Entegrasyon:** StructurePlacer, ChunkManager, TerritoryManager, ServiceLocator  
> **Faz:** 4 (Oyun Mekanikleri)

### 1.8.1 Sistem Genel BakÄ±ÅŸ

**AmaÃ§:**
OyuncularÄ±n dekoratif ve iÅŸlevsel mobilyalarÄ± yerleÅŸtirmesini saÄŸlamak.

**Temel Ã–zellikler:**
1. **Furniture Items:** Bed, chair, table, chest, lamp, vb.
2. **Furniture Placement:** StructurePlacer entegrasyonu
3. **Furniture Interaction:** Sit on chair, sleep on bed
4. **Furniture Decoration:** Aesthetic items
5. **Furniture Storage:** Chest inventory
6. **Furniture Crafting:** Recipe'ler

---

### 1.8.2 FurnitureDefinition.cs - Furniture TanÄ±mlarÄ±

**Dosya:** `_Stratocraft/Data/Furniture/FurnitureDefinition.cs`

**AmaÃ§:** Furniture tanÄ±mlarÄ±nÄ± ScriptableObject olarak saklamak

**Kod:**

```csharp
using UnityEngine;

/// <summary>
/// âœ… Furniture definition - OPTÄ°MÄ°ZE: ScriptableObject, data-driven
/// </summary>
[CreateAssetMenu(fileName = "FurnitureDefinition", menuName = "Stratocraft/Furniture")]
public class FurnitureDefinition : ScriptableObject {
    [Header("Kimlik")]
    public string furnitureId;
    public string furnitureName;
    
    [Header("GÃ¶rsel")]
    public GameObject furniturePrefab;
    public FurnitureType type;
    
    [Header("Ã–zellikler")]
    public bool hasStorage; // Chest iÃ§in
    public int storageSlots; // Chest iÃ§in (0 = storage yok)
    public bool canSit; // Chair iÃ§in
    public bool canSleep; // Bed iÃ§in
    public bool requiresGround; // Yere yerleÅŸtirilebilir mi?
    public bool canRotate; // DÃ¶ndÃ¼rÃ¼lebilir mi?
    
    [Header("EtkileÅŸim")]
    public float interactionRange = 3f;
    public bool requiresOwnership; // Sahiplik gerekiyor mu?
}

/// <summary>
/// âœ… Furniture tipleri
/// </summary>
public enum FurnitureType {
    Bed,
    Chair,
    Table,
    Chest,
    Lamp,
    Decoration,
    Workbench,
    Storage
}
```

---

### 1.8.3 FurniturePlacer.cs - Furniture YerleÅŸtirme

**Dosya:** `_Stratocraft/Scripts/Systems/Furniture/FurniturePlacer.cs`

**AmaÃ§:** Furniture yerleÅŸtirme mantÄ±ÄŸÄ±nÄ± yÃ¶netmek

**Kod:**

```csharp
using UnityEngine;
using FishNet.Object;
using System.Collections.Generic;

/// <summary>
/// âœ… Furniture Placer - OPTÄ°MÄ°ZE: ServiceLocator, ChunkManager, StructurePlacer entegrasyonu
/// </summary>
public class FurniturePlacer : NetworkBehaviour {
    [Header("Furniture AyarlarÄ±")]
    public FurnitureDefinition furnitureDefinition;
    
    // âœ… OPTÄ°MÄ°ZE: ServiceLocator entegrasyonu
    private StructurePlacer _structurePlacer;
    private ChunkManager _chunkManager;
    private TerritoryManager _territoryManager;
    
    // âœ… OPTÄ°MÄ°ZE: Furniture cache (chunk bazlÄ±)
    private Dictionary<Vector3Int, List<FurnitureInstance>> _furnitureCache = new Dictionary<Vector3Int, List<FurnitureInstance>>();
    
    void Awake() {
        // âœ… Service referanslarÄ±nÄ± al
        _structurePlacer = ServiceLocator.Instance?.Get<StructurePlacer>();
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        _territoryManager = ServiceLocator.Instance?.Get<TerritoryManager>();
        
        if (_structurePlacer == null) {
            Debug.LogWarning("[FurniturePlacer] StructurePlacer bulunamadÄ±!");
        }
    }
    
    /// <summary>
    /// âœ… Furniture yerleÅŸtir (server-authoritative)
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void CmdPlaceFurniture(Vector3 position, FurnitureDefinition furnitureDef, NetworkObject player) {
        if (!IsServer) return;
        if (furnitureDef == null) return;
        
        // âœ… ChunkManager entegrasyonu (voxel terrain uyumlu)
        Vector3Int chunkCoord = _chunkManager?.GetChunkCoord(position) ?? Vector3Int.zero;
        
        // âœ… Territory kontrolÃ¼ (sahiplik gerekiyorsa)
        if (furnitureDef.requiresOwnership) {
            string territoryOwner = _territoryManager?.GetTerritoryOwner(position);
            if (string.IsNullOrEmpty(territoryOwner) || territoryOwner != player.OwnerId.ToString()) {
                Debug.LogWarning("[FurniturePlacer] Bu bÃ¶lgede furniture yerleÅŸtirme yetkisi yok!");
                return;
            }
        }
        
        // âœ… Yer kontrolÃ¼ (requiresGround)
        if (furnitureDef.requiresGround) {
            if (!_chunkManager?.IsSolidBlock(position + Vector3.down) ?? false) {
                Debug.LogWarning("[FurniturePlacer] Furniture yerleÅŸtirmek iÃ§in zemin gerekli!");
                return;
            }
        }
        
        // âœ… StructurePlacer ile yerleÅŸtir
        if (_structurePlacer != null) {
            _structurePlacer.PlaceStructure(position, furnitureDef.furniturePrefab);
        } else {
            // âœ… Fallback: Direkt instantiate
            GameObject furnitureObj = Instantiate(furnitureDef.furniturePrefab, position, Quaternion.identity);
            Spawn(furnitureObj, Owner);
        }
        
        // âœ… Cache'e ekle
        FurnitureInstance instance = new FurnitureInstance {
            furnitureDefinition = furnitureDef,
            position = position,
            ownerId = player.OwnerId,
            chunkCoord = chunkCoord
        };
        
        if (!_furnitureCache.ContainsKey(chunkCoord)) {
            _furnitureCache[chunkCoord] = new List<FurnitureInstance>();
        }
        _furnitureCache[chunkCoord].Add(instance);
        
        Debug.Log($"[FurniturePlacer] {furnitureDef.furnitureName} yerleÅŸtirildi: {position}");
    }
    
    /// <summary>
    /// âœ… Furniture kaldÄ±r (server-authoritative)
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void CmdRemoveFurniture(Vector3 position, NetworkObject player) {
        if (!IsServer) return;
        
        Vector3Int chunkCoord = _chunkManager?.GetChunkCoord(position) ?? Vector3Int.zero;
        
        if (_furnitureCache.TryGetValue(chunkCoord, out List<FurnitureInstance> furnitureList)) {
            FurnitureInstance furniture = furnitureList.Find(f => Vector3.Distance(f.position, position) < 0.5f);
            if (furniture != null) {
                // âœ… Sahiplik kontrolÃ¼
                if (furniture.ownerId != player.OwnerId) {
                    Debug.LogWarning("[FurniturePlacer] Bu furniture'Ä± kaldÄ±rma yetkiniz yok!");
                    return;
                }
                
                // âœ… KaldÄ±r
                furnitureList.Remove(furniture);
                
                // âœ… GameObject'i yok et
                Collider[] colliders = Physics.OverlapSphere(position, 0.5f);
                foreach (var col in colliders) {
                    if (col.GetComponent<FurnitureInstance>() != null) {
                        Despawn(col.gameObject);
                        break;
                    }
                }
                
                Debug.Log($"[FurniturePlacer] Furniture kaldÄ±rÄ±ldÄ±: {position}");
            }
        }
    }
    
    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: Chunk bazlÄ± furniture cache temizleme
    /// </summary>
    public void ClearChunkCache(Vector3Int chunkCoord) {
        _furnitureCache.Remove(chunkCoord);
    }
}

/// <summary>
/// âœ… Furniture instance data
/// </summary>
[System.Serializable]
public class FurnitureInstance {
    public FurnitureDefinition furnitureDefinition;
    public Vector3 position;
    public uint ownerId;
    public Vector3Int chunkCoord;
}
```

---

### 1.8.4 FurnitureInteraction.cs - Furniture EtkileÅŸimi

**Dosya:** `_Stratocraft/Scripts/Systems/Furniture/FurnitureInteraction.cs`

**AmaÃ§:** Furniture etkileÅŸim mantÄ±ÄŸÄ±nÄ± yÃ¶netmek

**Kod:**

```csharp
using UnityEngine;
using FishNet.Object;

/// <summary>
/// âœ… Furniture Interaction - OPTÄ°MÄ°ZE: IInteractable, ServiceLocator entegrasyonu
/// </summary>
public class FurnitureInteraction : NetworkBehaviour, IInteractable {
    [Header("Furniture ReferansÄ±")]
    public FurnitureDefinition furnitureDefinition;
    
    // âœ… OPTÄ°MÄ°ZE: ServiceLocator entegrasyonu
    private PlayerInventory _playerInventory;
    private ChestInventory _chestInventory; // Chest iÃ§in
    
    void Awake() {
        if (furnitureDefinition == null) {
            furnitureDefinition = GetComponent<FurnitureDefinition>();
        }
    }
    
    void Start() {
        _playerInventory = ServiceLocator.Instance?.Get<PlayerInventory>();
        
        // âœ… Chest ise ChestInventory component'i al
        if (furnitureDefinition.hasStorage) {
            _chestInventory = GetComponent<ChestInventory>();
            if (_chestInventory == null) {
                _chestInventory = gameObject.AddComponent<ChestInventory>();
            }
        }
    }
    
    /// <summary>
    /// âœ… IInteractable interface
    /// </summary>
    public void OnInteract(NetworkObject player) {
        if (!IsServer) return;
        
        if (furnitureDefinition == null) return;
        
        // âœ… Furniture tipine gÃ¶re etkileÅŸim
        switch (furnitureDefinition.type) {
            case FurnitureType.Chair:
                if (furnitureDefinition.canSit) {
                    CmdSitOnChair(player);
                }
                break;
                
            case FurnitureType.Bed:
                if (furnitureDefinition.canSleep) {
                    CmdSleepOnBed(player);
                }
                break;
                
            case FurnitureType.Chest:
                if (furnitureDefinition.hasStorage && _chestInventory != null) {
                    RpcOpenChest(player.Owner);
                }
                break;
                
            case FurnitureType.Workbench:
                // âœ… Crafting table gibi Ã§alÄ±ÅŸÄ±r
                CraftingTable craftingTable = GetComponent<CraftingTable>();
                if (craftingTable != null) {
                    craftingTable.OnInteract(player);
                }
                break;
        }
    }
    
    /// <summary>
    /// âœ… Sandalyeye otur
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    void CmdSitOnChair(NetworkObject player) {
        // âœ… Oturma animasyonu
        PlayerController playerController = player.GetComponent<PlayerController>();
        if (playerController != null) {
            playerController.SetSitting(true, transform.position);
        }
        
        RpcPlaySitAnimation(player.Owner);
    }
    
    /// <summary>
    /// âœ… Yatakta uyu
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    void CmdSleepOnBed(NetworkObject player) {
        // âœ… Uyuma mekaniÄŸi (GameTimeManager entegrasyonu)
        GameTimeManager timeManager = ServiceLocator.Instance?.Get<GameTimeManager>();
        if (timeManager != null) {
            timeManager.SleepUntilMorning();
        }
        
        RpcPlaySleepAnimation(player.Owner);
    }
    
    /// <summary>
    /// âœ… Chest aÃ§
    /// </summary>
    [ObserversRpc]
    void RpcOpenChest(NetworkConnection conn) {
        if (_chestInventory != null) {
            _chestInventory.OpenChest();
        }
    }
    
    /// <summary>
    /// âœ… Oturma animasyonu (client-side)
    /// </summary>
    [ObserversRpc]
    void RpcPlaySitAnimation(NetworkConnection conn) {
        Animator animator = GetComponent<Animator>();
        if (animator != null) {
            animator.SetTrigger("Sit");
        }
    }
    
    /// <summary>
    /// âœ… Uyuma animasyonu (client-side)
    /// </summary>
    [ObserversRpc]
    void RpcPlaySleepAnimation(NetworkConnection conn) {
        Animator animator = GetComponent<Animator>();
        if (animator != null) {
            animator.SetTrigger("Sleep");
        }
    }
}
```

---

### 1.8.5 Dosya YapÄ±sÄ±

**Yeni Dosyalar:**
```
_Stratocraft/
â”œâ”€â”€ Data/
â”‚   â””â”€â”€ Furniture/
â”‚       â””â”€â”€ FurnitureDefinition.cs (ScriptableObject)
â”‚
â”œâ”€â”€ Scripts/
â”‚   â””â”€â”€ Systems/
â”‚       â””â”€â”€ Furniture/
â”‚           â”œâ”€â”€ FurniturePlacer.cs
â”‚           â””â”€â”€ FurnitureInteraction.cs
```

---

### 1.8.6 Entegrasyonlar

**ServiceLocator:**
- `FurniturePlacer` â†’ ServiceLocator'dan sistemleri alÄ±r
- `FurnitureInteraction` â†’ ServiceLocator'dan sistemleri alÄ±r

**ChunkManager:**
- Furniture pozisyonu chunk koordinatÄ±na Ã§evrilir
- Voxel terrain uyumlu
- `IsSolidBlock()` ile zemin kontrolÃ¼

**StructurePlacer:**
- Furniture yerleÅŸtirme iÃ§in `PlaceStructure()` kullanÄ±lÄ±r

**TerritoryManager:**
- Sahiplik kontrolÃ¼ iÃ§in `GetTerritoryOwner()` kullanÄ±lÄ±r

**GameTimeManager:**
- Uyuma mekaniÄŸi iÃ§in `SleepUntilMorning()` kullanÄ±lÄ±r

---

### 1.8.7 Optimizasyonlar

**âœ… Dictionary Cache:**
- Furniture cache: Chunk bazlÄ± (O(1) lookup)
- Chunk unload olduÄŸunda cache temizlenir

**âœ… Network Optimizasyonu:**
- Server-authoritative furniture placement
- `ServerRpc` ve `ObserversRpc` kullanÄ±mÄ±

**âœ… Chunk-Based Caching:**
- Furniture'lar chunk bazlÄ± cache'lenir
- Chunk unload olduÄŸunda cache temizlenir

---

## ğŸ› ï¸ ADIM 1.9: Ä°ÅLEVSEL ITEM'LER (Functional Items)

> **âœ… YENÄ° SÄ°STEM:** Tool'larÄ±n durability, repair ve upgrade sistemlerini ekleyen sistem.  
> **Entegrasyon:** ItemDefinition, DatabaseManager, PlayerInventory, ServiceLocator  
> **Faz:** 4 (Oyun Mekanikleri)

### 1.9.1 Sistem Genel BakÄ±ÅŸ

**AmaÃ§:**
Tool'larÄ±n durability, repair ve upgrade sistemlerini eklemek.

**Temel Ã–zellikler:**
1. **Tool Durability:** KullanÄ±m sayÄ±sÄ±
2. **Tool Repair:** Anvil, repair station
3. **Tool Upgrade:** Seviye bazlÄ±
4. **Tool Enchantment:** BÃ¼yÃ¼ sistemi
5. **Ã‡ok AmaÃ§lÄ± Tool'lar:** Multi-purpose tools
6. **Tool Crafting:** Recipe'ler

---

### 1.9.2 ItemDefinition.cs GÃ¼ncellemeleri

**Dosya:** `_Stratocraft/Scripts/Core/Definitions/ItemDefinition.cs`

**Eklenen Ã–zellikler:**

```csharp
// ItemDefinition.cs'e eklenecek - OPTÄ°MÄ°ZE: Tool Ã¶zellikleri
[Header("Tool Durability")]
[Tooltip("Tool durability (kullanÄ±m sayÄ±sÄ±)")]
[Range(1, 10000)]
public int maxDurability = 100;

[Tooltip("Mevcut durability (runtime - database'de saklanÄ±r)")]
[System.NonSerialized]
public int currentDurability = 100;

[Tooltip("Tool seviyesi (upgrade iÃ§in)")]
[Range(1, 10)]
public int toolLevel = 1;

[Tooltip("Tool enchantments (bÃ¼yÃ¼ iÃ§in)")]
public List<Enchantment> enchantments = new List<Enchantment>();

[Tooltip("Repair malzemeleri (repair iÃ§in gerekli)")]
public List<RepairMaterial> repairMaterials = new List<RepairMaterial>();

[Tooltip("Upgrade malzemeleri (upgrade iÃ§in gerekli)")]
public List<UpgradeMaterial> upgradeMaterials = new List<UpgradeMaterial>();

[System.Serializable]
public class RepairMaterial {
    public ItemDefinition material;
    public int amount;
}

[System.Serializable]
public class UpgradeMaterial {
    public ItemDefinition material;
    public int amount;
    public int requiredLevel;
}

[System.Serializable]
public class Enchantment {
    public string enchantmentId;
    public string enchantmentName;
    public EnchantmentType type;
    public int level = 1;
    public float value = 0f; // Damage boost, speed boost, vb.
}

public enum EnchantmentType {
    DamageBoost,
    SpeedBoost,
    DurabilityBoost,
    EfficiencyBoost,
    Fortune, // Daha fazla drop
    Unbreaking // Daha yavaÅŸ yÄ±pranma
}
```

---

### 1.9.3 ToolDurability.cs - Durability Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Tools/ToolDurability.cs`

**AmaÃ§:** Tool durability mantÄ±ÄŸÄ±nÄ± yÃ¶netmek

**Ã–zellikler:**
- Durability azaltma (kullanÄ±m sonrasÄ±)
- Unbreaking enchantment desteÄŸi
- Tool kÄ±rÄ±ldÄ±ÄŸÄ±nda envanterden Ã§Ä±karma
- Async database persistence

---

### 1.9.4 RepairStation.cs - Repair Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Tools/RepairStation.cs`

**AmaÃ§:** Tool repair mantÄ±ÄŸÄ±nÄ± yÃ¶netmek

**Ã–zellikler:**
- Repair malzeme kontrolÃ¼
- Tool durability restore
- IInteractable interface

---

### 1.9.5 UpgradeStation.cs - Upgrade Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Tools/UpgradeStation.cs`

**AmaÃ§:** Tool upgrade mantÄ±ÄŸÄ±nÄ± yÃ¶netmek

**Ã–zellikler:**
- Upgrade malzeme kontrolÃ¼
- Tool level artÄ±ÅŸÄ±
- Durability ve efficiency artÄ±ÅŸÄ±

---

### 1.9.6 EnchantmentSystem.cs - Enchantment Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Tools/EnchantmentSystem.cs`

**AmaÃ§:** Enchantment mantÄ±ÄŸÄ±nÄ± yÃ¶netmek

**Ã–zellikler:**
- Enchantment database cache (O(1) lookup)
- Enchantment ekleme/Ã§Ä±karma
- ServiceLocator entegrasyonu

---

### 1.9.7 Dosya YapÄ±sÄ±

**Yeni Dosyalar:**
```
_Stratocraft/
â”œâ”€â”€ Scripts/
â”‚   â”œâ”€â”€ Core/
â”‚   â”‚   â””â”€â”€ Definitions/
â”‚   â”‚       â””â”€â”€ ItemDefinition.cs (gÃ¼ncellendi)
â”‚   â”‚
â”‚   â””â”€â”€ Systems/
â”‚       â””â”€â”€ Tools/
â”‚           â”œâ”€â”€ ToolDurability.cs
â”‚           â”œâ”€â”€ RepairStation.cs
â”‚           â”œâ”€â”€ UpgradeStation.cs
â”‚           â””â”€â”€ EnchantmentSystem.cs
â”‚
â””â”€â”€ Data/
    â””â”€â”€ Enchantments/
        â””â”€â”€ EnchantmentDefinition.cs (ScriptableObject)
```

---

### 1.9.8 Entegrasyonlar

**ServiceLocator:**
- `EnchantmentSystem` â†’ `ServiceLocator.Instance.Register<EnchantmentSystem>(this)`
- `RepairStation` / `UpgradeStation` â†’ ServiceLocator'dan sistemleri alÄ±r

**DatabaseManager:**
- Async durability persistence
- `LoadToolDurabilityAsync()` / `SaveToolDurabilityAsync()`

**PlayerInventory:**
- Tool kÄ±rÄ±ldÄ±ÄŸÄ±nda envanterden Ã§Ä±karma
- Repair/Upgrade malzeme kontrolÃ¼

---

### 1.9.9 Optimizasyonlar

**âœ… Dictionary Cache:**
- Enchantment lookup: O(1) complexity
- Durability cache: Player bazlÄ±

**âœ… Async Database Operations:**
- Durability persistence async/await ile
- UI donmasÄ±nÄ± Ã¶nler

**âœ… Network Optimizasyonu:**
- Server-authoritative tool operations
- `ServerRpc` ve `ObserversRpc` kullanÄ±mÄ±

---

## ğŸ› ï¸ ADIM 1.10: NPC SÄ°STEMÄ° (Non-Player Characters)

> **âœ… YENÄ° SÄ°STEM:** Dost NPC'ler (villagers) ekleyerek ticaret, gÃ¶rev ve kÃ¶y sistemlerini oluÅŸturan sistem.  
> **Entegrasyon:** ChunkManager, ChunkNavMeshBaker, PlayerInventory, ServiceLocator  
> **Faz:** 5 (Yapay Zeka, SavaÅŸ ve Felaketler)

### 1.10.1 Sistem Genel BakÄ±ÅŸ

**AmaÃ§:**
Dost NPC'ler (villagers) ekleyerek ticaret, gÃ¶rev ve kÃ¶y sistemlerini oluÅŸturmak.

**Temel Ã–zellikler:**
1. **NPC AI:** Dost NPC'ler, pathfinding
2. **NPC Ticaret:** Villager trading
3. **NPC GÃ¶rev:** Quest giver
4. **NPC KÃ¶yleri:** Village generation
5. **NPC Meslekleri:** Blacksmith, merchant, vb.
6. **NPC EtkileÅŸimi:** Dialogue system

---

### 1.10.2 NPCDefinition.cs - NPC TanÄ±mlarÄ±

**Dosya:** `_Stratocraft/Data/NPCs/NPCDefinition.cs`

**Kod:**

```csharp
[CreateAssetMenu(fileName = "NPCDefinition", menuName = "Stratocraft/NPC")]
public class NPCDefinition : ScriptableObject {
    [Header("Kimlik")]
    public string npcId;
    public string npcName;
    public NPCProfession profession;
    
    [Header("Ticaret")]
    public List<TradeOffer> tradeOffers = new List<TradeOffer>();
    
    [Header("GÃ¶revler")]
    public List<QuestDefinition> availableQuests = new List<QuestDefinition>();
    
    [Header("Diyalog")]
    public DialogueTree dialogueTree;
    
    [Header("AI AyarlarÄ±")]
    public float wanderRadius = 10f;
    public float interactionRange = 3f;
    public bool canMove = true;
    public float moveSpeed = 2f;
}

public enum NPCProfession {
    Blacksmith, Merchant, Farmer, Guard, Priest, Builder, Scholar
}
```

---

### 1.10.3 NPCAI.cs - NPC AI MantÄ±ÄŸÄ±

**Dosya:** `_Stratocraft/Scripts/Systems/NPCs/NPCAI.cs`

**Ã–zellikler:**
- State Machine (Idle, Wandering, Talking, Working)
- NavMesh pathfinding entegrasyonu
- ChunkManager entegrasyonu (voxel terrain uyumlu)
- ChunkNavMeshBaker entegrasyonu

---

### 1.10.4 VillagerTrading.cs - Ticaret Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/NPCs/VillagerTrading.cs`

**Ã–zellikler:**
- Trade offer sistemi
- Trade history cache
- PlayerInventory entegrasyonu

---

### 1.10.5 DialogueSystem.cs - Diyalog Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/NPCs/DialogueSystem.cs`

**Ã–zellikler:**
- Dialogue tree sistemi
- Dialogue state cache
- Network optimizasyonu

---

### 1.10.6 VillageGenerator.cs - KÃ¶y OluÅŸturma

**Dosya:** `_Stratocraft/Scripts/Systems/NPCs/VillageGenerator.cs`

**Ã–zellikler:**
- Job System + Burst ile village generation
- Chunk bazlÄ± village cache
- NPC spawn sistemi

---

### 1.10.7 Dosya YapÄ±sÄ±

```
_Stratocraft/
â”œâ”€â”€ Data/
â”‚   â””â”€â”€ NPCs/
â”‚       â””â”€â”€ NPCDefinition.cs
â”‚
â”œâ”€â”€ Scripts/
â”‚   â””â”€â”€ Systems/
â”‚       â””â”€â”€ NPCs/
â”‚           â”œâ”€â”€ NPCAI.cs
â”‚           â”œâ”€â”€ VillagerTrading.cs
â”‚           â”œâ”€â”€ DialogueSystem.cs
â”‚           â””â”€â”€ VillageGenerator.cs
```

---

### 1.10.8 Optimizasyonlar

**âœ… Dictionary Cache:**
- Trade history cache: Player bazlÄ±
- Dialogue state cache: Player bazlÄ±
- Village cache: Chunk bazlÄ±

**âœ… Job System + Burst:**
- Village generation paralel iÅŸlem

**âœ… NavMesh Entegrasyonu:**
- ChunkNavMeshBaker ile dinamik NavMesh

---

## ğŸ› ï¸ ADIM 1.11: GELÄ°ÅMÄ°Å BÄ°NEK SÄ°STEMÄ°

> **âœ… YENÄ° SÄ°STEM:** Binek sistemini eÄŸer, envanter, zÄ±rh ve Ã¶zel yeteneklerle geniÅŸleten sistem.  
> **Entegrasyon:** RideableMob, PlayerInventory, DatabaseManager, ServiceLocator  
> **Faz:** 7 (GÃ¼Ã§ Sistemi, Binekler ve SavaÅŸ Makineleri)

### 1.11.1 Sistem Genel BakÄ±ÅŸ

**AmaÃ§:**
Binek sistemini eÄŸer, envanter, zÄ±rh ve Ã¶zel yeteneklerle geniÅŸletmek.

**Temel Ã–zellikler:**
1. **Saddle System:** EÄŸer sistemi
2. **Mount Inventory:** Binek envanteri
3. **Mount Armor:** Binek zÄ±rhÄ±
4. **Mount Abilities:** Ã–zel yetenekler
5. **Mount Leveling:** Seviye sistemi
6. **Mount Breeding:** Ãœreme sistemi

---

### 1.11.2 SaddleDefinition.cs - EÄŸer TanÄ±mlarÄ±

**Dosya:** `_Stratocraft/Data/Mounts/SaddleDefinition.cs`

**Ã–zellikler:**
- Envanter slot sayÄ±sÄ±
- HÄ±z ve dayanÄ±klÄ±lÄ±k Ã§arpanlarÄ±
- ZÄ±rh takma desteÄŸi

---

### 1.11.3 MountInventory.cs - Binek Envanteri

**Dosya:** `_Stratocraft/Scripts/Systems/Mounts/MountInventory.cs`

**Ã–zellikler:**
- SyncList ile network synchronization
- Async database persistence
- Item stacking logic

---

### 1.11.4 MountArmor.cs - Binek ZÄ±rhÄ±

**Dosya:** `_Stratocraft/Scripts/Systems/Mounts/MountArmor.cs`

**Ã–zellikler:**
- Hasar azaltma sistemi
- ZÄ±rh yÄ±pranma mekaniÄŸi

---

### 1.11.5 MountAbilities.cs - Binek Yetenekleri

**Dosya:** `_Stratocraft/Scripts/Systems/Mounts/MountAbilities.cs`

**Ã–zellikler:**
- Cooldown sistemi
- Dash, Jump, Charge, Heal, Shield yetenekleri

---

### 1.11.6 MountLeveling.cs - Binek Seviye Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Mounts/MountLeveling.cs`

**Ã–zellikler:**
- Experience sistemi (exponential growth)
- Level bazlÄ± stat artÄ±ÅŸlarÄ±
- Async database persistence

---

### 1.11.7 Dosya YapÄ±sÄ±

```
_Stratocraft/
â”œâ”€â”€ Data/
â”‚   â””â”€â”€ Mounts/
â”‚       â”œâ”€â”€ SaddleDefinition.cs
â”‚       â””â”€â”€ MountArmorDefinition.cs
â”‚
â”œâ”€â”€ Scripts/
â”‚   â””â”€â”€ Systems/
â”‚       â””â”€â”€ Mounts/
â”‚           â”œâ”€â”€ MountInventory.cs
â”‚           â”œâ”€â”€ MountArmor.cs
â”‚           â”œâ”€â”€ MountAbilities.cs
â”‚           â””â”€â”€ MountLeveling.cs
```

---

## ğŸ› ï¸ ADIM 1.12: GELÄ°ÅMÄ°Å BOSS SÄ°STEMÄ°

> **âœ… YENÄ° SÄ°STEM:** Ejderha AI, boss arenasÄ±, loot table ve multi-phase fight sistemi.  
> **Entegrasyon:** BossAI, ChunkManager, StructurePlacer, ServiceLocator  
> **Faz:** 5 (Yapay Zeka, SavaÅŸ ve Felaketler)

### 1.12.1 Sistem Genel BakÄ±ÅŸ

**AmaÃ§:**
Ejderha AI, boss arenasÄ±, loot table ve multi-phase fight sistemi eklemek.

**Temel Ã–zellikler:**
1. **Dragon AI:** UÃ§uÅŸ mekaniÄŸi
2. **Boss Arena:** Arena sistemi
3. **Boss Loot:** Loot table
4. **Boss Phases:** Multi-phase fights
5. **Boss Summoning:** Ã‡aÄŸÄ±rma sistemi
6. **Boss Respawn:** Respawn cooldown

---

### 1.12.2 DragonAI.cs - Ejderha AI

**Dosya:** `_Stratocraft/Scripts/Systems/Bosses/DragonAI.cs`

**Ã–zellikler:**
- Flight state machine (Grounded, Flying, Hovering)
- Unity Physics entegrasyonu
- ChunkManager entegrasyonu (yÃ¼kseklik kontrolÃ¼)

---

### 1.12.3 BossArena.cs - Boss ArenasÄ±

**Dosya:** `_Stratocraft/Scripts/Systems/Bosses/BossArena.cs`

**Ã–zellikler:**
- Arena oluÅŸturma sistemi
- Boss spawn sistemi
- Respawn cooldown kontrolÃ¼

---

### 1.12.4 BossLootTable.cs - Loot Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Bosses/BossLootTable.cs`

**Ã–zellikler:**
- Rarity bazlÄ± loot sistemi
- Drop chance kontrolÃ¼
- ItemSpawner entegrasyonu

---

### 1.12.5 BossPhaseSystem.cs - Faz Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Bosses/BossPhaseSystem.cs`

**Ã–zellikler:**
- Multi-phase fight sistemi
- Phase bazlÄ± ability sistemi
- Health threshold kontrolÃ¼

---

### 1.12.6 BossSummoning.cs - Ã‡aÄŸÄ±rma Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Bosses/BossSummoning.cs`

**Ã–zellikler:**
- Ritual malzeme kontrolÃ¼
- Arena gereksinimi kontrolÃ¼
- Boss spawn entegrasyonu

---

### 1.12.7 Dosya YapÄ±sÄ±

```
_Stratocraft/
â”œâ”€â”€ Data/
â”‚   â””â”€â”€ Bosses/
â”‚       â”œâ”€â”€ BossArenaDefinition.cs
â”‚       â””â”€â”€ BossLootTableDefinition.cs
â”‚
â”œâ”€â”€ Scripts/
â”‚   â””â”€â”€ Systems/
â”‚       â””â”€â”€ Bosses/
â”‚           â”œâ”€â”€ DragonAI.cs
â”‚           â”œâ”€â”€ BossArena.cs
â”‚           â”œâ”€â”€ BossLootTable.cs
â”‚           â”œâ”€â”€ BossPhaseSystem.cs
â”‚           â””â”€â”€ BossSummoning.cs
```

---

## ğŸ› ï¸ ADIM 1.13: Ã–ZEL CANLI TÄ°PLERÄ°

> **âœ… YENÄ° SÄ°STEM:** Goblin, ork, troll gibi Ã¶zel canlÄ± tipleri ve sÄ±nÄ±f sistemi.  
> **Entegrasyon:** MobAI, StatusEffectManager, ChunkManager, ServiceLocator  
> **Faz:** 5 (Yapay Zeka, SavaÅŸ ve Felaketler)

### 1.13.1 Sistem Genel BakÄ±ÅŸ

**AmaÃ§:**
Goblin, ork, troll gibi Ã¶zel canlÄ± tipleri ve sÄ±nÄ±f sistemi eklemek.

**Temel Ã–zellikler:**
1. **Mob Classes:** Warrior, Mage, Archer, vb.
2. **Mob Abilities:** Ã–zel yetenekler
3. **Mob Armor:** ZÄ±rh sistemi
4. **Mob Leveling:** Seviye sistemi
5. **Mob Trading:** Ticaret sistemi

---

### 1.13.2 MobClassDefinition.cs - Mob SÄ±nÄ±f TanÄ±mlarÄ±

**Dosya:** `_Stratocraft/Data/Mobs/MobClassDefinition.cs`

**Ã–zellikler:**
- Stat multiplier'larÄ±
- SÄ±nÄ±f bazlÄ± yetenekler
- Default zÄ±rh

---

### 1.13.3 MobAbilitySystem.cs - Mob Yetenek Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Mobs/MobAbilitySystem.cs`

**Ã–zellikler:**
- Cooldown sistemi
- Melee, Ranged, Area, Heal, Buff, Debuff yetenekleri
- Level scaling

---

### 1.13.4 MobArmorSystem.cs - Mob ZÄ±rh Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Mobs/MobArmorSystem.cs`

**Ã–zellikler:**
- Hasar azaltma sistemi
- ZÄ±rh yÄ±pranma mekaniÄŸi

---

### 1.13.5 MobLeveling.cs - Mob Seviye Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Mobs/MobLeveling.cs`

**Ã–zellikler:**
- Experience sistemi
- Level bazlÄ± stat artÄ±ÅŸlarÄ±

---

### 1.13.6 Dosya YapÄ±sÄ±

```
_Stratocraft/
â”œâ”€â”€ Data/
â”‚   â””â”€â”€ Mobs/
â”‚       â”œâ”€â”€ MobClassDefinition.cs
â”‚       â””â”€â”€ MobArmorDefinition.cs
â”‚
â”œâ”€â”€ Scripts/
â”‚   â””â”€â”€ Systems/
â”‚       â””â”€â”€ Mobs/
â”‚           â”œâ”€â”€ MobAbilitySystem.cs
â”‚           â”œâ”€â”€ MobArmorSystem.cs
â”‚           â””â”€â”€ MobLeveling.cs
```

---

## ğŸ› ï¸ ADIM 1.14: YEMEK VE AÃ‡LIK SÄ°STEMÄ°

> **âœ… YENÄ° SÄ°STEM:** Yemek, aÃ§lÄ±k, piÅŸirme ve yemek kalitesi sistemi.  
> **Entegrasyon:** PlayerInventory, StatusEffectManager, DatabaseManager, ServiceLocator  
> **Faz:** 4 (Oyun Mekanikleri)

### 1.14.1 Sistem Genel BakÄ±ÅŸ

**AmaÃ§:**
Yemek, aÃ§lÄ±k, piÅŸirme ve yemek kalitesi sistemi eklemek.

**Temel Ã–zellikler:**
1. **Hunger System:** AÃ§lÄ±k barÄ±
2. **Food System:** Yemek sistemi
3. **Cooking System:** PiÅŸirme sistemi
4. **Food Quality:** Yemek kalitesi
5. **Food Buffs:** Yemek buff'larÄ±

---

### 1.14.2 FoodDefinition.cs - Yemek TanÄ±mlarÄ±

**Dosya:** `_Stratocraft/Data/Food/FoodDefinition.cs`

**Ã–zellikler:**
- Hunger restore deÄŸeri
- Health restore deÄŸeri
- Food quality sistemi
- Food buff'larÄ±

---

### 1.14.3 HungerSystem.cs - AÃ§lÄ±k Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Food/HungerSystem.cs`

**Ã–zellikler:**
- Coroutine ile hunger decrease
- Async database persistence
- AÃ§lÄ±k durumuna gÃ¶re can azaltma

---

### 1.14.4 CookingStation.cs - PiÅŸirme Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Food/CookingStation.cs`

**Ã–zellikler:**
- Cooking recipe sistemi
- Cooking time kontrolÃ¼
- Malzeme kontrolÃ¼

---

### 1.14.5 CookingRecipe.cs - PiÅŸirme Tarifleri

**Dosya:** `_Stratocraft/Data/Food/CookingRecipe.cs`

**Ã–zellikler:**
- Malzeme listesi
- PiÅŸirme sÃ¼resi
- Cooking station seviye gereksinimi

---

### 1.14.6 Dosya YapÄ±sÄ±

```
_Stratocraft/
â”œâ”€â”€ Data/
â”‚   â””â”€â”€ Food/
â”‚       â”œâ”€â”€ FoodDefinition.cs
â”‚       â””â”€â”€ CookingRecipe.cs
â”‚
â”œâ”€â”€ Scripts/
â”‚   â””â”€â”€ Systems/
â”‚       â””â”€â”€ Food/
â”‚           â”œâ”€â”€ HungerSystem.cs
â”‚           â””â”€â”€ CookingStation.cs
```

---

## ğŸ› ï¸ ADIM 1.15: HASTALIK VE DURUM SÄ°STEMÄ°

> **âœ… YENÄ° SÄ°STEM:** HastalÄ±k, durum efektleri (poison, burn) ve iyileÅŸtirme sistemi.  
> **Entegrasyon:** StatusEffectManager, HealthComponent, MovementController, ServiceLocator  
> **Faz:** 4 (Oyun Mekanikleri)

### 1.15.1 Sistem Genel BakÄ±ÅŸ

**AmaÃ§:**
HastalÄ±k, durum efektleri (poison, burn) ve iyileÅŸtirme sistemi eklemek.

**Temel Ã–zellikler:**
1. **Status Effects:** Poison, Burn, Freeze, Slow, vb.
2. **Disease System:** HastalÄ±k sistemi
3. **Cure Items:** Ä°yileÅŸtirme item'larÄ±
4. **Status Stacking:** Stack sistemi
5. **Status UI:** Durum gÃ¶stergeleri

---

### 1.15.2 StatusEffectDefinition.cs - Durum Efekt TanÄ±mlarÄ±

**Dosya:** `_Stratocraft/Data/StatusEffects/StatusEffectDefinition.cs`

**Ã–zellikler:**
- Stat modifikasyonlarÄ± (speed, damage, defense multipliers)
- Stack sistemi
- Duration ve damage per second

---

### 1.15.3 StatusEffectManager.cs - Durum Efekt YÃ¶neticisi

**Dosya:** `_Stratocraft/Scripts/Systems/StatusEffects/StatusEffectManager.cs`

**Ã–zellikler:**
- Coroutine ile effect update
- Stack sistemi
- Particle effect entegrasyonu

---

### 1.15.4 DiseaseSystem.cs - HastalÄ±k Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/StatusEffects/DiseaseSystem.cs`

**Ã–zellikler:**
- Disease state cache
- Cure item kontrolÃ¼
- StatusEffectManager entegrasyonu

---

### 1.15.5 Dosya YapÄ±sÄ±

```
_Stratocraft/
â”œâ”€â”€ Data/
â”‚   â””â”€â”€ StatusEffects/
â”‚       â”œâ”€â”€ StatusEffectDefinition.cs
â”‚       â”œâ”€â”€ DiseaseDefinition.cs
â”‚       â””â”€â”€ CureItemDefinition.cs
â”‚
â”œâ”€â”€ Scripts/
â”‚   â””â”€â”€ Systems/
â”‚       â””â”€â”€ StatusEffects/
â”‚           â”œâ”€â”€ StatusEffectManager.cs
â”‚           â””â”€â”€ DiseaseSystem.cs
```

---

## ğŸ› ï¸ ADIM 1.16: ZAMAN VE HAVA SÄ°STEMÄ°

> **âœ… YENÄ° SÄ°STEM:** Hava durumu, mevsimler ve sÄ±caklÄ±k sistemi.  
> **Entegrasyon:** GameTimeManager, ChunkManager, StatusEffectManager, ServiceLocator  
> **Faz:** 4 (Oyun Mekanikleri)

### 1.16.1 Sistem Genel BakÄ±ÅŸ

**AmaÃ§:**
Hava durumu, mevsimler ve sÄ±caklÄ±k sistemi eklemek.

**Temel Ã–zellikler:**
1. **Weather System:** Rain, snow, storm, fog
2. **Season System:** Spring, summer, autumn, winter
3. **Temperature System:** SÄ±caklÄ±k sistemi
4. **Weather Effects:** GÃ¶rsel ve ses efektleri

---

### 1.16.2 WeatherSystem.cs - Hava Durumu Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Weather/WeatherSystem.cs`

**Ã–zellikler:**
- Coroutine ile weather change
- Mevsim bazlÄ± hava durumu ÅŸansÄ±
- Chunk bazlÄ± weather cache

---

### 1.16.3 SeasonSystem.cs - Mevsim Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Weather/SeasonSystem.cs`

**Ã–zellikler:**
- GameTimeManager entegrasyonu
- Mevsim sÃ¼releri
- Mevsim geÃ§iÅŸleri

---

### 1.16.4 TemperatureSystem.cs - SÄ±caklÄ±k Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Weather/TemperatureSystem.cs`

**Ã–zellikler:**
- Mevsim bazlÄ± sÄ±caklÄ±k
- Hava durumu bazlÄ± sÄ±caklÄ±k
- YÃ¼kseklik bazlÄ± sÄ±caklÄ±k (ChunkManager entegrasyonu)
- SÄ±caklÄ±k bazlÄ± status effect'ler

---

### 1.16.5 WeatherEffects.cs - Hava Durumu Efektleri

**Dosya:** `_Stratocraft/Scripts/Systems/Weather/WeatherEffects.cs`

**Ã–zellikler:**
- Unity Particle System entegrasyonu
- Unity Audio entegrasyonu
- Weather bazlÄ± efektler

---

### 1.16.6 Dosya YapÄ±sÄ±

```
_Stratocraft/
â”œâ”€â”€ Scripts/
â”‚   â””â”€â”€ Systems/
â”‚       â””â”€â”€ Weather/
â”‚           â”œâ”€â”€ WeatherSystem.cs
â”‚           â”œâ”€â”€ SeasonSystem.cs
â”‚           â”œâ”€â”€ TemperatureSystem.cs
â”‚           â””â”€â”€ WeatherEffects.cs
```

---

## ğŸ› ï¸ ADIM 1.17: ZÄ°NDAN VE MAÄARA SÄ°STEMÄ°

> **âœ… YENÄ° SÄ°STEM:** Zindan oluÅŸturma, boss, loot ve key sistemi.  
> **Entegrasyon:** ChunkManager, StructurePlacer, BossArena, ServiceLocator  
> **Faz:** 5 (Yapay Zeka, SavaÅŸ ve Felaketler)

### 1.17.1 Sistem Genel BakÄ±ÅŸ

**AmaÃ§:**
Zindan oluÅŸturma, boss, loot ve key sistemi eklemek.

**Temel Ã–zellikler:**
1. **Dungeon Generation:** Zindan oluÅŸturma
2. **Dungeon Boss:** Zindan boss'u
3. **Dungeon Loot:** Loot chest'leri
4. **Dungeon Key:** Key sistemi
5. **Dungeon Difficulty:** Zorluk seviyeleri

---

### 1.17.2 DungeonDefinition.cs - Zindan TanÄ±mlarÄ±

**Dosya:** `_Stratocraft/Data/Dungeons/DungeonDefinition.cs`

**Ã–zellikler:**
- Zindan boyutu
- Boss tanÄ±mÄ±
- Loot chest'leri
- Key gereksinimi

---

### 1.17.3 DungeonGenerator.cs - Zindan OluÅŸturma

**Dosya:** `_Stratocraft/Scripts/Systems/Dungeons/DungeonGenerator.cs`

**Ã–zellikler:**
- Job System + Burst ile dungeon generation
- Oda ve koridor oluÅŸturma
- Chunk bazlÄ± dungeon cache

---

### 1.17.4 DungeonEntrance.cs - Zindan GiriÅŸi

**Dosya:** `_Stratocraft/Scripts/Systems/Dungeons/DungeonEntrance.cs`

**Ã–zellikler:**
- Key kontrolÃ¼
- DungeonGenerator entegrasyonu
- IInteractable interface

---

### 1.17.5 Dosya YapÄ±sÄ±

```
_Stratocraft/
â”œâ”€â”€ Data/
â”‚   â””â”€â”€ Dungeons/
â”‚       â””â”€â”€ DungeonDefinition.cs
â”‚
â”œâ”€â”€ Scripts/
â”‚   â””â”€â”€ Systems/
â”‚       â””â”€â”€ Dungeons/
â”‚           â”œâ”€â”€ DungeonGenerator.cs
â”‚           â””â”€â”€ DungeonEntrance.cs
```

---

## ğŸ› ï¸ ADIM 1.18: MAGIC VE BÃœYÃœ SÄ°STEMÄ°

> **âœ… YENÄ° SÄ°STEM:** BÃ¼yÃ¼ sistemi, bÃ¼yÃ¼ kitaplarÄ± ve mana sistemi.  
> **Entegrasyon:** ManaSystem, ItemDatabase, ChunkManager, ServiceLocator  
> **Faz:** 4 (Oyun Mekanikleri)

### 1.18.1 Sistem Genel BakÄ±ÅŸ

**AmaÃ§:**
BÃ¼yÃ¼ sistemi, bÃ¼yÃ¼ kitaplarÄ± ve mana sistemi eklemek.

**Temel Ã–zellikler:**
1. **Spell System:** BÃ¼yÃ¼ sistemi
2. **Spell Books:** BÃ¼yÃ¼ kitaplarÄ±
3. **Mana System:** Mana barÄ±
4. **Spell Schools:** Fire, Ice, Lightning, vb.
5. **Spell Levels:** BÃ¼yÃ¼ seviyeleri

---

### 1.18.2 SpellDefinition.cs - BÃ¼yÃ¼ TanÄ±mlarÄ±

**Dosya:** `_Stratocraft/Data/Spells/SpellDefinition.cs`

**Ã–zellikler:**
- Spell school (Fire, Ice, Lightning, vb.)
- Mana cost
- Cast time ve cooldown
- Damage ve range

---

### 1.18.3 ManaSystem.cs - Mana Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Magic/ManaSystem.cs`

**Ã–zellikler:**
- Coroutine ile mana regeneration
- Async database persistence
- Mana kullanÄ±m kontrolÃ¼

---

### 1.18.4 SpellCasting.cs - BÃ¼yÃ¼ Kullanma

**Dosya:** `_Stratocraft/Scripts/Systems/Magic/SpellCasting.cs`

**Ã–zellikler:**
- ManaSystem entegrasyonu
- Spell effect spawn
- Cast animation

---

### 1.18.5 Dosya YapÄ±sÄ±

```
_Stratocraft/
â”œâ”€â”€ Data/
â”‚   â””â”€â”€ Spells/
â”‚       â””â”€â”€ SpellDefinition.cs
â”‚
â”œâ”€â”€ Scripts/
â”‚   â””â”€â”€ Systems/
â”‚       â””â”€â”€ Magic/
â”‚           â”œâ”€â”€ ManaSystem.cs
â”‚           â””â”€â”€ SpellCasting.cs
```

---

## ğŸ› ï¸ ADIM 1.19: TEKNOLOJÄ° AÄACI (Tech Tree)

> **âœ… YENÄ° SÄ°STEM:** Teknoloji aÄŸacÄ±, unlock sistemi ve baÄŸÄ±mlÄ±lÄ±klar.  
> **Entegrasyon:** ResearchManager, DatabaseManager, ServiceLocator  
> **Faz:** 8 (Eksik Sistemler, Admin KomutlarÄ±)

### 1.19.1 Sistem Genel BakÄ±ÅŸ

**AmaÃ§:**
Teknoloji aÄŸacÄ±, unlock sistemi ve baÄŸÄ±mlÄ±lÄ±klar eklemek.

**Temel Ã–zellikler:**
1. **Tech Tree UI:** Teknoloji aÄŸacÄ± arayÃ¼zÃ¼
2. **Tech Unlock:** Unlock sistemi
3. **Tech Prerequisites:** BaÄŸÄ±mlÄ±lÄ±klar
4. **Research Points:** AraÅŸtÄ±rma puanlarÄ±
5. **Tech Categories:** Kategoriler

---

### 1.19.2 TechNodeDefinition.cs - Teknoloji DÃ¼ÄŸÃ¼m TanÄ±mlarÄ±

**Dosya:** `_Stratocraft/Data/Tech/TechNodeDefinition.cs`

**Ã–zellikler:**
- Prerequisite teknolojiler
- Research point gereksinimi
- Tech kategorisi

---

### 1.19.3 TechTreeManager.cs - Teknoloji AÄŸacÄ± YÃ¶neticisi

**Dosya:** `_Stratocraft/Scripts/Systems/Tech/TechTreeManager.cs`

**Ã–zellikler:**
- Tech unlock sistemi
- Prerequisite kontrolÃ¼
- Research point sistemi

---

### 1.19.4 Dosya YapÄ±sÄ±

```
_Stratocraft/
â”œâ”€â”€ Data/
â”‚   â””â”€â”€ Tech/
â”‚       â””â”€â”€ TechNodeDefinition.cs
â”‚
â”œâ”€â”€ Scripts/
â”‚   â””â”€â”€ Systems/
â”‚       â””â”€â”€ Tech/
â”‚           â””â”€â”€ TechTreeManager.cs
```

---

## ğŸ› ï¸ ADIM 1.20: ARAÃ‡ VE ULAÅIM SÄ°STEMÄ°

> **âœ… YENÄ° SÄ°STEM:** Carts, boats, airships gibi araÃ§lar ve ulaÅŸÄ±m sistemi.  
> **Entegrasyon:** ChunkManager, PlayerInventory, ServiceLocator  
> **Faz:** 7 (GÃ¼Ã§ Sistemi, Binekler ve SavaÅŸ Makineleri)

### 1.20.1 Sistem Genel BakÄ±ÅŸ

**AmaÃ§:**
Carts, boats, airships gibi araÃ§lar ve ulaÅŸÄ±m sistemi eklemek.

**Temel Ã–zellikler:**
1. **Vehicles:** Carts, boats, airships
2. **Vehicle Controls:** Kontrol sistemi
3. **Vehicle Inventory:** AraÃ§ envanteri
4. **Vehicle Fuel:** YakÄ±t sistemi
5. **Vehicle Repair:** Tamir sistemi

---

### 1.20.2 VehicleDefinition.cs - AraÃ§ TanÄ±mlarÄ±

**Dosya:** `_Stratocraft/Data/Vehicles/VehicleDefinition.cs`

**Ã–zellikler:**
- AraÃ§ tipi (Cart, Boat, Airship)
- Envanter slot sayÄ±sÄ±
- YakÄ±t tÃ¼ketimi
- HÄ±z ve dayanÄ±klÄ±lÄ±k

---

### 1.20.3 VehicleController.cs - AraÃ§ KontrolÃ¼

**Dosya:** `_Stratocraft/Scripts/Systems/Vehicles/VehicleController.cs`

**Ã–zellikler:**
- Unity Physics entegrasyonu
- Kontrol sistemi
- YakÄ±t tÃ¼ketimi

---

### 1.20.4 Dosya YapÄ±sÄ±

```
_Stratocraft/
â”œâ”€â”€ Data/
â”‚   â””â”€â”€ Vehicles/
â”‚       â””â”€â”€ VehicleDefinition.cs
â”‚
â”œâ”€â”€ Scripts/
â”‚   â””â”€â”€ Systems/
â”‚       â””â”€â”€ Vehicles/
â”‚           â””â”€â”€ VehicleController.cs
```

---

## ğŸ› ï¸ ADIM 1.21: PET VE EV HAYVANI SÄ°STEMÄ°

> **âœ… YENÄ° SÄ°STEM:** Companion pet'ler, pet envanteri ve komut sistemi.  
> **Entegrasyon:** MobAI, PlayerInventory, DatabaseManager, ServiceLocator  
> **Faz:** 5 (Yapay Zeka, SavaÅŸ ve Felaketler)

### 1.21.1 Sistem Genel BakÄ±ÅŸ

**AmaÃ§:**
Companion pet'ler, pet envanteri ve komut sistemi eklemek.

**Temel Ã–zellikler:**
1. **Pet System:** Companion pet'ler
2. **Pet Inventory:** Pet envanteri
3. **Pet Leveling:** Pet seviye sistemi
4. **Pet Commands:** Komut sistemi
5. **Pet Abilities:** Pet yetenekleri

---

### 1.21.2 PetDefinition.cs - Pet TanÄ±mlarÄ±

**Dosya:** `_Stratocraft/Data/Pets/PetDefinition.cs`

**Ã–zellikler:**
- Pet tipi
- Pet yetenekleri
- Pet envanter slot sayÄ±sÄ±

---

### 1.21.3 PetSystem.cs - Pet Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Pets/PetSystem.cs`

**Ã–zellikler:**
- Pet spawn sistemi
- Pet komut sistemi
- Pet leveling sistemi

---

### 1.21.4 Dosya YapÄ±sÄ±

```
_Stratocraft/
â”œâ”€â”€ Data/
â”‚   â””â”€â”€ Pets/
â”‚       â””â”€â”€ PetDefinition.cs
â”‚
â”œâ”€â”€ Scripts/
â”‚   â””â”€â”€ Systems/
â”‚       â””â”€â”€ Pets/
â”‚           â””â”€â”€ PetSystem.cs
```

---

## ğŸ› ï¸ ADIM 1.22: TARIM VE Ã‡Ä°FTÃ‡Ä°LÄ°K SÄ°STEMÄ°

> **âœ… YENÄ° SÄ°STEM:** Crop planting, seeds, harvest ve farming tools sistemi.  
> **Entegrasyon:** ChunkManager, PlayerInventory, GameTimeManager, ServiceLocator  
> **Faz:** 4 (Oyun Mekanikleri)

### 1.22.1 Sistem Genel BakÄ±ÅŸ

**AmaÃ§:**
Crop planting, seeds, harvest ve farming tools sistemi eklemek.

**Temel Ã–zellikler:**
1. **Crop System:** Bitki sistemi
2. **Seed System:** Tohum sistemi
3. **Growth System:** BÃ¼yÃ¼me sistemi
4. **Harvest System:** Hasat sistemi
5. **Fertilizer System:** GÃ¼bre sistemi

---

### 1.22.2 CropDefinition.cs - Bitki TanÄ±mlarÄ±

**Dosya:** `_Stratocraft/Data/Crops/CropDefinition.cs`

**Ã–zellikler:**
- BÃ¼yÃ¼me aÅŸamalarÄ±
- BÃ¼yÃ¼me sÃ¼resi
- Hasat sonucu

---

### 1.22.3 FarmingSystem.cs - Ã‡iftÃ§ilik Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Farming/FarmingSystem.cs`

**Ã–zellikler:**
- Crop planting
- Growth coroutine
- Harvest sistemi

---

### 1.22.4 Dosya YapÄ±sÄ±

```
_Stratocraft/
â”œâ”€â”€ Data/
â”‚   â””â”€â”€ Crops/
â”‚       â””â”€â”€ CropDefinition.cs
â”‚
â”œâ”€â”€ Scripts/
â”‚   â””â”€â”€ Systems/
â”‚       â””â”€â”€ Farming/
â”‚           â””â”€â”€ FarmingSystem.cs
```

---

## ğŸ› ï¸ ADIM 1.23: BALIKÃ‡ILIK SÄ°STEMÄ°

> **âœ… YENÄ° SÄ°STEM:** Fishing mechanics, fishing rod ve fish types sistemi.  
> **Entegrasyon:** PlayerInventory, ChunkManager, ServiceLocator  
> **Faz:** 4 (Oyun Mekanikleri)

### 1.23.1 Sistem Genel BakÄ±ÅŸ

**AmaÃ§:**
Fishing mechanics, fishing rod ve fish types sistemi eklemek.

**Temel Ã–zellikler:**
1. **Fishing Mechanics:** BalÄ±k tutma mekaniÄŸi
2. **Fishing Rod:** Olta sistemi
3. **Fish Types:** BalÄ±k tipleri
4. **Fishing Spots:** BalÄ±k tutma noktalarÄ±
5. **Fishing Rewards:** Ã–dÃ¼l sistemi

---

### 1.23.2 FishDefinition.cs - BalÄ±k TanÄ±mlarÄ±

**Dosya:** `_Stratocraft/Data/Fish/FishDefinition.cs`

**Ã–zellikler:**
- BalÄ±k tipi
- Yakalanma ÅŸansÄ±
- Ã–dÃ¼l item'larÄ±

---

### 1.23.3 FishingSystem.cs - BalÄ±kÃ§Ä±lÄ±k Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Fishing/FishingSystem.cs`

**Ã–zellikler:**
- Fishing minigame
- Fish spawn sistemi
- Reward sistemi

---

### 1.23.4 Dosya YapÄ±sÄ±

```
_Stratocraft/
â”œâ”€â”€ Data/
â”‚   â””â”€â”€ Fish/
â”‚       â””â”€â”€ FishDefinition.cs
â”‚
â”œâ”€â”€ Scripts/
â”‚   â””â”€â”€ Systems/
â”‚       â””â”€â”€ Fishing/
â”‚           â””â”€â”€ FishingSystem.cs
```

---

## ğŸ› ï¸ ADIM 1.24: MADENCÄ°LÄ°K VE ERÄ°TME SÄ°STEMÄ°

> **âœ… YENÄ° SÄ°STEM:** Smelting mechanics, furnaces, fuel ve smelting recipes sistemi.  
> **Entegrasyon:** PlayerInventory, ItemDatabase, ServiceLocator  
> **Faz:** 4 (Oyun Mekanikleri)

### 1.24.1 Sistem Genel BakÄ±ÅŸ

**AmaÃ§:**
Smelting mechanics, furnaces, fuel ve smelting recipes sistemi eklemek.

**Temel Ã–zellikler:**
1. **Smelting System:** Eritme sistemi
2. **Furnace System:** FÄ±rÄ±n sistemi
3. **Fuel System:** YakÄ±t sistemi
4. **Smelting Recipes:** Eritme tarifleri
5. **Smelting Time:** Eritme sÃ¼resi

---

### 1.24.2 SmeltingRecipe.cs - Eritme Tarifleri

**Dosya:** `_Stratocraft/Data/Recipes/Smelting/SmeltingRecipe.cs`

**Ã–zellikler:**
- Input item
- Output item
- Fuel gereksinimi
- Smelting time

---

### 1.24.3 SmeltingSystem.cs - Eritme Sistemi

**Dosya:** `_Stratocraft/Scripts/Systems/Smelting/SmeltingSystem.cs`

**Ã–zellikler:**
- Furnace entegrasyonu
- Fuel tÃ¼ketimi
- Coroutine ile smelting time

---

### 1.24.4 Dosya YapÄ±sÄ±

```
_Stratocraft/
â”œâ”€â”€ Data/
â”‚   â””â”€â”€ Recipes/
â”‚       â””â”€â”€ Smelting/
â”‚           â””â”€â”€ SmeltingRecipe.cs
â”‚
â”œâ”€â”€ Scripts/
â”‚   â””â”€â”€ Systems/
â”‚       â””â”€â”€ Smelting/
â”‚           â””â”€â”€ SmeltingSystem.cs
```

---

## ğŸ› ï¸ ADIM 1.25: DEPOLAMA VE SANDIK SÄ°STEMÄ°

> **âœ… YENÄ° SÄ°STEM:** Chests, chest inventory, locking ve kategoriler sistemi.  
> **Entegrasyon:** PlayerInventory, TerritoryManager, ServiceLocator  
> **Faz:** 4 (Oyun Mekanikleri)

### 1.25.1 Sistem Genel BakÄ±ÅŸ

**AmaÃ§:**
Chests, chest inventory, locking ve kategoriler sistemi eklemek.

**Temel Ã–zellikler:**
1. **Chest System:** SandÄ±k sistemi
2. **Chest Inventory:** SandÄ±k envanteri
3. **Chest Locking:** Kilit sistemi
4. **Chest Categories:** Kategoriler
5. **Chest UI:** SandÄ±k arayÃ¼zÃ¼

---

### 1.25.2 ChestDefinition.cs - SandÄ±k TanÄ±mlarÄ±

**Dosya:** `_Stratocraft/Data/Chests/ChestDefinition.cs`

**Ã–zellikler:**
- Envanter slot sayÄ±sÄ±
- Kilit desteÄŸi
- Kategori sistemi

---

### 1.25.3 ChestInventory.cs - SandÄ±k Envanteri

**Dosya:** `_Stratocraft/Scripts/Systems/Storage/ChestInventory.cs`

**Ã–zellikler:**
- SyncList ile network synchronization
- Async database persistence
- Lock sistemi

---

### 1.25.4 Dosya YapÄ±sÄ±

```
_Stratocraft/
â”œâ”€â”€ Data/
â”‚   â””â”€â”€ Chests/
â”‚       â””â”€â”€ ChestDefinition.cs
â”‚
â”œâ”€â”€ Scripts/
â”‚   â””â”€â”€ Systems/
â”‚       â””â”€â”€ Storage/
â”‚           â””â”€â”€ ChestInventory.cs
```

---

## ğŸ”¥ ADIM 2: RÄ°TÃœEL SÄ°STEMÄ° (MÃ¼hendislik BÃ¼yÃ¼sÃ¼)

### 2.1 RitualRecipe.cs (ScriptableObject)

**Dosya:** `_Stratocraft/Scripts/Core/Definitions/RitualRecipe.cs`

**AmaÃ§:** RitÃ¼el tariflerini tanÄ±mlamak (Java'daki BlockRecipe ve StructureRecipeManager eÅŸdeÄŸeri)

**Kod:**

```csharp
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// âœ… Data-Driven Ritual System - ScriptableObject tabanlÄ± ritÃ¼el tarifleri
/// Java'daki BlockRecipe ve StructureRecipeManager'Ä±n Unity eÅŸdeÄŸeri
/// </summary>
[CreateAssetMenu(fileName = "New Ritual", menuName = "Stratocraft/Data/Ritual Recipe", order = 2)]
public class RitualRecipe : ScriptableObject {
    [Header("Kimlik")]
    [Tooltip("RitÃ¼el adÄ±")]
    public string ritualName = "Unknown Ritual";
    
    [Tooltip("AÃ§Ä±klama")]
    [TextArea(3, 5)]
    public string description = "";

    [Header("Gereksinimler")]
    [Tooltip("Gereken eÅŸyalar ve miktarlarÄ±")]
    public List<RitualIngredient> ingredients = new List<RitualIngredient>();
    
    [Tooltip("RitÃ¼el yarÄ±Ã§apÄ± (fiziksel tarama mesafesi)")]
    [Range(1f, 10f)]
    public float scanRadius = 4f;
    
    [Tooltip("Åekil Ã¶nemli mi? (true = belirli ÅŸekilde dizilmeli)")]
    public bool requiresShape = false;
    
    [Tooltip("Åekil tanÄ±mÄ± (requiresShape = true ise)")]
    public RitualShape shape;

    [Header("SonuÃ§")]
    [Tooltip("RitÃ¼el baÅŸarÄ±lÄ± olduÄŸunda oluÅŸacak prefab")]
    public GameObject resultPrefab;
    
    [Tooltip("RitÃ¼el sÃ¼resi (saniye)")]
    [Range(0.1f, 60f)]
    public float craftTime = 3f;
    
    [Tooltip("RitÃ¼el enerji rengi")]
    public Color ritualColor = Color.white;

    [Header("Efektler")]
    [Tooltip("RitÃ¼el baÅŸladÄ±ÄŸÄ±nda oynatÄ±lacak efekt")]
    public GameObject startEffectPrefab;
    
    [Tooltip("RitÃ¼el tamamlandÄ±ÄŸÄ±nda oynatÄ±lacak efekt")]
    public GameObject completeEffectPrefab;
    
    [Tooltip("RitÃ¼el baÅŸarÄ±sÄ±z olduÄŸunda oynatÄ±lacak efekt")]
    public GameObject failEffectPrefab;

    /// <summary>
    /// âœ… RitÃ¼el gereksinimlerini kontrol et
    /// </summary>
    public bool CheckRequirements(List<PhysicalItem> itemsOnFloor) {
        if (itemsOnFloor == null || itemsOnFloor.Count == 0) return false;
        
        // âœ… Her gereksinim iÃ§in kontrol et
        foreach (var ingredient in ingredients) {
            int requiredCount = ingredient.amount;
            int foundCount = 0;
            
            foreach (var item in itemsOnFloor) {
                if (item.GetItemID() == ingredient.item.itemID) {
                    foundCount += item.stackSize;
                }
            }
            
            if (foundCount < requiredCount) {
                return false; // Yeterli malzeme yok
            }
        }
        
        // âœ… Åekil kontrolÃ¼ (gerekirse)
        if (requiresShape && shape != null) {
            return shape.CheckShape(itemsOnFloor);
        }
        
        return true;
    }
}

/// <summary>
/// âœ… RitÃ¼el gereksinimi (eÅŸya + miktar)
/// </summary>
[System.Serializable]
public class RitualIngredient {
    [Tooltip("Gereken eÅŸya")]
    public ItemDefinition item;
    
    [Tooltip("Gereken miktar")]
    [Range(1, 999)]
    public int amount = 1;
}

/// <summary>
/// âœ… RitÃ¼el ÅŸekli (belirli geometrik dÃ¼zen)
/// </summary>
[System.Serializable]
public class RitualShape {
    [Tooltip("Åekil tipi")]
    public ShapeType type = ShapeType.Circle;
    
    [Tooltip("Åekil boyutu")]
    public float size = 3f;
    
    public enum ShapeType {
        Circle,     // Daire
        Triangle,   // ÃœÃ§gen
        Square,     // Kare
        Line,       // Ã‡izgi
        Custom      // Ã–zel (Vector3 listesi)
    }
    
    [Tooltip("Ã–zel ÅŸekil pozisyonlarÄ± (Custom iÃ§in)")]
    public List<Vector3> customPositions = new List<Vector3>();
    
    /// <summary>
    /// âœ… Åekil kontrolÃ¼
    /// </summary>
    public bool CheckShape(List<PhysicalItem> items) {
        // âœ… Åekil kontrolÃ¼ mantÄ±ÄŸÄ± (ileride geniÅŸletilebilir)
        // Åimdilik basit kontrol
        return items.Count >= 3; // En az 3 eÅŸya olmalÄ±
    }
}
```

---

### 2.2 RitualManager.cs (NetworkBehaviour)

**Dosya:** `_Stratocraft/Scripts/Systems/Rituals/RitualManager.cs`

**AmaÃ§:** RitÃ¼elleri yÃ¶netmek ve iÅŸlemek (Java'daki StructureRecipeManager ve RitualInteractionListener eÅŸdeÄŸeri)

**Kod:**

```csharp
using FishNet.Object;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: RitÃ¼el yÃ¶neticisi - Fiziksel ritÃ¼elleri iÅŸler
/// Java'daki StructureRecipeManager ve RitualInteractionListener'Ä±n Unity eÅŸdeÄŸeri
/// </summary>
public class RitualManager : NetworkBehaviour {
    [Header("Ayarlar")]
    [Tooltip("TÃ¼m ritÃ¼el tarifleri")]
    public List<RitualRecipe> allRecipes = new List<RitualRecipe>();
    
    [Tooltip("VarsayÄ±lan tarama yarÄ±Ã§apÄ±")]
    [Range(1f, 10f)]
    public float defaultScanRadius = 4f;
    
    [Tooltip("RitÃ¼el cooldown (saniye)")]
    [Range(0f, 60f)]
    public float ritualCooldown = 5f;

    // âœ… OPTÄ°MÄ°ZE: Aktif ritÃ¼eller (pozisyon -> ritÃ¼el)
    private Dictionary<Vector3Int, RitualProcess> _activeRituals = new Dictionary<Vector3Int, RitualProcess>();
    
    // âœ… OPTÄ°MÄ°ZE: Cooldown cache (oyuncu -> son ritÃ¼el zamanÄ±)
    private Dictionary<uint, float> _playerCooldowns = new Dictionary<uint, float>();
    
    // âœ… OPTÄ°MÄ°ZE: ChunkManager referansÄ± (voxel terrain entegrasyonu)
    private ChunkManager _chunkManager;

    void Awake() {
        // âœ… ServiceLocator'a kaydet
        ServiceLocator.Instance?.Register<RitualManager>(this);
    }
    
    void Start() {
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        if (_chunkManager == null) {
            Debug.LogWarning("[RitualManager] ChunkManager bulunamadÄ±! Voxel terrain entegrasyonu devre dÄ±ÅŸÄ±.");
        }
    }

    /// <summary>
    /// âœ… Oyuncu ritÃ¼el denemesi yaptÄ±ÄŸÄ±nda Ã§aÄŸrÄ±lÄ±r (E tuÅŸu veya Ã§Ã¶melme)
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void CmdAttemptRitual(Vector3 centerPos, NetworkObject player) {
        if (player == null) return;
        
        // âœ… Cooldown kontrolÃ¼
        uint playerId = player.ObjectId;
        if (_playerCooldowns.ContainsKey(playerId)) {
            float lastRitualTime = _playerCooldowns[playerId];
            if (Time.time - lastRitualTime < ritualCooldown) {
                return; // Cooldown'da
            }
        }
        
        // âœ… Pozisyonu grid'e yuvarla (ritÃ¼el pozisyonu)
        Vector3Int gridPos = new Vector3Int(
            Mathf.FloorToInt(centerPos.x),
            Mathf.FloorToInt(centerPos.y),
            Mathf.FloorToInt(centerPos.z)
        );
        
        // âœ… Zaten aktif ritÃ¼el var mÄ±?
        if (_activeRituals.ContainsKey(gridPos)) {
            return; // Bu pozisyonda zaten ritÃ¼el var
        }
        
        // âœ… 1. Chunk kontrolÃ¼ (voxel terrain iÃ§in)
        if (_chunkManager != null) {
            Vector3Int chunkCoord = _chunkManager.GetChunkCoord(centerPos);
            GameObject chunk = _chunkManager.GetChunk(chunkCoord);
            if (chunk == null) {
                Debug.LogWarning($"[RitualManager] Chunk henÃ¼z yÃ¼klenmedi: {chunkCoord}");
                return; // Chunk yÃ¼klenene kadar bekle
            }
        }
        
        // âœ… 2. EtrafÄ± Tara (Physics.OverlapSphere) - Voxel terrain Ã¼zerinde
        Collider[] hits = Physics.OverlapSphere(centerPos, defaultScanRadius);
        List<PhysicalItem> floorItems = new List<PhysicalItem>();

        foreach (var hit in hits) {
            PhysicalItem item = hit.GetComponent<PhysicalItem>();
            if (item != null) {
                // âœ… Voxel terrain Ã¼zerinde mi kontrol et (opsiyonel)
                // EÅŸyalarÄ±n voxel terrain Ã¼zerinde olmasÄ± gerekir
                floorItems.Add(item);
            }
        }
        
        if (floorItems.Count == 0) {
            return; // Yerde eÅŸya yok
        }
        
        // âœ… 2. Tarifleri Kontrol Et
        RitualRecipe matchedRecipe = null;
        
        foreach (var recipe in allRecipes) {
            if (recipe == null) continue;
            
            if (recipe.CheckRequirements(floorItems)) {
                matchedRecipe = recipe;
                break; // Ä°lk eÅŸleÅŸen tarifi kullan
            }
        }
        
        if (matchedRecipe == null) {
            // âœ… RitÃ¼el bulunamadÄ± - baÅŸarÄ±sÄ±z efekt
            RpcShowRitualFail(centerPos);
            return;
        }
        
        // âœ… 3. RitÃ¼eli BaÅŸlat
        StartCoroutine(ProcessRitual(matchedRecipe, floorItems, centerPos, gridPos, playerId));
        
        // âœ… Cooldown kaydet
        _playerCooldowns[playerId] = Time.time;
    }

    /// <summary>
    /// âœ… RitÃ¼el iÅŸleme (coroutine)
    /// </summary>
    private IEnumerator ProcessRitual(RitualRecipe recipe, List<PhysicalItem> consumedItems, 
                                     Vector3 pos, Vector3Int gridPos, uint playerId) {
        // âœ… RitÃ¼el kaydÄ± oluÅŸtur
        RitualProcess process = new RitualProcess {
            recipe = recipe,
            position = pos,
            startTime = Time.time,
            consumedItems = consumedItems
        };
        _activeRituals[gridPos] = process;
        
        // âœ… BaÅŸlangÄ±Ã§ efektleri
        RpcShowRitualStart(pos, recipe.ritualColor);
        
        // âœ… Malzemeleri iÅŸaretle (gÃ¶rsel olarak)
        foreach (var item in consumedItems) {
            RpcHighlightItem(item.NetworkObject, recipe.ritualColor);
        }
        
        // âœ… RitÃ¼el sÃ¼resi bekle
        yield return new WaitForSeconds(recipe.craftTime);
        
        // âœ… Malzemeleri yok et (server tarafÄ±nda)
        foreach (var item in consumedItems) {
            if (item != null && item.NetworkObject != null) {
                item.NetworkObject.Despawn();
            }
        }
        
        // âœ… Sonucu oluÅŸtur (Batarya, YapÄ±, vb.)
        if (recipe.resultPrefab != null) {
            GameObject result = Instantiate(recipe.resultPrefab, pos, Quaternion.identity);
            
            // âœ… AÄŸ Ã¼zerinden spawn et
            NetworkObject resultNetObj = result.GetComponent<NetworkObject>();
            if (resultNetObj != null) {
                Spawn(resultNetObj);
            }
        }
        
        // âœ… Tamamlanma efektleri
        RpcShowRitualComplete(pos, recipe.ritualColor);
        
        // âœ… RitÃ¼el kaydÄ±nÄ± temizle
        _activeRituals.Remove(gridPos);
    }

    /// <summary>
    /// âœ… RitÃ¼el baÅŸlangÄ±Ã§ efektleri (tÃ¼m clientlara)
    /// </summary>
    [ObserversRpc]
    void RpcShowRitualStart(Vector3 pos, Color color) {
        // âœ… PartikÃ¼l efektleri
        // ParticleSystem veya VFX Graph kullanÄ±labilir
    }

    /// <summary>
    /// âœ… RitÃ¼el tamamlanma efektleri (tÃ¼m clientlara)
    /// </summary>
    [ObserversRpc]
    void RpcShowRitualComplete(Vector3 pos, Color color) {
        // âœ… PartikÃ¼l efektleri
    }

    /// <summary>
    /// âœ… RitÃ¼el baÅŸarÄ±sÄ±z efektleri (tÃ¼m clientlara)
    /// </summary>
    [ObserversRpc]
    void RpcShowRitualFail(Vector3 pos) {
        // âœ… BaÅŸarÄ±sÄ±z efektleri
    }

    /// <summary>
    /// âœ… EÅŸyayÄ± vurgula (ritÃ¼el sÄ±rasÄ±nda)
    /// </summary>
    [ObserversRpc]
    void RpcHighlightItem(NetworkObject itemObj, Color color) {
        if (itemObj == null) return;
        
        // âœ… GÃ¶rsel vurgulama (outline, glow, vb.)
    }
}

/// <summary>
/// âœ… Aktif ritÃ¼el sÃ¼reci
/// </summary>
public class RitualProcess {
    public RitualRecipe recipe;
    public Vector3 position;
    public float startTime;
    public List<PhysicalItem> consumedItems;
}
```

---

### 2.3 RitualInputHandler.cs

**Dosya:** `_Stratocraft/Scripts/Systems/Rituals/RitualInputHandler.cs`

**AmaÃ§:** Oyuncu giriÅŸlerini ritÃ¼el sistemine baÄŸlamak

**Kod:**

```csharp
using FishNet.Object;
using UnityEngine;

/// <summary>
/// âœ… RitÃ¼el giriÅŸ yÃ¶neticisi - Oyuncu giriÅŸlerini ritÃ¼el sistemine baÄŸlar
/// </summary>
public class RitualInputHandler : NetworkBehaviour {
    [Header("Ayarlar")]
    [Tooltip("RitÃ¼el tetikleme tuÅŸu")]
    public KeyCode ritualKey = KeyCode.E;
    
    [Tooltip("RitÃ¼el mesafesi")]
    [Range(1f, 10f)]
    public float ritualRange = 5f;

    private RitualManager _ritualManager;

    void Start() {
        _ritualManager = ServiceLocator.Instance?.Get<RitualManager>();
    }

    void Update() {
        if (!IsOwner) return; // Sadece kendi karakterim
        
        // âœ… RitÃ¼el tuÅŸu kontrolÃ¼
        if (Input.GetKeyDown(ritualKey)) {
            AttemptRitual();
        }
    }

    /// <summary>
    /// âœ… RitÃ¼el denemesi
    /// </summary>
    void AttemptRitual() {
        if (_ritualManager == null) return;
        
        // âœ… Oyuncunun pozisyonu
        Vector3 playerPos = transform.position;
        
        // âœ… RitÃ¼el merkezi (oyuncunun altÄ±)
        Vector3 ritualCenter = playerPos + Vector3.down * 0.5f;
        
        // âœ… Sunucuya istek gÃ¶nder
        _ritualManager.CmdAttemptRitual(ritualCenter, NetworkObject);
    }
}
```

---

## ğŸ° ADIM 3: KLAN VE BÃ–LGE SÄ°STEMÄ° (Flood-Fill)

### 3.1 TerritoryManager.cs (NetworkBehaviour)

**Dosya:** `_Stratocraft/Scripts/Systems/Clans/TerritoryManager.cs`

**AmaÃ§:** Klan kristali koyulduÄŸunda, Ã§itlerle Ã§evrili alanÄ± hesaplayan sistem (Java'daki TerritoryManager ve TerritoryBoundaryManager eÅŸdeÄŸeri)

**Kod:**

```csharp
using FishNet.Object;
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: BÃ¶lge yÃ¶neticisi - Flood-Fill algoritmasÄ± ile gÃ¼venli bÃ¶lge hesaplama
/// Java'daki TerritoryManager ve TerritoryBoundaryManager'Ä±n Unity eÅŸdeÄŸeri
/// </summary>
public class TerritoryManager : NetworkBehaviour {
    [Header("Ayarlar")]
    [Tooltip("Maksimum bÃ¶lge yarÄ±Ã§apÄ±")]
    [Range(10f, 500f)]
    public float maxTerritoryRadius = 100f;
    
    [Tooltip("Ã‡it yÃ¼kseklik toleransÄ±")]
    [Range(1, 20)]
    public int fenceHeightTolerance = 5;
    
    [Tooltip("BÃ¶lge hesaplama async mi? (performans iÃ§in)")]
    public bool asyncCalculation = true;

    // âœ… OPTÄ°MÄ°ZE: BÃ¶lge cache (klan ID -> TerritoryData)
    private Dictionary<string, TerritoryData> _territoryCache = new Dictionary<string, TerritoryData>();
    
    // âœ… OPTÄ°MÄ°ZE: Chunk cache (chunk key -> klan ID)
    private Dictionary<string, string> _chunkTerritoryCache = new Dictionary<string, string>();

    void Awake() {
        // âœ… ServiceLocator'a kaydet
        ServiceLocator.Instance?.Register<TerritoryManager>(this);
    }

    /// <summary>
    /// âœ… Klan kristali koyulduÄŸunda bu fonksiyon Ã§aÄŸrÄ±lÄ±r
    /// </summary>
    [Server]
    public void CalculateTerritory(Vector3 startNode, string clanId) {
        if (string.IsNullOrEmpty(clanId)) return;
        
        // âœ… Async hesaplama (performans iÃ§in)
        if (asyncCalculation) {
            StartCoroutine(CalculateTerritoryAsync(startNode, clanId));
        } else {
            CalculateTerritorySync(startNode, clanId);
        }
    }

    /// <summary>
    /// âœ… OPTÄ°MÄ°ZE: Async bÃ¶lge hesaplama (UI donmasÄ±nÄ± Ã¶nler)
    /// </summary>
    private System.Collections.IEnumerator CalculateTerritoryAsync(Vector3 startNode, string clanId) {
        // âœ… Flood Fill AlgoritmasÄ± (TaÅŸma)
        Queue<Vector3Int> queue = new Queue<Vector3Int>();
        HashSet<Vector3Int> visited = new HashSet<Vector3Int>();
        List<Vector3Int> securedBlocks = new List<Vector3Int>();
        List<Vector3Int> fenceLocations = new List<Vector3Int>();
        
        Vector3Int startPos = new Vector3Int(
            Mathf.FloorToInt(startNode.x),
            Mathf.FloorToInt(startNode.y),
            Mathf.FloorToInt(startNode.z)
        );
        
        queue.Enqueue(startPos);
        visited.Add(startPos);
        
        bool isClosedArea = true;
        int maxIterations = 50000; // Anti-infinite loop
        int iterations = 0;
        int processedThisFrame = 0;
        int maxPerFrame = 1000; // Frame baÅŸÄ±na maksimum iÅŸlem

        while (queue.Count > 0 && iterations < maxIterations) {
            Vector3Int current = queue.Dequeue();
            iterations++;
            processedThisFrame++;
            
            // âœ… Mesafe kontrolÃ¼ (aÃ§Ä±k alan kontrolÃ¼)
            float distance = Vector3Int.Distance(startPos, current);
            if (distance > maxTerritoryRadius) {
                isClosedArea = false;
                break; // Ã‡ok uzak, aÃ§Ä±k alan
            }
            
            // âœ… Ã‡it kontrolÃ¼
            if (IsFence(current, clanId)) {
                fenceLocations.Add(current);
                continue; // SÄ±nÄ±r, devam etme
            }
            
            securedBlocks.Add(current);
            
            // âœ… 6 yÃ¶ne yayÄ±l (3D Flood-Fill)
            Vector3Int[] directions = {
                new Vector3Int(1, 0, 0),   // DoÄŸu
                new Vector3Int(-1, 0, 0),  // BatÄ±
                new Vector3Int(0, 0, 1),   // Kuzey
                new Vector3Int(0, 0, -1),  // GÃ¼ney
                new Vector3Int(0, 1, 0),   // YukarÄ±
                new Vector3Int(0, -1, 0)   // AÅŸaÄŸÄ±
            };
            
            foreach (var dir in directions) {
                Vector3Int neighbor = current + dir;
                
                // âœ… YÃ¼kseklik toleransÄ± kontrolÃ¼
                int heightDiff = Mathf.Abs(neighbor.y - startPos.y);
                if (heightDiff > fenceHeightTolerance) {
                    visited.Add(neighbor);
                    continue; // Tolerans dÄ±ÅŸÄ±nda
                }
                
                if (visited.Contains(neighbor)) continue;
                visited.Add(neighbor);
                
                // âœ… GeÃ§ilebilir blok kontrolÃ¼
                if (IsPassable(neighbor)) {
                    queue.Enqueue(neighbor);
                }
            }
            
            // âœ… Frame limit kontrolÃ¼ (UI donmasÄ±nÄ± Ã¶nler)
            if (processedThisFrame >= maxPerFrame) {
                processedThisFrame = 0;
                yield return null; // Bir frame bekle
            }
        }
        
        // âœ… BÃ¶lge hesaplama tamamlandÄ±
        if (isClosedArea && securedBlocks.Count > 0) {
            // âœ… TerritoryData oluÅŸtur
            TerritoryData territory = new TerritoryData {
                clanId = clanId,
                center = startNode,
                fenceLocations = fenceLocations,
                securedBlocks = securedBlocks,
                radius = CalculateRadius(securedBlocks, startNode)
            };
            
            // âœ… Cache'e ekle
            _territoryCache[clanId] = territory;
            
            // âœ… VeritabanÄ±na kaydet (async)
            SaveTerritoryToDatabase(territory);
            
            Debug.Log($"[TerritoryManager] Klan bÃ¶lgesi oluÅŸturuldu: {clanId}, Blok sayÄ±sÄ±: {securedBlocks.Count}");
        } else {
            Debug.LogWarning($"[TerritoryManager] AÃ§Ä±k alan veya geÃ§ersiz bÃ¶lge: {clanId}");
        }
    }

    /// <summary>
    /// âœ… Sync bÃ¶lge hesaplama (kÃ¼Ã§Ã¼k alanlar iÃ§in)
    /// </summary>
    private void CalculateTerritorySync(Vector3 startNode, string clanId) {
        // âœ… AynÄ± mantÄ±k ama async olmadan (kÃ¼Ã§Ã¼k alanlar iÃ§in)
        // Kod tekrarÄ±nÄ± Ã¶nlemek iÃ§in CalculateTerritoryAsync'i Ã§aÄŸÄ±rabiliriz
        StartCoroutine(CalculateTerritoryAsync(startNode, clanId));
    }

    /// <summary>
    /// âœ… Ã‡it kontrolÃ¼ (belirli pozisyonda klan Ã§iti var mÄ±?)
    /// </summary>
    private bool IsFence(Vector3Int pos, string clanId) {
        // âœ… Physics.OverlapSphere ile Ã§it kontrolÃ¼
        Collider[] colliders = Physics.OverlapSphere(pos, 0.4f);
        
        foreach (var col in colliders) {
            // âœ… ClanFence component'i kontrol et
            ClanFence fence = col.GetComponent<ClanFence>();
            if (fence != null && fence.clanId == clanId) {
                return true;
            }
        }
        
        return false;
    }

    /// <summary>
    /// âœ… GeÃ§ilebilir blok kontrolÃ¼ (hava, su, vb.) - Voxel terrain entegrasyonu
    /// </summary>
    private bool IsPassable(Vector3Int pos) {
        // âœ… OPTÄ°MÄ°ZE: ChunkManager'dan density kontrolÃ¼
        ChunkManager chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        if (chunkManager == null) {
            return true; // ChunkManager yoksa varsayÄ±lan olarak geÃ§ilebilir
        }
        
        // âœ… Chunk koordinatÄ±nÄ± hesapla
        Vector3 worldPos = new Vector3(pos.x, pos.y, pos.z);
        Vector3Int chunkCoord = chunkManager.GetChunkCoord(worldPos);
        
        // âœ… Density data'sÄ±nÄ± al
        float[] densityData = chunkManager.GetDensityDataForChunk(chunkCoord);
        if (densityData == null) {
            return true; // Chunk yÃ¼klenmemiÅŸse geÃ§ilebilir
        }
        
        // âœ… Local voxel koordinatÄ±nÄ± hesapla
        int chunkSize = 32; // ChunkManager'dan alÄ±nabilir
        Vector3Int localPos = new Vector3Int(
            pos.x % chunkSize,
            pos.y % chunkSize,
            pos.z % chunkSize
        );
        
        // âœ… Negatif deÄŸerleri dÃ¼zelt
        if (localPos.x < 0) localPos.x += chunkSize;
        if (localPos.y < 0) localPos.y += chunkSize;
        if (localPos.z < 0) localPos.z += chunkSize;
        
        // âœ… Density index'ini hesapla
        int index = localPos.x + localPos.y * chunkSize + localPos.z * chunkSize * chunkSize;
        
        if (index < 0 || index >= densityData.Length) {
            return true; // SÄ±nÄ±r dÄ±ÅŸÄ±, geÃ§ilebilir
        }
        
        // âœ… Density < 0 ise geÃ§ilebilir (boÅŸ), >= 0 ise dolu (geÃ§ilemez)
        return densityData[index] < 0f;
    }

    /// <summary>
    /// âœ… BÃ¶lge yarÄ±Ã§apÄ±nÄ± hesapla
    /// </summary>
    private float CalculateRadius(List<Vector3Int> blocks, Vector3 center) {
        if (blocks.Count == 0) return 0f;
        
        float maxDistance = 0f;
        foreach (var block in blocks) {
            float distance = Vector3.Distance(block, center);
            if (distance > maxDistance) {
                maxDistance = distance;
            }
        }
        
        return maxDistance;
    }

    /// <summary>
    /// âœ… BÃ¶lge sahibini bul (pozisyondan)
    /// </summary>
    public string GetTerritoryOwner(Vector3 pos) {
        // âœ… OPTÄ°MÄ°ZE: Chunk cache kullan
        Vector3Int chunkPos = new Vector3Int(
            Mathf.FloorToInt(pos.x / 16),
            0,
            Mathf.FloorToInt(pos.z / 16)
        );
        string chunkKey = $"{chunkPos.x};{chunkPos.z}";
        
        if (_chunkTerritoryCache.TryGetValue(chunkKey, out string cachedClanId)) {
            // âœ… Cache'den bulundu, doÄŸrula
            if (_territoryCache.TryGetValue(cachedClanId, out TerritoryData territory)) {
                if (territory.IsInsideTerritory(pos)) {
                    return cachedClanId;
                }
            }
        }
        
        // âœ… Cache miss - TÃ¼m bÃ¶lgeleri kontrol et
        foreach (var kvp in _territoryCache) {
            if (kvp.Value.IsInsideTerritory(pos)) {
                // âœ… Cache'e ekle
                _chunkTerritoryCache[chunkKey] = kvp.Key;
                return kvp.Key;
            }
        }
        
        return null;
    }

    /// <summary>
    /// âœ… BÃ¶lge verisini al
    /// </summary>
    public TerritoryData GetTerritoryData(string clanId) {
        _territoryCache.TryGetValue(clanId, out TerritoryData territory);
        return territory;
    }

    /// <summary>
    /// âœ… BÃ¶lgeyi veritabanÄ±na kaydet (async)
    /// </summary>
    private async void SaveTerritoryToDatabase(TerritoryData territory) {
        DatabaseManager db = ServiceLocator.Instance?.Get<DatabaseManager>();
        if (db != null) {
            await db.SaveTerritoryAsync(territory);
        }
    }
}

/// <summary>
/// âœ… BÃ¶lge verisi (Java'daki TerritoryData eÅŸdeÄŸeri)
/// </summary>
[System.Serializable]
public class TerritoryData {
    public string clanId;
    public Vector3 center;
    public float radius;
    public List<Vector3Int> fenceLocations = new List<Vector3Int>();
    public List<Vector3Int> securedBlocks = new List<Vector3Int>();
    public int minY;
    public int maxY;
    public int skyHeight = 150;
    public int groundDepth = 20;

    /// <summary>
    /// âœ… BÃ¶lge iÃ§inde mi kontrol et (3D)
    /// </summary>
    public bool IsInsideTerritory(Vector3 pos) {
        // âœ… Y ekseni kontrolÃ¼
        if (pos.y < minY - groundDepth || pos.y > maxY + skyHeight) {
            return false;
        }
        
        // âœ… 2D mesafe kontrolÃ¼
        float distance2D = Vector2.Distance(
            new Vector2(pos.x, pos.z),
            new Vector2(center.x, center.z)
        );
        
        return distance2D <= radius;
    }
}
```

---

### 3.2 ClanFence.cs

**Dosya:** `_Stratocraft/Scripts/Systems/Clans/ClanFence.cs`

**AmaÃ§:** Klan Ã§iti component'i (Java'daki CustomBlockData.isClanFence eÅŸdeÄŸeri)

**Kod:**

```csharp
using FishNet.Object;
using FishNet.Object.Synchronizing;
using UnityEngine;

/// <summary>
/// âœ… Klan Ã§iti component'i - Fiziksel Ã§it bloÄŸu
/// Java'daki CustomBlockData.isClanFence eÅŸdeÄŸeri
/// </summary>
public class ClanFence : NetworkBehaviour {
    [Header("Klan Verisi")]
    [Tooltip("Klan ID'si (aÄŸ Ã¼zerinden senkronize edilir)")]
    [SyncVar]
    public string clanId = "";

    void Start() {
        // âœ… GÃ¶rsel gÃ¼ncelleme (klan rengi, vb.)
        UpdateVisuals();
    }

    /// <summary>
    /// âœ… GÃ¶rsel gÃ¼ncelleme (klan rengi, glow, vb.)
    /// </summary>
    void UpdateVisuals() {
        // âœ… Klan rengini al ve materyali gÃ¼ncelle
        // ClanManager'dan klan rengini al
    }
}
```

---

## ğŸ“œ ADIM 4: EKONOMÄ° VE KONTRATLAR (Hukuk)

### 4.1 ContractManager.cs (NetworkBehaviour)

**Dosya:** `_Stratocraft/Scripts/Systems/Economy/ContractManager.cs`

**AmaÃ§:** "Code is Law" felsefesini uygulayan kontrat sistemi (Java'daki ContractManager eÅŸdeÄŸeri)

**Kod:**

```csharp
using FishNet.Object;
using UnityEngine;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Kontrat yÃ¶neticisi - SQLite tabanlÄ± kontrat sistemi
/// Java'daki ContractManager'Ä±n Unity eÅŸdeÄŸeri
/// </summary>
public class ContractManager : NetworkBehaviour {
    [Header("Ayarlar")]
    [Tooltip("Kontrat varsayÄ±lan sÃ¼resi (gÃ¼n)")]
    [Range(1, 30)]
    public int defaultContractDays = 7;
    
    [Tooltip("Kontrat Ã¶dÃ¼l Ã§arpanÄ±")]
    [Range(0.1f, 2f)]
    public float rewardMultiplier = 0.5f;

    // âœ… OPTÄ°MÄ°ZE: Aktif kontratlar cache (ID -> ContractData)
    private Dictionary<string, ContractData> _activeContracts = new Dictionary<string, ContractData>();
    
    // âœ… OPTÄ°MÄ°ZE: Oyuncu kontratlarÄ± cache (oyuncu ID -> List<ContractData>)
    private Dictionary<string, List<ContractData>> _playerContracts = new Dictionary<string, List<ContractData>>();

    void Awake() {
        // âœ… ServiceLocator'a kaydet
        ServiceLocator.Instance?.Register<ContractManager>(this);
        
        // âœ… VeritabanÄ±ndan kontratlarÄ± yÃ¼kle (async)
        LoadContractsFromDatabase();
    }

    /// <summary>
    /// âœ… Yeni kontrat oluÅŸtur
    /// </summary>
    [Server]
    public void CreateContract(string employerId, string targetId, ContractType type, int reward) {
        var contract = new ContractData {
            ID = Guid.NewGuid().ToString(),
            EmployerID = employerId,
            TargetID = targetId,
            Type = type,
            RewardGold = reward,
            IsCompleted = false,
            CreatedAt = DateTime.UtcNow,
            Deadline = DateTime.UtcNow.AddDays(defaultContractDays)
        };

        // âœ… Cache'e ekle
        _activeContracts[contract.ID] = contract;
        
        // âœ… Oyuncu cache'ine ekle
        if (!_playerContracts.ContainsKey(employerId)) {
            _playerContracts[employerId] = new List<ContractData>();
        }
        _playerContracts[employerId].Add(contract);
        
        // âœ… Async (Arka planda) kaydet
        SaveContractToDatabase(contract);
        
        Debug.Log($"[ContractManager] Kontrat oluÅŸturuldu: {contract.ID}, Ä°ÅŸveren: {employerId}, Hedef: {targetId}");
    }

    /// <summary>
    /// âœ… Oyun iÃ§i bir olay olduÄŸunda (Biri Ã¶ldÃ¼ÄŸÃ¼nde)
    /// </summary>
    [Server]
    public void OnEntityDeath(string victimID, string killerID) {
        CheckContracts(victimID, killerID);
    }

    /// <summary>
    /// âœ… KontratlarÄ± kontrol et (async)
    /// </summary>
    private async void CheckContracts(string victimID, string killerID) {
        // âœ… VeritabanÄ±ndan "Bu kurban iÃ§in aktif kontrat var mÄ±?" diye sor
        DatabaseManager db = ServiceLocator.Instance?.Get<DatabaseManager>();
        if (db == null) return;
        
        var contracts = await db.QueryContractsAsync($"SELECT * FROM contracts WHERE TargetID = '{victimID}' AND IsCompleted = 0");
        
        foreach (var contract in contracts) {
            if (!contract.IsCompleted) {
                // âœ… Ã–dÃ¼lÃ¼ transfer et
                TransferReward(contract.EmployerID, killerID, contract.RewardGold);
                
                // âœ… KontratÄ± tamamlandÄ± olarak iÅŸaretle
                contract.IsCompleted = true;
                contract.CompletedAt = DateTime.UtcNow;
                
                // âœ… VeritabanÄ±nÄ± gÃ¼ncelle
                await db.UpdateContractAsync(contract);
                
                // âœ… Cache'i gÃ¼ncelle
                _activeContracts[contract.ID] = contract;
                
                Debug.Log($"[ContractManager] Kontrat tamamlandÄ±: {contract.ID}, Ã–dÃ¼l: {contract.RewardGold}");
            }
        }
    }

    /// <summary>
    /// âœ… Ã–dÃ¼l transferi
    /// </summary>
    private void TransferReward(string from, string to, int amount) {
        // âœ… EconomyManager.Transfer(...) Ã§aÄŸÄ±r
        EconomyManager economy = ServiceLocator.Instance?.Get<EconomyManager>();
        if (economy != null) {
            economy.TransferMoney(from, to, amount);
        }
    }

    /// <summary>
    /// âœ… KontratÄ± veritabanÄ±na kaydet (async)
    /// </summary>
    private async void SaveContractToDatabase(ContractData contract) {
        DatabaseManager db = ServiceLocator.Instance?.Get<DatabaseManager>();
        if (db != null) {
            await db.InsertContractAsync(contract);
        }
    }

    /// <summary>
    /// âœ… VeritabanÄ±ndan kontratlarÄ± yÃ¼kle (async)
    /// </summary>
    private async void LoadContractsFromDatabase() {
        DatabaseManager db = ServiceLocator.Instance?.Get<DatabaseManager>();
        if (db == null) return;
        
        var contracts = await db.QueryContractsAsync("SELECT * FROM contracts WHERE IsCompleted = 0");
        
        foreach (var contract in contracts) {
            _activeContracts[contract.ID] = contract;
            
            // âœ… Oyuncu cache'ine ekle
            if (!_playerContracts.ContainsKey(contract.EmployerID)) {
                _playerContracts[contract.EmployerID] = new List<ContractData>();
            }
            _playerContracts[contract.EmployerID].Add(contract);
        }
        
        Debug.Log($"[ContractManager] {contracts.Count} aktif kontrat yÃ¼klendi");
    }

    /// <summary>
    /// âœ… Oyuncunun kontratlarÄ±nÄ± al
    /// </summary>
    public List<ContractData> GetPlayerContracts(string playerId) {
        if (_playerContracts.TryGetValue(playerId, out List<ContractData> contracts)) {
            return contracts;
        }
        return new List<ContractData>();
    }

    /// <summary>
    /// âœ… KontratÄ± al (ID ile)
    /// </summary>
    public ContractData GetContract(string contractId) {
        _activeContracts.TryGetValue(contractId, out ContractData contract);
        return contract;
    }
}

/// <summary>
/// âœ… Kontrat verisi (Java'daki Contract model eÅŸdeÄŸeri)
/// </summary>
[System.Serializable]
public class ContractData {
    public string ID;
    public string EmployerID;
    public string TargetID;
    public ContractType Type;
    public int RewardGold;
    public bool IsCompleted;
    public DateTime CreatedAt;
    public DateTime Deadline;
    public DateTime? CompletedAt;
}

/// <summary>
/// âœ… Kontrat tipi
/// </summary>
public enum ContractType {
    KILL_TARGET,        // Hedef Ã¶ldÃ¼r
    COLLECT_RESOURCE,   // Kaynak topla
    DELIVER_ITEM,       // EÅŸya teslim et
    BUILD_STRUCTURE,    // YapÄ± inÅŸa et
    DEFEND_TERRITORY    // BÃ¶lgeyi koru
}
```

---

### 4.2 DatabaseManager.cs - Contract MetodlarÄ±

**Dosya:** `_Stratocraft/Scripts/Core/DatabaseManager.cs` (yukarÄ±daki koda eklenecek)

**Kod:**

```csharp
// DatabaseManager.cs iÃ§ine eklenecek metodlar

/// <summary>
/// âœ… Kontrat kaydet (async)
/// </summary>
public async Task InsertContractAsync(ContractData contract) {
    // âœ… SQLite async iÅŸlemi
    await Task.Run(() => {
        using (var connection = GetConnection()) {
            using (var cmd = connection.CreateCommand()) {
                cmd.CommandText = @"
                    INSERT INTO contracts (id, employer_id, target_id, type, reward_gold, is_completed, created_at, deadline)
                    VALUES (@id, @employer, @target, @type, @reward, @completed, @created, @deadline)";
                
                cmd.Parameters.AddWithValue("@id", contract.ID);
                cmd.Parameters.AddWithValue("@employer", contract.EmployerID);
                cmd.Parameters.AddWithValue("@target", contract.TargetID);
                cmd.Parameters.AddWithValue("@type", contract.Type.ToString());
                cmd.Parameters.AddWithValue("@reward", contract.RewardGold);
                cmd.Parameters.AddWithValue("@completed", contract.IsCompleted ? 1 : 0);
                cmd.Parameters.AddWithValue("@created", contract.CreatedAt);
                cmd.Parameters.AddWithValue("@deadline", contract.Deadline);
                
                cmd.ExecuteNonQuery();
            }
        }
    });
}

/// <summary>
/// âœ… Kontrat sorgula (async)
/// </summary>
public async Task<List<ContractData>> QueryContractsAsync(string query) {
    return await Task.Run(() => {
        List<ContractData> contracts = new List<ContractData>();
        
        using (var connection = GetConnection()) {
            using (var cmd = connection.CreateCommand()) {
                cmd.CommandText = query;
                
                using (var reader = cmd.ExecuteReader()) {
                    while (reader.Read()) {
                        contracts.Add(new ContractData {
                            ID = reader.GetString(0),
                            EmployerID = reader.GetString(1),
                            TargetID = reader.GetString(2),
                            Type = Enum.Parse<ContractType>(reader.GetString(3)),
                            RewardGold = reader.GetInt32(4),
                            IsCompleted = reader.GetInt32(5) == 1,
                            CreatedAt = reader.GetDateTime(6),
                            Deadline = reader.GetDateTime(7),
                            CompletedAt = reader.IsDBNull(8) ? null : reader.GetDateTime(8)
                        });
                    }
                }
            }
        }
        
        return contracts;
    });
}

/// <summary>
/// âœ… Kontrat gÃ¼ncelle (async)
/// </summary>
public async Task UpdateContractAsync(ContractData contract) {
    await Task.Run(() => {
        using (var connection = GetConnection()) {
            using (var cmd = connection.CreateCommand()) {
                cmd.CommandText = @"
                    UPDATE contracts 
                    SET is_completed = @completed, completed_at = @completedAt
                    WHERE id = @id";
                
                cmd.Parameters.AddWithValue("@completed", contract.IsCompleted ? 1 : 0);
                cmd.Parameters.AddWithValue("@completedAt", contract.CompletedAt ?? (object)DBNull.Value);
                cmd.Parameters.AddWithValue("@id", contract.ID);
                
                cmd.ExecuteNonQuery();
            }
        }
    });
}
```

---

## ğŸ¦– ADIM 5: EÄÄ°TME SÄ°STEMÄ° (Taming System)

### 5.1 TamingManager.cs (NetworkBehaviour)

**Dosya:** `_Stratocraft/Scripts/Systems/Taming/TamingManager.cs`

**AmaÃ§:** MoblarÄ± eÄŸitme sistemi (Java'daki TamingManager eÅŸdeÄŸeri) - Voxel terrain uyumlu

**Kod:**

```csharp
using FishNet.Object;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: EÄŸitme yÃ¶neticisi - Mob eÄŸitme sistemi
/// Java'daki TamingManager'Ä±n Unity eÅŸdeÄŸeri
/// Voxel terrain Ã¼zerinde TamingCore ile mob eÄŸitme
/// </summary>
public class TamingManager : NetworkBehaviour {
    [Header("Ayarlar")]
    [Tooltip("EÄŸitme baÅŸarÄ± ÅŸansÄ± (0-1)")]
    [Range(0f, 1f)]
    public float baseTamingChance = 0.3f;
    
    [Tooltip("EÄŸitme sÃ¼resi (saniye)")]
    [Range(1f, 60f)]
    public float tamingDuration = 10f;
    
    [Tooltip("EÄŸitme mesafesi")]
    [Range(1f, 10f)]
    public float tamingRange = 5f;
    
    [Tooltip("TamingCore item ID'si")]
    public string tamingCoreItemID = "taming_core";

    // âœ… OPTÄ°MÄ°ZE: EÄŸitilmiÅŸ moblar cache (NetworkObject ID -> Owner ID)
    private Dictionary<uint, string> _tamedMobs = new Dictionary<uint, string>();
    
    // âœ… OPTÄ°MÄ°ZE: Aktif eÄŸitme sÃ¼reÃ§leri (NetworkObject ID -> TamingProcess)
    private Dictionary<uint, TamingProcess> _activeTamings = new Dictionary<uint, TamingProcess>();
    
    // âœ… OPTÄ°MÄ°ZE: ChunkManager referansÄ± (voxel terrain entegrasyonu)
    private ChunkManager _chunkManager;
    private ItemDatabase _itemDatabase;

    void Awake() {
        // âœ… ServiceLocator'a kaydet
        ServiceLocator.Instance?.Register<TamingManager>(this);
    }

    void Start() {
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        _itemDatabase = ServiceLocator.Instance?.Get<ItemDatabase>();
    }

    /// <summary>
    /// âœ… Mob eÄŸitme isteÄŸi (ServerRpc)
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void CmdStartTaming(NetworkObject player, NetworkObject mob, Vector3 tamingCorePosition) {
        if (player == null || mob == null) return;
        
        string playerId = player.OwnerId.ToString();
        uint mobId = mob.ObjectId;
        
        // âœ… Zaten eÄŸitilmiÅŸ mi?
        if (_tamedMobs.ContainsKey(mobId)) {
            RpcShowMessage(player.Owner, "Bu mob zaten eÄŸitilmiÅŸ!");
            return;
        }
        
        // âœ… Zaten eÄŸitiliyor mu?
        if (_activeTamings.ContainsKey(mobId)) {
            RpcShowMessage(player.Owner, "Bu mob zaten eÄŸitiliyor!");
            return;
        }
        
        // âœ… Mesafe kontrolÃ¼
        float distance = Vector3.Distance(player.transform.position, mob.transform.position);
        if (distance > tamingRange) {
            RpcShowMessage(player.Owner, "Mob Ã§ok uzakta!");
            return;
        }
        
        // âœ… TamingCore kontrolÃ¼ (oyuncunun elinde veya yakÄ±nÄ±nda)
        if (!HasTamingCore(player, tamingCorePosition)) {
            RpcShowMessage(player.Owner, "EÄŸitme Ã‡ekirdeÄŸi gerekli!");
            return;
        }
        
        // âœ… Chunk kontrolÃ¼ (voxel terrain iÃ§in)
        if (_chunkManager != null) {
            Vector3Int chunkCoord = _chunkManager.GetChunkCoord(tamingCorePosition);
            GameObject chunk = _chunkManager.GetChunk(chunkCoord);
            if (chunk == null) {
                RpcShowMessage(player.Owner, "Bu bÃ¶lge henÃ¼z yÃ¼klenmedi!");
                return;
            }
        }
        
        // âœ… MobAI kontrolÃ¼ (eÄŸitilebilir mi?)
        MobAI mobAI = mob.GetComponent<MobAI>();
        if (mobAI == null) {
            RpcShowMessage(player.Owner, "Bu mob eÄŸitilemez!");
            return;
        }
        
        // âœ… EÄŸitme sÃ¼recini baÅŸlat
        TamingProcess process = new TamingProcess {
            playerId = playerId,
            mobId = mobId,
            mob = mob,
            startTime = Time.time,
            duration = tamingDuration,
            tamingCorePosition = tamingCorePosition
        };
        _activeTamings[mobId] = process;
        
        // âœ… EÄŸitme baÅŸladÄ± efektleri
        RpcShowTamingStart(mob.transform.position);
        
        // âœ… Coroutine baÅŸlat
        StartCoroutine(TamingCoroutine(process));
    }

    /// <summary>
    /// âœ… EÄŸitme coroutine'i
    /// </summary>
    IEnumerator TamingCoroutine(TamingProcess process) {
        yield return new WaitForSeconds(process.duration);
        
        // âœ… BaÅŸarÄ± ÅŸansÄ± hesapla
        float successChance = baseTamingChance;
        
        // âœ… Zorluk seviyesine gÃ¶re ÅŸansÄ± ayarla (ileride eklenebilir)
        // DifficultyManager'dan zorluk seviyesi alÄ±nabilir
        
        bool success = Random.Range(0f, 1f) < successChance;
        
        if (success) {
            // âœ… EÄŸitme baÅŸarÄ±lÄ±
            _tamedMobs[process.mobId] = process.playerId;
            
            // âœ… MobAI'yi gÃ¼ncelle (sahibini takip et)
            MobAI mobAI = process.mob.GetComponent<MobAI>();
            if (mobAI != null) {
                mobAI.SetOwner(process.playerId);
                mobAI.SetFollowTarget(FindPlayerById(process.playerId)?.transform);
            }
            
            // âœ… BaÅŸarÄ± efektleri
            RpcShowTamingSuccess(process.mob.transform.position);
            
            // âœ… Oyuncuya bildir
            NetworkObject player = FindPlayerById(process.playerId);
            if (player != null) {
                RpcShowMessage(player.Owner, "Mob baÅŸarÄ±yla eÄŸitildi!");
            }
        } else {
            // âœ… EÄŸitme baÅŸarÄ±sÄ±z
            RpcShowTamingFail(process.mob.transform.position);
            
            // âœ… Oyuncuya bildir
            NetworkObject player = FindPlayerById(process.playerId);
            if (player != null) {
                RpcShowMessage(player.Owner, "EÄŸitme baÅŸarÄ±sÄ±z oldu!");
            }
        }
        
        // âœ… SÃ¼reci temizle
        _activeTamings.Remove(process.mobId);
    }

    /// <summary>
    /// âœ… TamingCore var mÄ± kontrol et
    /// </summary>
    bool HasTamingCore(NetworkObject player, Vector3 tamingCorePosition) {
        // âœ… 1. Oyuncunun elinde TamingCore var mÄ±? (InventoryManager'dan kontrol edilebilir)
        // TODO: InventoryManager entegrasyonu
        
        // âœ… 2. YakÄ±nda TamingCore yapÄ±sÄ± var mÄ±? (StructurePlacer'dan kontrol)
        Collider[] colliders = Physics.OverlapSphere(tamingCorePosition, 3f);
        foreach (var col in colliders) {
            // âœ… TamingCore yapÄ±sÄ± kontrolÃ¼
            // StructurePlacer'dan TamingCore yapÄ±sÄ± kontrol edilebilir
            if (col.gameObject.name.Contains("TamingCore")) {
                return true;
            }
        }
        
        return false;
    }

    /// <summary>
    /// âœ… Mob eÄŸitilmiÅŸ mi?
    /// </summary>
    public bool IsTamed(NetworkObject mob) {
        if (mob == null) return false;
        return _tamedMobs.ContainsKey(mob.ObjectId);
    }

    /// <summary>
    /// âœ… Mob'un sahibi kim?
    /// </summary>
    public string GetOwner(NetworkObject mob) {
        if (mob == null) return null;
        _tamedMobs.TryGetValue(mob.ObjectId, out string ownerId);
        return ownerId;
    }

    /// <summary>
    /// âœ… Oyuncu bul (ID'den)
    /// </summary>
    NetworkObject FindPlayerById(string playerId) {
        foreach (var conn in ServerManager.Clients) {
            if (conn.ClientId.ToString() == playerId) {
                return conn.FirstObject;
            }
        }
        return null;
    }

    /// <summary>
    /// âœ… RPC: Mesaj gÃ¶ster
    /// </summary>
    [TargetRpc]
    void RpcShowMessage(NetworkConnection conn, string message) {
        Debug.Log($"[TamingManager] {message}");
    }

    /// <summary>
    /// âœ… RPC: EÄŸitme baÅŸladÄ± efektleri
    /// </summary>
    [ObserversRpc]
    void RpcShowTamingStart(Vector3 position) {
        // âœ… PartikÃ¼l efektleri
    }

    /// <summary>
    /// âœ… RPC: EÄŸitme baÅŸarÄ±lÄ± efektleri
    /// </summary>
    [ObserversRpc]
    void RpcShowTamingSuccess(Vector3 position) {
        // âœ… PartikÃ¼l efektleri
    }

    /// <summary>
    /// âœ… RPC: EÄŸitme baÅŸarÄ±sÄ±z efektleri
    /// </summary>
    [ObserversRpc]
    void RpcShowTamingFail(Vector3 position) {
        // âœ… PartikÃ¼l efektleri
    }
}

/// <summary>
/// âœ… EÄŸitme sÃ¼reci data yapÄ±sÄ±
/// </summary>
class TamingProcess {
    public string playerId;
    public uint mobId;
    public NetworkObject mob;
    public float startTime;
    public float duration;
    public Vector3 tamingCorePosition;
}
```

**KullanÄ±m:**
1. Oyuncu TamingCore'u voxel terrain Ã¼zerine yerleÅŸtirir (StructurePlacer ile)
2. Oyuncu mob'a yaklaÅŸÄ±r ve eÄŸitme baÅŸlatÄ±r
3. TamingManager eÄŸitme sÃ¼recini yÃ¶netir
4. BaÅŸarÄ±lÄ± olursa mob sahibini takip eder

---

## âœ… FAZ 4 BÄ°TÄ°Å RAPORU

### ğŸ“Š Tamamlanan Ã–zellikler

**1. EÅŸya Sistemi:**
- âœ… ItemDefinition ScriptableObject (Data-Driven)
- âœ… ItemDatabase (cache sistemi ile)
- âœ… PhysicalItem (aÄŸ senkronizasyonu)
- âœ… ItemSpawner (dÃ¼nyaya eÅŸya yerleÅŸtirme)

**2. RitÃ¼el Sistemi:**
- âœ… RitualRecipe ScriptableObject
- âœ… RitualManager (Physics.OverlapSphere ile tarama)
- âœ… RitualInputHandler (oyuncu giriÅŸleri)
- âœ… Åekil bazlÄ± ritÃ¼eller (Circle, Triangle, Square)

**3. Klan ve BÃ¶lge Sistemi:**
- âœ… TerritoryManager (3D Flood-Fill algoritmasÄ±)
- âœ… TerritoryData (bÃ¶lge verisi)
- âœ… ClanFence (fiziksel Ã§it component'i)
- âœ… Chunk-based cache (performans)

**4. Ekonomi ve Kontratlar:**
- âœ… ContractManager (SQLite tabanlÄ±)
- âœ… ContractData model
- âœ… Async veritabanÄ± iÅŸlemleri
- âœ… Cache sistemi (aktif kontratlar)

### ğŸ¯ AmaÃ§ ve SonuÃ§

**AmaÃ§:** DÃ¼nyayÄ± tek dÃ¼ze bir simÃ¼lasyondan, oyuncularÄ±n ticaret yaptÄ±ÄŸÄ±, bÃ¼yÃ¼ler kurduÄŸu ve bÃ¶lge savaÅŸÄ± verdiÄŸi bir **MMO RPG**'ye dÃ¶nÃ¼ÅŸtÃ¼rmek.

**SonuÃ§:**
- âœ… Envanter yok ama eÅŸya var (fiziksel obje sistemi)
- âœ… BÃ¼yÃ¼ yapÄ±labiliyor (ritÃ¼el sistemi)
- âœ… Klan kurulabiliyor (bÃ¶lge sistemi)
- âœ… Hukuk iÅŸliyor (kontrat sistemi)

### ğŸ“‚ Mevcut Dosya YapÄ±sÄ± (Faz 4 SonrasÄ±)

```
Assets/_Stratocraft/
â”œâ”€â”€ Data/
â”‚   â”œâ”€â”€ Items/
â”‚   â”‚   â”œâ”€â”€ TitaniumOre.asset          âœ… YENÄ°
â”‚   â”‚   â”œâ”€â”€ ClanCrystal.asset          âœ… YENÄ°
â”‚   â”‚   â””â”€â”€ ... (diÄŸer eÅŸyalar)
â”‚   â”‚
â”‚   â””â”€â”€ Recipes/
â”‚       â”œâ”€â”€ FireBatteryRecipe.asset    âœ… YENÄ°
â”‚       â””â”€â”€ ... (diÄŸer ritÃ¼eller)
â”‚
â”œâ”€â”€ Scripts/
â”‚   â”œâ”€â”€ Core/
â”‚   â”‚   â”œâ”€â”€ Definitions/
â”‚   â”‚   â”‚   â”œâ”€â”€ ItemDefinition.cs      âœ… YENÄ°
â”‚   â”‚   â”‚   â””â”€â”€ RitualRecipe.cs        âœ… YENÄ°
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ ItemDatabase.cs            âœ… YENÄ°
â”‚   â”‚   â””â”€â”€ DatabaseManager.cs        âœ… GÃœNCELLENDÄ° (Contract metodlarÄ±)
â”‚   â”‚
â”‚   â””â”€â”€ Systems/
â”‚       â”œâ”€â”€ Interaction/
â”‚       â”‚   â”œâ”€â”€ PhysicalItem.cs         âœ… YENÄ°
â”‚       â”‚   â””â”€â”€ ItemSpawner.cs         âœ… YENÄ°
â”‚       â”‚
â”‚       â”œâ”€â”€ Rituals/
â”‚       â”‚   â”œâ”€â”€ RitualManager.cs       âœ… YENÄ°
â”‚       â”‚   â””â”€â”€ RitualInputHandler.cs  âœ… YENÄ°
â”‚       â”‚
â”‚       â”œâ”€â”€ Clans/
â”‚       â”‚   â”œâ”€â”€ TerritoryManager.cs    âœ… YENÄ°
â”‚       â”‚   â””â”€â”€ ClanFence.cs           âœ… YENÄ°
â”‚       â”‚
â”‚       â””â”€â”€ Economy/
â”‚           â””â”€â”€ ContractManager.cs     âœ… YENÄ°
```

### ğŸ”® Gelecek Fazlarda Bu Ã–zelliklere Eklenecekler

**Faz 5 (Yapay Zeka ve SavaÅŸ):**
- Titan AI (Panda BT ile boss savaÅŸlarÄ±)
- Combat sistemi (silah hasarlarÄ±, zÄ±rh delme)
- Tuzak sistemi (trap core entegrasyonu)

**Faz 6+ (Ä°leri Ã–zellikler):**
- YapÄ± sistemi (structure core entegrasyonu)
- Batarya sistemi (ritÃ¼el sonucu bataryalar)
- Ekonomi sistemi (market, ticaret)

---

## ğŸ§ª TEST ADIMLARI

### Test 1: EÅŸya Sistemi

1. Unity'de `TitaniumOre.asset` oluÅŸtur
2. `ItemDatabase` GameObject'ine ekle
3. `allItems` listesine ekle
4. `ItemSpawner.SpawnItem("titanium_ore", 1, Vector3.zero)` Ã§aÄŸÄ±r
5. Play tuÅŸuna bas

**Beklenen SonuÃ§:**
- DÃ¼nyada fiziksel eÅŸya gÃ¶rÃ¼nmeli
- EÅŸya aÄŸ Ã¼zerinden senkronize edilmeli
- EÅŸya toplanabilir olmalÄ±

---

### Test 2: RitÃ¼el Sistemi

1. Unity'de `FireBatteryRecipe.asset` oluÅŸtur
2. `RitualManager` GameObject'ine ekle
3. `allRecipes` listesine ekle
4. Yere 3 Magma taÅŸÄ± koy
5. E tuÅŸuna bas

**Beklenen SonuÃ§:**
- RitÃ¼el baÅŸlamalÄ± (efektler gÃ¶rÃ¼nmeli)
- PartikÃ¼ller gÃ¶rÃ¼nmeli (ritÃ¼el enerjisi)
- RitÃ¼el tamamlandÄ±ÄŸÄ±nda sonuÃ§ item spawn olmalÄ±
- RitÃ¼el baÅŸarÄ±sÄ±z olursa hata mesajÄ± gÃ¶rÃ¼nmeli

---

### Test 3: Klan ve BÃ¶lge Sistemi

1. Unity'de `ClanFence` prefab'Ä± oluÅŸtur
2. Yere 8+ `ClanFence` koy (kapalÄ± bir alan oluÅŸtur)
3. `ClanCrystal` item'Ä±nÄ± al
4. Ã‡itlerin iÃ§ine gir ve `ClanCrystal` kullan

**Beklenen SonuÃ§:**
- Klan oluÅŸturulmalÄ±
- BÃ¶lge sÄ±nÄ±rlarÄ± hesaplanmalÄ± (Flood-Fill)
- PartikÃ¼ller gÃ¶rÃ¼nmeli (bÃ¶lge sÄ±nÄ±rlarÄ±)
- DiÄŸer oyuncular bÃ¶lgeye girememeli

---

### Test 4: Ekonomi ve Kontratlar

1. `ContractManager` GameObject'ine ekle
2. `ContractManager.CreateContract()` Ã§aÄŸÄ±r
3. `ContractManager.AcceptContract()` Ã§aÄŸÄ±r
4. `ContractManager.CompleteContract()` Ã§aÄŸÄ±r

**Beklenen SonuÃ§:**
- Kontrat veritabanÄ±na kaydedilmeli
- Kontrat listesi gÃ¶rÃ¼nmeli
- Kontrat tamamlandÄ±ÄŸÄ±nda Ã¶dÃ¼l verilmeli
- Kontrat iptal edilebilmeli



---

# ğŸš€ FAZ 5: YAPAY ZEKA, SAVAÅ VE FELAKETLER

**AmaÃ§:**

1. **Normal Moblar:** Basit AI ile oyuncularÄ± takip eden, saldÄ±ran dÃ¼ÅŸmanlar (Goblin, Ork, Troll, vb.)
2. **Bosslar:** Panda BT ile faz deÄŸiÅŸtiren, Ã¶zel yetenekleri olan gÃ¼Ã§lÃ¼ dÃ¼ÅŸmanlar (13 farklÄ± boss)
3. **Felaketler:** CanlÄ± felaketler (Titan Golem, Kaos EjderhasÄ±) ve doÄŸa olaylarÄ± (GÃ¼neÅŸ FÄ±rtÄ±nasÄ±, Deprem)
4. **Tuzaklar:** 25 farklÄ± mayÄ±n tipi ile savunma sistemi

---

## ğŸ› ï¸ ADIM 1: GEREKLÄ° ARAÃ‡LARIN KURULUMU

### 1.1 Panda BT (Behavior Tree)

**Link:** [Unity Asset Store - Panda BT Free](https://assetstore.unity.com/packages/tools/visual-scripting/panda-bt-free-19449) veya [GitHub](https://github.com/llamacademy/panda-bt)

**AmaÃ§:** BosslarÄ±n karmaÅŸÄ±k zekasÄ±nÄ± kodlamak (CanÄ± %50 olunca kaÃ§, %20 olunca Ã¶fkelen, faz deÄŸiÅŸtir)

**Kurulum:**
1. Asset Store'dan Panda BT Free'i indir
2. Veya GitHub'dan projeyi klonla
3. Unity'ye import et

**Not:** If-Else ile bu iÅŸ yapÄ±lmaz. Behavior Tree, bosslarÄ±n stratejik kararlar almasÄ±nÄ± saÄŸlar.

**Referanslar:**
- [Panda BT Unity Tutorial](https://www.youtube.com/watch?v=G5JXV2wzLhc)
- [Behavior Tree Best Practices](https://www.gamedeveloper.com/programming/behavior-trees-for-ai-how-they-work)

---

### 1.2 NavMesh Components (Runtime Baking)

**Link:** [GitHub - Unity NavMeshComponents](https://github.com/Unity-Technologies/NavMeshComponents)

**AmaÃ§:** Unity'nin standart NavMesh'i statiktir. Bizim dÃ¼nya (Scrawk) sÃ¼rekli deÄŸiÅŸiyor (kazÄ±lÄ±yor). Bu paket, oyun Ã§alÄ±ÅŸÄ±rken (Runtime) NavMesh'i tekrar piÅŸirmemizi (Bake) saÄŸlar.

**Kurulum:**
1. GitHub'dan projeyi klonla
2. Unity Package Manager â†’ Add package from disk â†’ `package.json` dosyasÄ±nÄ± seÃ§
3. Veya Assets klasÃ¶rÃ¼ne kopyala

**Referanslar:**
- [Unity NavMesh Runtime Baking](https://docs.unity3d.com/Manual/nav-BuildingNavMesh.html)
- [Dynamic NavMesh Tutorial](https://www.youtube.com/watch?v=CHV1ymlwcPs)

---

## ğŸ§  ADIM 2: DÄ°NAMÄ°K YOL BULMA (Dynamic Navigation)

DÃ¼nya sonsuz ve kazÄ±labilir olduÄŸu iÃ§in, NavMesh'i **Chunk bazlÄ±** piÅŸireceÄŸiz.

**Dosya:** `Assets/_Stratocraft/Scripts/AI/Core/ChunkNavMeshBaker.cs`

```csharp
using UnityEngine;
using UnityEngine.AI;
using System.Collections;
using FishNet.Object;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Chunk bazlÄ± dinamik NavMesh piÅŸirme - Voxel terrain uyumlu
/// Scrawk'Ä±n deÄŸiÅŸen dÃ¼nyasÄ±nda moblarÄ±n yol bulmasÄ±nÄ± saÄŸlar
/// ChunkManager entegrasyonu ile voxel terrain uyumu
/// </summary>
public class ChunkNavMeshBaker : NetworkBehaviour {
    [Header("Ayarlar")]
    public float rebakeInterval = 5f; // 5 saniyede bir kontrol et
    public float rebakeDelay = 0.5f; // Mesh oluÅŸumunu bekle
    public bool onlyBakeActiveChunks = true; // Sadece aktif chunklarda bake yap
    
    private NavMeshSurface _surface;
    private float _lastRebakeTime;
    private bool _isBaking = false;
    
    // âœ… OPTÄ°MÄ°ZE: Chunk deÄŸiÅŸiklik takibi
    private bool _chunkModified = false;
    
    // âœ… OPTÄ°MÄ°ZE: ChunkManager referansÄ± (voxel terrain entegrasyonu)
    private ChunkManager _chunkManager;
    private Vector3Int _chunkCoord;
    
    void Start() {
        // âœ… ChunkManager referansÄ±nÄ± al
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        if (_chunkManager != null) {
            _chunkCoord = _chunkManager.GetChunkCoord(transform.position);
        }
        
        // âœ… NavMeshSurface component'ini ekle
        _surface = gameObject.AddComponent<NavMeshSurface>();
        _surface.collectObjects = CollectObjects.Children; // Sadece bu chunk'Ä± piÅŸir
        _surface.useGeometry = NavMeshCollectGeometry.PhysicsColliders; // Collider'lardan mesh oluÅŸtur
        
        // âœ… Ä°lk bake'i yap (sadece aktif chunklarda)
        if (!onlyBakeActiveChunks || IsChunkActive()) {
            StartCoroutine(BakeAsync());
        }
    }
    
    void Update() {
        // âœ… Sadece sunucuda Ã§alÄ±ÅŸ
        if (!IsServer) return;
        
        // âœ… Aktif chunk kontrolÃ¼ (voxel terrain iÃ§in)
        if (onlyBakeActiveChunks && !IsChunkActive()) {
            return; // Uzak chunklarda bake yapma
        }
        
        // âœ… Chunk deÄŸiÅŸtiyse ve bekleme sÃ¼resi dolduysa rebake yap
        if (_chunkModified && Time.time - _lastRebakeTime > rebakeInterval && !_isBaking) {
            _chunkModified = false;
            StartCoroutine(BakeAsync());
        }
    }
    
    /// <summary>
    /// âœ… Chunk aktif mi? (oyuncu yakÄ±nÄ±nda mÄ±?)
    /// </summary>
    bool IsChunkActive() {
        if (_chunkManager == null) return true; // ChunkManager yoksa varsayÄ±lan olarak aktif
        
        // âœ… ChunkManager'dan aktif chunk listesini al
        var activeChunks = _chunkManager.GetActiveChunkCoords();
        return activeChunks.Contains(_chunkCoord);
    }
    
    /// <summary>
    /// âœ… Chunk deÄŸiÅŸtiÄŸinde Ã§aÄŸrÄ±lÄ±r (TerrainEditor veya NetworkMining'den)
    /// </summary>
    public void OnChunkModified() {
        _chunkModified = true;
    }
    
    /// <summary>
    /// âœ… Async NavMesh bake (frame kilitlememesi iÃ§in)
    /// </summary>
    IEnumerator BakeAsync() {
        if (_isBaking) yield break;
        _isBaking = true;
        
        // âœ… Mesh oluÅŸumunu bekle (voxel terrain iÃ§in)
        yield return new WaitForSeconds(rebakeDelay);
        yield return new WaitForEndOfFrame();
        
        // âœ… Chunk hala aktif mi kontrol et
        if (onlyBakeActiveChunks && !IsChunkActive()) {
            _isBaking = false;
            yield break; // Chunk artÄ±k aktif deÄŸilse bake yapma
        }
        
        // âœ… NavMesh'i piÅŸir
        _surface.BuildNavMesh();
        _lastRebakeTime = Time.time;
        
        _isBaking = false;
    }
    
    /// <summary>
    /// âœ… Manuel rebake (admin komutu iÃ§in)
    /// </summary>
    public void ReBake() {
        StartCoroutine(BakeAsync());
    }
}
```

**KullanÄ±m:**
1. Bu scripti Chunk Prefab'Ä±na ekle
2. `ChunkManager` chunk spawn ettiÄŸinde otomatik bake yapar
3. `TerrainEditor.ModifyTerrain()` Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda `OnChunkModified()` Ã§aÄŸrÄ±lÄ±r

**Not:** Bunu sadece oyuncunun ve moblarÄ±n olduÄŸu aktif chunklarda yapmalÄ±sÄ±n. Uzaktaki chunklarda NavMesh piÅŸirmek gereksiz performans kaybÄ±dÄ±r.

**Optimizasyon:**
- âœ… Sadece aktif chunklarda bake yap
- âœ… Chunk deÄŸiÅŸiklik takibi ile gereksiz rebake Ã¶nleme
- âœ… Async bake ile frame kilitleme Ã¶nleme
- âœ… Coroutine kullanarak performans optimizasyonu

---

## ğŸ‘¹ ADIM 3: NORMAL MOBLAR (Basit AI)

Normal moblar, oyunda sÄ±kÃ§a karÅŸÄ±laÅŸÄ±lan ve genellikle basit davranÄ±ÅŸlara sahip dÃ¼ÅŸmanlardÄ±r.

### 3.1 Mob TanÄ±mlarÄ± (ScriptableObject)

**Dosya:** `Assets/_Stratocraft/Scripts/Core/Definitions/MobDefinition.cs`

**Not:** MobIdentity ve MobDatabase de eklenmelidir (MobAI'de kullanÄ±lÄ±yor).

**Dosya:** `Assets/_Stratocraft/Scripts/AI/Mobs/MobIdentity.cs`

```csharp
using UnityEngine;

/// <summary>
/// âœ… Mob kimliÄŸi - Mob'Ä±n ID'sini tutar
/// </summary>
public class MobIdentity : MonoBehaviour {
    [Header("Mob Bilgileri")]
    public string mobId; // "goblin", "ork", "troll"
    
    void Awake() {
        if (string.IsNullOrEmpty(mobId)) {
            Debug.LogWarning($"[MobIdentity] Mob ID boÅŸ: {gameObject.name}");
        }
    }
}
```

**Dosya:** `Assets/_Stratocraft/Scripts/Core/Databases/MobDatabase.cs`

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Mob veritabanÄ± - MobDefinition lookup (O(1))
/// </summary>
public class MobDatabase : MonoBehaviour {
    [Header("Mob TanÄ±mlarÄ±")]
    public List<MobDefinition> allMobs = new List<MobDefinition>();
    
    // âœ… OPTÄ°MÄ°ZE: Dictionary cache (O(1) lookup)
    private Dictionary<string, MobDefinition> _mobCache = new Dictionary<string, MobDefinition>();
    
    private static MobDatabase _instance;
    public static MobDatabase Instance {
        get {
            if (_instance == null) {
                _instance = FindObjectOfType<MobDatabase>();
            }
            return _instance;
        }
    }
    
    void Awake() {
        if (_instance == null) {
            _instance = this;
            DontDestroyOnLoad(gameObject);
        } else if (_instance != this) {
            Destroy(gameObject);
            return;
        }
        
        // âœ… Cache'i doldur
        BuildCache();
        
        // âœ… ServiceLocator'a kaydet
        ServiceLocator.Instance?.Register<MobDatabase>(this);
    }
    
    /// <summary>
    /// âœ… Cache'i oluÅŸtur
    /// </summary>
    void BuildCache() {
        _mobCache.Clear();
        foreach (var mob in allMobs) {
            if (mob != null && !string.IsNullOrEmpty(mob.mobId)) {
                _mobCache[mob.mobId] = mob;
            }
        }
        Debug.Log($"[MobDatabase] {_mobCache.Count} mob cache'lendi.");
    }
    
    /// <summary>
    /// âœ… MobDefinition al (O(1) lookup)
    /// </summary>
    public MobDefinition GetMob(string mobId) {
        if (string.IsNullOrEmpty(mobId)) return null;
        
        if (_mobCache.TryGetValue(mobId, out MobDefinition mob)) {
            return mob;
        }
        
        Debug.LogWarning($"[MobDatabase] Mob bulunamadÄ±: {mobId}");
        return null;
    }
    
    /// <summary>
    /// âœ… TÃ¼m moblarÄ± al
    /// </summary>
    public List<MobDefinition> GetAllMobs() {
        return allMobs.ToList();
    }
}
```

---

```csharp
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(menuName = "Stratocraft/Data/Mob")]
public class MobDefinition : ScriptableObject {
    [Header("Kimlik")]
    public string mobId;              // "goblin", "ork", "troll"
    public string displayName;         // "Goblin", "Ork", "Troll"
    public GameObject prefab;         // Mob prefab'Ä±
    
    [Header("Ä°statistikler")]
    public float maxHealth = 100f;
    public float attackDamage = 10f;
    public float moveSpeed = 3.5f;
    public float detectionRange = 15f; // Oyuncuyu algÄ±lama mesafesi
    public float attackRange = 2f;     // SaldÄ±rÄ± mesafesi
    
    [Header("AI DavranÄ±ÅŸlarÄ±")]
    public float idleTime = 3f;        // Bekleme sÃ¼resi
    public float chaseSpeed = 5f;      // Takip hÄ±zÄ±
    public float fleeHealthPercent = 0.3f; // KaÃ§Ä±ÅŸ iÃ§in can yÃ¼zdesi
    
    [Header("Drop Tablosu")]
    public List<DropItem> dropTable;   // Ã–lÃ¼nce dÃ¼ÅŸecek itemler
    
    [System.Serializable]
    public class DropItem {
        public ItemDefinition item;
        public float dropChance;       // 0-1 arasÄ±
        public int minAmount = 1;
        public int maxAmount = 1;
    }
}
```

**KullanÄ±m:**
1. Unity EditÃ¶rÃ¼nde `Assets/_Stratocraft/Data/Mobs/` klasÃ¶rÃ¼ne saÄŸ tÄ±kla
2. `Create > Stratocraft > Mob` seÃ§eneÄŸini seÃ§
3. Mob Ã¶zelliklerini doldur (Goblin, Ork, Troll, vb.)

---

### 3.2 Mob AI State Machine

**Dosya:** `Assets/_Stratocraft/Scripts/AI/Mobs/MobAI.cs`

```csharp
using UnityEngine;
using UnityEngine.AI;
using FishNet.Object;
using FishNet.Object.Synchronizing;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Normal mob AI (State Machine)
/// Idle â†’ Chase â†’ Attack â†’ Flee durumlarÄ±
/// </summary>
public class MobAI : NetworkBehaviour {
    [Header("Referanslar")]
    private NavMeshAgent _agent;
    private HealthComponent _health;
    private MobDefinition _mobData;
    
    [Header("AI DurumlarÄ±")]
    private enum AIState { Idle, Chase, Attack, Flee }
    [SyncVar] private AIState _currentState = AIState.Idle;
    
    [Header("Hedef Takibi")]
    private Transform _targetPlayer;
    private float _lastStateChangeTime;
    private float _attackCooldown;
    
    // âœ… OPTÄ°MÄ°ZE: Oyuncu arama cache'i
    private float _lastPlayerSearchTime;
    private const float PLAYER_SEARCH_INTERVAL = 1f; // 1 saniyede bir oyuncu ara
    
    void Awake() {
        _agent = GetComponent<NavMeshAgent>();
        _health = GetComponent<HealthComponent>();
    }
    
    public override void OnStartServer() {
        base.OnStartServer();
        
        // âœ… MobDefinition'Ä± yÃ¼kle (ID'den)
        string mobId = GetComponent<MobIdentity>().mobId;
        _mobData = ServiceLocator.Instance.Get<MobDatabase>().GetMob(mobId);
        
        if (_mobData == null) {
            Debug.LogError($"[MobAI] MobDefinition bulunamadÄ±: {mobId}");
            return;
        }
        
        // âœ… Ä°statistikleri ayarla
        _health.SetMaxHealth(_mobData.maxHealth);
        _agent.speed = _mobData.moveSpeed;
        _agent.stoppingDistance = _mobData.attackRange;
    }
    
    void Update() {
        if (!IsServer) return; // AI sadece sunucuda Ã§alÄ±ÅŸÄ±r
        
        // âœ… Durum makinesi
        switch (_currentState) {
            case AIState.Idle:
                HandleIdle();
                break;
            case AIState.Chase:
                HandleChase();
                break;
            case AIState.Attack:
                HandleAttack();
                break;
            case AIState.Flee:
                HandleFlee();
                break;
        }
    }
    
    /// <summary>
    /// âœ… Bekleme durumu
    /// </summary>
    void HandleIdle() {
        // âœ… Oyuncu arama (cache'li)
        if (Time.time - _lastPlayerSearchTime > PLAYER_SEARCH_INTERVAL) {
            _targetPlayer = FindNearestPlayer(_mobData.detectionRange);
            _lastPlayerSearchTime = Time.time;
        }
        
        if (_targetPlayer != null) {
            // âœ… Oyuncu bulundu, takip et
            ChangeState(AIState.Chase);
            return;
        }
        
        // âœ… Bekleme sÃ¼resi doldu mu?
        if (Time.time - _lastStateChangeTime > _mobData.idleTime) {
            // âœ… Rastgele yÃ¼rÃ¼ (patrol)
            Vector3 randomPos = transform.position + Random.insideUnitSphere * 5f;
            randomPos.y = transform.position.y; // Y eksenini sabit tut
            _agent.SetDestination(randomPos);
        }
    }
    
    /// <summary>
    /// âœ… Takip durumu
    /// </summary>
    void HandleChase() {
        if (_targetPlayer == null || !_targetPlayer.gameObject.activeInHierarchy) {
            ChangeState(AIState.Idle);
            return;
        }
        
        // âœ… Mesafe kontrolÃ¼
        float distance = Vector3.Distance(transform.position, _targetPlayer.position);
        
        if (distance > _mobData.detectionRange * 2f) {
            // âœ… Ã‡ok uzaklaÅŸtÄ±, bekleme moduna geÃ§
            ChangeState(AIState.Idle);
            _targetPlayer = null;
            return;
        }
        
        if (distance <= _mobData.attackRange) {
            // âœ… SaldÄ±rÄ± menzilinde
            ChangeState(AIState.Attack);
            return;
        }
        
        // âœ… Takip et
        _agent.speed = _mobData.chaseSpeed;
        _agent.SetDestination(_targetPlayer.position);
    }
    
    /// <summary>
    /// âœ… SaldÄ±rÄ± durumu
    /// </summary>
    void HandleAttack() {
        if (_targetPlayer == null) {
            ChangeState(AIState.Idle);
            return;
        }
        
        // âœ… Mesafe kontrolÃ¼
        float distance = Vector3.Distance(transform.position, _targetPlayer.position);
        
        if (distance > _mobData.attackRange * 1.5f) {
            // âœ… UzaklaÅŸtÄ±, tekrar takip et
            ChangeState(AIState.Chase);
            return;
        }
        
        // âœ… SaldÄ±rÄ± cooldown kontrolÃ¼
        if (Time.time - _attackCooldown < 1f) return; // 1 saniye cooldown
        
        // âœ… SaldÄ±rÄ± yap
        PerformAttack(_targetPlayer);
        _attackCooldown = Time.time;
    }
    
    /// <summary>
    /// âœ… KaÃ§Ä±ÅŸ durumu (can dÃ¼ÅŸÃ¼kse)
    /// </summary>
    void HandleFlee() {
        if (_targetPlayer == null) {
            ChangeState(AIState.Idle);
            return;
        }
        
        // âœ… Can yÃ¼zdesi kontrolÃ¼
        float healthPercent = _health.CurrentHealth / _health.MaxHealth;
        if (healthPercent > _mobData.fleeHealthPercent + 0.1f) {
            // âœ… Can yeterli, tekrar saldÄ±r
            ChangeState(AIState.Chase);
            return;
        }
        
        // âœ… Hedefin tersi yÃ¶ne kaÃ§
        Vector3 fleeDirection = (transform.position - _targetPlayer.position).normalized;
        Vector3 fleePosition = transform.position + fleeDirection * 10f;
        _agent.SetDestination(fleePosition);
    }
    
    /// <summary>
    /// âœ… Durum deÄŸiÅŸtir
    /// </summary>
    void ChangeState(AIState newState) {
        if (_currentState == newState) return;
        
        _currentState = newState;
        _lastStateChangeTime = Time.time;
        
        // âœ… Duruma gÃ¶re agent ayarlarÄ±
        switch (newState) {
            case AIState.Idle:
                _agent.isStopped = true;
                break;
            case AIState.Chase:
                _agent.isStopped = false;
                _agent.speed = _mobData.chaseSpeed;
                break;
            case AIState.Attack:
                _agent.isStopped = true; // SaldÄ±rÄ± sÄ±rasÄ±nda dur
                break;
            case AIState.Flee:
                _agent.isStopped = false;
                _agent.speed = _mobData.moveSpeed * 1.5f; // KaÃ§Ä±ÅŸta daha hÄ±zlÄ±
                break;
        }
    }
    
    /// <summary>
    /// âœ… En yakÄ±n oyuncuyu bul (optimize edilmiÅŸ - voxel terrain uyumlu)
    /// </summary>
    Transform FindNearestPlayer(float range) {
        // âœ… ServiceLocator'dan PlayerManager al
        var playerManager = ServiceLocator.Instance?.Get<PlayerManager>();
        if (playerManager == null) return null;
        
        Transform nearest = null;
        float nearestDistance = float.MaxValue;
        
        // âœ… ChunkManager referansÄ± (voxel terrain kontrolÃ¼ iÃ§in)
        ChunkManager chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        
        // âœ… TÃ¼m oyuncularÄ± kontrol et
        foreach (var player in playerManager.GetAllPlayers()) {
            if (player == null || !player.gameObject.activeInHierarchy) continue;
            
            // âœ… Voxel terrain kontrolÃ¼: Oyuncu aktif bir chunk'ta mÄ±?
            if (chunkManager != null) {
                Vector3Int playerChunkCoord = chunkManager.GetChunkCoord(player.position);
                GameObject playerChunk = chunkManager.GetChunk(playerChunkCoord);
                if (playerChunk == null) continue; // Oyuncu yÃ¼klenmemiÅŸ chunk'ta
            }
            
            float distance = Vector3.Distance(transform.position, player.position);
            if (distance <= range && distance < nearestDistance) {
                nearest = player;
                nearestDistance = distance;
            }
        }
        
        return nearest;
    }
    
    /// <summary>
    /// âœ… SaldÄ±rÄ± yap
    /// </summary>
    void PerformAttack(Transform target) {
        // âœ… Hasar ver
        var targetHealth = target.GetComponent<HealthComponent>();
        if (targetHealth != null) {
            targetHealth.TakeDamage(_mobData.attackDamage, _mobData.mobId);
        }
        
        // âœ… Animasyon tetikle (Animator varsa)
        var animator = GetComponent<Animator>();
        if (animator != null) {
            animator.SetTrigger("Attack");
        }
        
        // âœ… SaldÄ±rÄ± efekti (partikÃ¼l, ses)
        // TODO: PartikÃ¼l ve ses efektleri ekle
    }
    
    /// <summary>
    /// âœ… Can dÃ¼ÅŸÃ¼kse kaÃ§Ä±ÅŸ moduna geÃ§
    /// </summary>
    void OnHealthChanged(float currentHealth, float maxHealth) {
        if (!IsServer) return;
        
        float healthPercent = currentHealth / maxHealth;
        if (healthPercent <= _mobData.fleeHealthPercent && _currentState != AIState.Flee) {
            ChangeState(AIState.Flee);
        }
    }
}
```

**Optimizasyon NotlarÄ±:**
- âœ… Oyuncu arama cache'i (1 saniyede bir)
- âœ… State Machine ile basit ve performanslÄ± AI
- âœ… NavMesh Agent ile optimize edilmiÅŸ yol bulma
- âœ… Sadece sunucuda AI Ã§alÄ±ÅŸÄ±r (network optimizasyonu)

---

### 3.3 Mob Spawner

**Dosya:** `Assets/_Stratocraft/Scripts/AI/Mobs/MobSpawner.cs`

```csharp
using UnityEngine;
using FishNet.Object;
using System.Collections.Generic;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Mob spawn sistemi (chunk bazlÄ±)
/// </summary>
public class MobSpawner : NetworkBehaviour {
    [Header("Ayarlar")]
    public List<MobDefinition> spawnableMobs; // Bu chunk'ta spawn olabilecek moblar
    public float spawnRadius = 50f;            // Spawn yarÄ±Ã§apÄ±
    public int maxMobsPerChunk = 10;           // Chunk baÅŸÄ±na maksimum mob
    public float spawnInterval = 30f;          // Spawn aralÄ±ÄŸÄ± (saniye)
    
    private float _lastSpawnTime;
    private int _currentMobCount = 0;
    
    // âœ… OPTÄ°MÄ°ZE: Spawn edilen moblarÄ± takip et
    private List<GameObject> _spawnedMobs = new List<GameObject>();
    
    void Update() {
        if (!IsServer) return;
        
        // âœ… Ã–lÃ¼ moblarÄ± listeden Ã§Ä±kar
        _spawnedMobs.RemoveAll(mob => mob == null || !mob.activeInHierarchy);
        _currentMobCount = _spawnedMobs.Count;
        
        // âœ… Spawn kontrolÃ¼
        if (_currentMobCount < maxMobsPerChunk && 
            Time.time - _lastSpawnTime > spawnInterval) {
            SpawnRandomMob();
            _lastSpawnTime = Time.time;
        }
    }
    
    /// <summary>
    /// âœ… Rastgele mob spawn et (voxel terrain uyumlu)
    /// </summary>
    void SpawnRandomMob() {
        if (spawnableMobs == null || spawnableMobs.Count == 0) return;
        
        // âœ… ChunkManager referansÄ± (voxel terrain zemin bulma iÃ§in)
        ChunkManager chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        if (chunkManager == null) {
            Debug.LogWarning("[MobSpawner] ChunkManager bulunamadÄ±!");
            return;
        }
        
        // âœ… Rastgele mob seÃ§
        MobDefinition mobData = spawnableMobs[Random.Range(0, spawnableMobs.Count)];
        
        // âœ… Rastgele pozisyon (chunk iÃ§inde)
        Vector3 spawnPos = transform.position + Random.insideUnitSphere * spawnRadius;
        spawnPos.y = transform.position.y + 2f; // Zemin Ã¼stÃ¼nde
        
        // âœ… Voxel terrain Ã¼zerinde zemin bul (ChunkManager ile)
        Vector3 groundPosition = GetGroundPositionOnVoxelTerrain(spawnPos, chunkManager);
        if (groundPosition == Vector3.zero) {
            Debug.LogWarning($"[MobSpawner] Voxel terrain Ã¼zerinde zemin bulunamadÄ±: {spawnPos}");
            return; // GeÃ§ersiz spawn pozisyonu
        }
        
        spawnPos = groundPosition + Vector3.up * 0.5f; // Zemin Ã¼stÃ¼nde 0.5 blok
        
        // âœ… Mob spawn et
        GameObject mobObj = Instantiate(mobData.prefab, spawnPos, Quaternion.identity);
        
        // âœ… MobIdentity component'ini ekle (mob ID'si iÃ§in)
        var mobIdentity = mobObj.GetComponent<MobIdentity>();
        if (mobIdentity == null) {
            mobIdentity = mobObj.AddComponent<MobIdentity>();
        }
        mobIdentity.mobId = mobData.mobId;
        
        // âœ… Network spawn
        NetworkObject mobNet = mobObj.GetComponent<NetworkObject>();
        if (mobNet == null) {
            mobNet = mobObj.AddComponent<NetworkObject>();
        }
        Spawn(mobNet);
        
        // âœ… Listeye ekle
        _spawnedMobs.Add(mobObj);
    }
    
    /// <summary>
    /// âœ… Voxel terrain Ã¼zerinde zemin pozisyonunu bul
    /// </summary>
    Vector3 GetGroundPositionOnVoxelTerrain(Vector3 position, ChunkManager chunkManager) {
        // âœ… Chunk koordinatÄ±nÄ± al
        Vector3Int chunkCoord = chunkManager.GetChunkCoord(position);
        GameObject chunk = chunkManager.GetChunk(chunkCoord);
        
        if (chunk == null) {
            return Vector3.zero; // Chunk henÃ¼z yÃ¼klenmedi
        }
        
        // âœ… Raycast ile voxel terrain'e bak
        RaycastHit hit;
        if (Physics.Raycast(position + Vector3.up * 10f, Vector3.down, out hit, 20f)) {
            // âœ… Voxel terrain Ã¼zerinde mi?
            if (hit.collider.gameObject.GetComponent<MarchingCubesGPU>() != null) {
                return hit.point;
            }
        }
        
        // âœ… Alternatif: ChunkManager'dan density kontrolÃ¼
        float[] densityData = chunkManager.GetDensityDataForChunk(chunkCoord);
        if (densityData != null) {
            // âœ… Local voxel koordinatÄ±nÄ± hesapla
            Vector3Int localPos = new Vector3Int(
                Mathf.FloorToInt(position.x) % 32,
                Mathf.FloorToInt(position.y) % 32,
                Mathf.FloorToInt(position.z) % 32
            );
            
            // âœ… Y ekseninde aÅŸaÄŸÄ± doÄŸru ilerle, ilk solid bloÄŸu bul
            for (int y = localPos.y; y >= 0; y--) {
                int index = localPos.x + y * 32 + localPos.z * 32 * 32;
                if (index >= 0 && index < densityData.Length && densityData[index] >= 0) {
                    // âœ… Solid blok bulundu
                    return new Vector3(position.x, y + chunkCoord.y * 32, position.z);
                }
            }
        }
        
        return Vector3.zero; // Zemin bulunamadÄ±
    }
}
```

**KullanÄ±m:**
1. `MobSpawner` scriptini Chunk Prefab'Ä±na ekle
2. `spawnableMobs` listesine bu chunk'ta spawn olabilecek moblarÄ± ekle
3. `ChunkManager` chunk spawn ettiÄŸinde otomatik mob spawn baÅŸlar

---

## âš”ï¸ ADIM 4: SAVAÅ VE HASAR SÄ°STEMÄ° (Combat)

Sadece can azaltmak yetmez. `IDamageable` interface'i kullanarak hem oyuncunun, hem duvarÄ±n, hem de Titan'Ä±n hasar almasÄ±nÄ± saÄŸlayacaÄŸÄ±z.

### 4.1 IDamageable Interface

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Combat/IDamageable.cs`

```csharp
/// <summary>
/// âœ… Hasar alabilen tÃ¼m objeler iÃ§in interface
/// </summary>
public interface IDamageable {
    void TakeDamage(float amount, string damageSource);
    bool IsDead { get; }
    float CurrentHealth { get; }
    float MaxHealth { get; }
}
```

---

### 4.2 HealthComponent

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Combat/HealthComponent.cs`

```csharp
using FishNet.Object;
using FishNet.Object.Synchronizing;
using UnityEngine;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Can sistemi (Network senkronizasyonlu)
/// </summary>
public class HealthComponent : NetworkBehaviour, IDamageable {
    [Header("Veri")]
    [SerializeField] private float _maxHealth = 100f;
    
    [SyncVar(OnChange = nameof(OnHealthChanged))] 
    private float _currentHealth;
    
    public bool IsDead => _currentHealth <= 0;
    public float CurrentHealth => _currentHealth;
    public float MaxHealth => _maxHealth;
    
    // âœ… Event: Can deÄŸiÅŸtiÄŸinde
    public System.Action<float, float> OnHealthChangedEvent;
    
    public override void OnStartServer() {
        base.OnStartServer();
        _currentHealth = _maxHealth;
    }
    
    /// <summary>
    /// âœ… Maksimum canÄ± ayarla
    /// </summary>
    public void SetMaxHealth(float maxHealth) {
        _maxHealth = maxHealth;
        if (IsServer) {
            _currentHealth = Mathf.Min(_currentHealth, _maxHealth);
        }
    }
    
    /// <summary>
    /// âœ… Hasar al
    /// </summary>
    public void TakeDamage(float amount, string source) {
        if (!IsServer) return; // Sadece sunucu can azaltabilir
        if (IsDead) return; // Ã–lÃ¼yse hasar verme
        
        // âœ… ZÄ±rh hesabÄ± (ArmorComponent varsa)
        var armor = GetComponent<ArmorComponent>();
        if (armor != null) {
            amount = armor.CalculateDamage(amount);
        }
        
        // âœ… Can azalt
        _currentHealth = Mathf.Max(_currentHealth - amount, 0);
        
        // âœ… Ã–lÃ¼m kontrolÃ¼
        if (IsDead) {
            Die(source);
        }
    }
    
    /// <summary>
    /// âœ… Can iyileÅŸtir
    /// </summary>
    public void Heal(float amount) {
        if (!IsServer) return;
        if (IsDead) return;
        
        _currentHealth = Mathf.Min(_currentHealth + amount, _maxHealth);
    }
    
    /// <summary>
    /// âœ… Ã–lÃ¼m
    /// </summary>
    private void Die(string killer) {
        // âœ… Kontrat sistemini kontrol et (Faz 4'te yapmÄ±ÅŸtÄ±k)
        var contractManager = ServiceLocator.Instance?.Get<ContractManager>();
        if (contractManager != null) {
            contractManager.OnEntityDeath(gameObject.name, killer);
        }
        
        // âœ… Drop tablosu (Mob ise)
        var mobIdentity = GetComponent<MobIdentity>();
        if (mobIdentity != null) {
            DropLoot(mobIdentity.mobId);
        }
        
        // âœ… Ã–lÃ¼m efekti spawnla
        SpawnDeathEffect();
        
        // âœ… Objeyi yok et (Network)
        StartCoroutine(DestroyAfterDelay(2f)); // 2 saniye sonra yok et
    }
    
    /// <summary>
    /// âœ… Loot drop
    /// </summary>
    private void DropLoot(string mobId) {
        var mobDatabase = ServiceLocator.Instance?.Get<MobDatabase>();
        if (mobDatabase == null) return;
        
        var mobData = mobDatabase.GetMob(mobId);
        if (mobData == null || mobData.dropTable == null) return;
        
        // âœ… Drop tablosundan item dÃ¼ÅŸÃ¼r
        foreach (var drop in mobData.dropTable) {
            if (Random.value <= drop.dropChance) {
                int amount = Random.Range(drop.minAmount, drop.maxAmount + 1);
                // TODO: Item spawn et (PhysicalItem component'i ile)
            }
        }
    }
    
    /// <summary>
    /// âœ… Ã–lÃ¼m efekti
    /// </summary>
    private void SpawnDeathEffect() {
        // TODO: PartikÃ¼l ve ses efekti
    }
    
    /// <summary>
    /// âœ… Gecikmeli yok etme
    /// </summary>
    private System.Collections.IEnumerator DestroyAfterDelay(float delay) {
        yield return new WaitForSeconds(delay);
        if (IsServer) {
            Despawn(gameObject);
        }
    }
    
    /// <summary>
    /// âœ… SyncVar callback
    /// </summary>
    private void OnHealthChanged(float oldHealth, float newHealth, bool asServer) {
        OnHealthChangedEvent?.Invoke(newHealth, _maxHealth);
    }
}
```

---

### 4.3 ArmorComponent (ZÄ±rh Sistemi)

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Combat/ArmorComponent.cs`

```csharp
using UnityEngine;

/// <summary>
/// âœ… ZÄ±rh sistemi (hasar azaltma)
/// </summary>
public class ArmorComponent : MonoBehaviour {
    [Header("ZÄ±rh DeÄŸerleri")]
    public float armorValue = 0f;      // ZÄ±rh puanÄ±
    public float armorReduction = 0f;  // Hasar azaltma yÃ¼zdesi (0-1)
    
    /// <summary>
    /// âœ… Hasar hesapla (zÄ±rh ile)
    /// </summary>
    public float CalculateDamage(float baseDamage) {
        // âœ… Basit zÄ±rh formÃ¼lÃ¼: damage = baseDamage * (1 - armorReduction)
        float finalDamage = baseDamage * (1f - armorReduction);
        
        // âœ… ZÄ±rh puanÄ±na gÃ¶re ek azaltma
        finalDamage = Mathf.Max(finalDamage - armorValue, 0f);
        
        return finalDamage;
    }
}
```

**Optimizasyon:**
- âœ… Server-authoritative hasar hesaplama (anti-cheat)
- âœ… SyncVar ile network senkronizasyonu
- âœ… Event-based can deÄŸiÅŸikliÄŸi takibi
- âœ… ZÄ±rh sistemi ile hasar azaltma

---

## ğŸ‘¹ ADIM 5: BOSS YAPAY ZEKASI (Panda BT)

Boss savaÅŸlarÄ±nÄ± "Phase" (Evre) mantÄ±ÄŸÄ±yla yapacaÄŸÄ±z. Panda BT kullanarak karmaÅŸÄ±k kararlar almasÄ±nÄ± saÄŸlayacaÄŸÄ±z.

### 5.1 Boss TanÄ±mlarÄ±

**Dosya:** `Assets/_Stratocraft/Scripts/Core/Definitions/BossDefinition.cs`

```csharp
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(menuName = "Stratocraft/Data/Boss")]
public class BossDefinition : ScriptableObject {
    [Header("Kimlik")]
    public string bossId;              // "goblin_king", "titan_golem"
    public string displayName;         // "Goblin KralÄ±", "Titan Golem"
    public GameObject prefab;          // Boss prefab'Ä±
    public int level;                  // 1-5 arasÄ± seviye
    
    [Header("Ä°statistikler")]
    public float maxHealth = 500f;
    public float attackDamage = 20f;
    public float moveSpeed = 3f;
    public float detectionRange = 50f;
    public float attackRange = 5f;
    
    [Header("Faz Sistemi")]
    public int maxPhases = 1;          // 1-3 arasÄ± faz
    public List<PhaseData> phases;     // Her faz iÃ§in veriler
    
    [System.Serializable]
    public class PhaseData {
        public int phaseNumber;        // 1, 2, 3
        public float healthPercentThreshold; // Faz geÃ§iÅŸi iÃ§in can yÃ¼zdesi (Ã¶rn: 0.5 = %50)
        public List<BossAbility> abilities; // Bu fazda kullanabileceÄŸi yetenekler
        public float abilityCooldown = 6f;   // Yetenek cooldown sÃ¼resi
    }
    
    [Header("ZayÄ±f Noktalar ve ZayÄ±flÄ±klar")]
    public bool hasWeakPoint = false;  // ZayÄ±f nokta var mÄ±?
    public float weakPointDamageMultiplier = 3f; // ZayÄ±f noktaya vurulunca 3x hasar
    public List<DamageType> weaknesses; // ZayÄ±flÄ±k tÃ¼rleri (FIRE, WATER, POISON, LIGHTNING)
    public float weaknessDamageMultiplier = 2f; // ZayÄ±flÄ±ÄŸa vurulunca 2x hasar
    
    [Header("Drop Tablosu")]
    public List<DropItem> dropTable;
    
    public enum DamageType {
        FIRE, WATER, POISON, LIGHTNING, PHYSICAL
    }
    
    public enum BossAbility {
        FIRE_BREATH,        // AteÅŸ pÃ¼skÃ¼rtme
        EXPLOSION,          // Patlama
        LIGHTNING_STRIKE,   // YÄ±ldÄ±rÄ±m
        BLOCK_THROW,        // Blok fÄ±rlatma
        POISON_CLOUD,       // Zehir bulutu
        TELEPORT,           // IÅŸÄ±nlanma
        CHARGE,             // KoÅŸu saldÄ±rÄ±sÄ±
        SUMMON_MINIONS,     // Minyon Ã§aÄŸÄ±rma
        HEAL,               // Kendini iyileÅŸtirme
        SHOCKWAVE           // Åok dalgasÄ±
    }
}
```

**Boss Listesi (Java'dan):**
- **Seviye 1:** Goblin KralÄ±, Ork Åefi
- **Seviye 2:** Troll KralÄ±
- **Seviye 3:** Ejderha, T-Rex, Tek GÃ¶zlÃ¼ Dev (Cyclops)
- **Seviye 4:** Titan Golem, Cehennem Ejderi, Hydra, Phoenix
- **Seviye 5:** HiÃ§lik Ejderi (Void Dragon), Kaos Titani, Khaos TanrÄ±sÄ±

---

### 5.2 Boss AI (Panda BT)

**Dosya:** `Assets/_Stratocraft/Scripts/AI/Bosses/BossAI.cs`

```csharp
using UnityEngine;
using UnityEngine.AI;
using FishNet.Object;
using Panda; // Panda BT kÃ¼tÃ¼phanesi

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Boss AI (Panda BT ile)
/// Phase sistemi ve Ã¶zel yetenekler
/// </summary>
public class BossAI : NetworkBehaviour {
    [Header("Referanslar")]
    private NavMeshAgent _agent;
    private HealthComponent _hp;
    private BossDefinition _bossData;
    private Transform _target;
    
    [Header("Faz Sistemi")]
    private int _currentPhase = 1;
    private float _lastAbilityTime;
    
    // âœ… OPTÄ°MÄ°ZE: Oyuncu arama cache'i
    private float _lastPlayerSearchTime;
    private const float PLAYER_SEARCH_INTERVAL = 2f;
    
    void Awake() {
        _agent = GetComponent<NavMeshAgent>();
        _hp = GetComponent<HealthComponent>();
    }
    
    public override void OnStartServer() {
        base.OnStartServer();
        
        // âœ… BossDefinition'Ä± yÃ¼kle
        string bossId = GetComponent<BossIdentity>().bossId;
        _bossData = ServiceLocator.Instance.Get<BossDatabase>().GetBoss(bossId);
        
        if (_bossData == null) {
            Debug.LogError($"[BossAI] BossDefinition bulunamadÄ±: {bossId}");
            return;
        }
        
        // âœ… Ä°statistikleri ayarla
        _hp.SetMaxHealth(_bossData.maxHealth);
        _agent.speed = _bossData.moveSpeed;
        _agent.stoppingDistance = _bossData.attackRange;
        
        // âœ… Can deÄŸiÅŸikliÄŸi event'i
        _hp.OnHealthChangedEvent += OnBossHealthChanged;
    }
    
    void Update() {
        if (!IsServer) return;
        
        // âœ… Oyuncu arama (cache'li)
        if (Time.time - _lastPlayerSearchTime > PLAYER_SEARCH_INTERVAL) {
            _target = FindNearestPlayer(_bossData.detectionRange);
            _lastPlayerSearchTime = Time.time;
        }
        
        // âœ… Faz kontrolÃ¼
        CheckPhaseTransition();
    }
    
    // --- PANDA BT GÃ–REVLERÄ° (Tasks) ---
    
    /// <summary>
    /// âœ… Panda BT Task: Can dÃ¼ÅŸÃ¼k mÃ¼?
    /// </summary>
    [Task]
    public bool IsHealthLow() {
        float healthPercent = _hp.CurrentHealth / _hp.MaxHealth;
        float threshold = GetCurrentPhaseData().healthPercentThreshold;
        return healthPercent <= threshold;
    }
    
    /// <summary>
    /// âœ… Panda BT Task: Hedef var mÄ±?
    /// </summary>
    [Task]
    public bool HasTarget() {
        return _target != null && _target.gameObject.activeInHierarchy;
    }
    
    /// <summary>
    /// âœ… Panda BT Task: SaldÄ±rÄ± menzilinde mi?
    /// </summary>
    [Task]
    public bool IsInAttackRange() {
        if (_target == null) return false;
        float distance = Vector3.Distance(transform.position, _target.position);
        return distance <= _bossData.attackRange;
    }
    
    /// <summary>
    /// âœ… Panda BT Task: Yetenek kullanÄ±labilir mi?
    /// </summary>
    [Task]
    public bool CanUseAbility() {
        float cooldown = GetCurrentPhaseData().abilityCooldown;
        return Time.time - _lastAbilityTime >= cooldown;
    }
    
    /// <summary>
    /// âœ… Panda BT Task: Hedefi takip et
    /// </summary>
    [Task]
    public void ChaseTarget() {
        if (_target == null) {
            Task.current.Fail();
            return;
        }
        
        _agent.SetDestination(_target.position);
        Task.current.Succeed();
    }
    
    /// <summary>
    /// âœ… Panda BT Task: YakÄ±n mesafe saldÄ±rÄ±sÄ±
    /// </summary>
    [Task]
    public void AttackMelee() {
        if (_target == null) {
            Task.current.Fail();
            return;
        }
        
        float distance = Vector3.Distance(transform.position, _target.position);
        if (distance <= _bossData.attackRange) {
            // âœ… Hasar ver
            var targetHealth = _target.GetComponent<HealthComponent>();
            if (targetHealth != null) {
                targetHealth.TakeDamage(_bossData.attackDamage, _bossData.bossId);
            }
            
            // âœ… Animasyon
            var animator = GetComponent<Animator>();
            if (animator != null) {
                animator.SetTrigger("Attack");
            }
            
            Task.current.Succeed();
        } else {
            Task.current.Fail();
        }
    }
    
    /// <summary>
    /// âœ… Panda BT Task: Lazer at (menzilli saldÄ±rÄ±)
    /// </summary>
    [Task]
    public void FireLaser() {
        if (_target == null) {
            Task.current.Fail();
            return;
        }
        
        // âœ… Lazer prefab'Ä± spawn et
        GameObject laserPrefab = GetAbilityPrefab(BossDefinition.BossAbility.LIGHTNING_STRIKE);
        if (laserPrefab != null) {
            Vector3 spawnPos = transform.position + Vector3.up * 2f;
            GameObject laser = Instantiate(laserPrefab, spawnPos, Quaternion.identity);
            
            // âœ… Hedefe yÃ¶nlendir
            Vector3 direction = (_target.position - spawnPos).normalized;
            laser.transform.rotation = Quaternion.LookRotation(direction);
            
            // âœ… Network spawn
            Spawn(laser);
        }
        
        _lastAbilityTime = Time.time;
        Task.current.Succeed();
    }
    
    /// <summary>
    /// âœ… Panda BT Task: Ã–fke modu (hÄ±zlÄ± koÅŸ, alan hasarÄ±)
    /// </summary>
    [Task]
    public void RageMode() {
        // âœ… HÄ±zÄ± artÄ±r
        _agent.speed = _bossData.moveSpeed * 2f;
        
        // âœ… Alan hasarÄ±
        Collider[] hits = Physics.OverlapSphere(transform.position, 5f);
        foreach (var hit in hits) {
            var health = hit.GetComponent<HealthComponent>();
            if (health != null && hit.transform != transform) {
                health.TakeDamage(_bossData.attackDamage * 1.5f, _bossData.bossId);
            }
        }
        
        Task.current.Succeed();
    }
    
    /// <summary>
    /// âœ… Faz geÃ§iÅŸi kontrolÃ¼
    /// </summary>
    void CheckPhaseTransition() {
        if (_bossData == null || _bossData.phases == null) return;
        
        float healthPercent = _hp.CurrentHealth / _hp.MaxHealth;
        
        // âœ… Mevcut fazÄ±n eÅŸiÄŸini kontrol et
        var currentPhaseData = GetCurrentPhaseData();
        if (currentPhaseData != null && healthPercent <= currentPhaseData.healthPercentThreshold) {
            // âœ… Bir sonraki faza geÃ§
            if (_currentPhase < _bossData.maxPhases) {
                TransitionToPhase(_currentPhase + 1);
            }
        }
    }
    
    /// <summary>
    /// âœ… Faz geÃ§iÅŸi
    /// </summary>
    void TransitionToPhase(int newPhase) {
        _currentPhase = newPhase;
        
        // âœ… Duyuru mesajÄ±
        Debug.Log($"[BossAI] {_bossData.displayName} Faz {_currentPhase}'e geÃ§ti!");
        
        // âœ… Yeni yetenekler aktif olur (Panda BT otomatik yÃ¶netir)
        // âœ… Ses efekti, partikÃ¼l, vb.
    }
    
    /// <summary>
    /// âœ… Mevcut faz verisini al
    /// </summary>
    BossDefinition.PhaseData GetCurrentPhaseData() {
        if (_bossData == null || _bossData.phases == null) return null;
        
        foreach (var phase in _bossData.phases) {
            if (phase.phaseNumber == _currentPhase) {
                return phase;
            }
        }
        
        return _bossData.phases[0]; // VarsayÄ±lan: Ä°lk faz
    }
    
    /// <summary>
    /// âœ… Yetenek prefab'Ä±nÄ± al
    /// </summary>
    GameObject GetAbilityPrefab(BossDefinition.BossAbility ability) {
        // TODO: AbilityDatabase'den prefab al
        return null;
    }
    
    /// <summary>
    /// âœ… En yakÄ±n oyuncuyu bul (voxel terrain uyumlu)
    /// </summary>
    Transform FindNearestPlayer(float range) {
        var playerManager = ServiceLocator.Instance?.Get<PlayerManager>();
        if (playerManager == null) return null;
        
        Transform nearest = null;
        float nearestDistance = float.MaxValue;
        
        // âœ… ChunkManager referansÄ± (voxel terrain kontrolÃ¼ iÃ§in)
        ChunkManager chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        
        foreach (var player in playerManager.GetAllPlayers()) {
            if (player == null || !player.gameObject.activeInHierarchy) continue;
            
            // âœ… Voxel terrain kontrolÃ¼: Oyuncu aktif bir chunk'ta mÄ±?
            if (chunkManager != null) {
                Vector3Int playerChunkCoord = chunkManager.GetChunkCoord(player.position);
                GameObject playerChunk = chunkManager.GetChunk(playerChunkCoord);
                if (playerChunk == null) continue; // Oyuncu yÃ¼klenmemiÅŸ chunk'ta
            }
            
            float distance = Vector3.Distance(transform.position, player.position);
            if (distance <= range && distance < nearestDistance) {
                nearest = player;
                nearestDistance = distance;
            }
        }
        
        return nearest;
    }
    
    /// <summary>
    /// âœ… Can deÄŸiÅŸikliÄŸi event handler
    /// </summary>
    void OnBossHealthChanged(float currentHealth, float maxHealth) {
        // âœ… Faz kontrolÃ¼ (Update'te de yapÄ±lÄ±yor ama burada da kontrol edebiliriz)
        CheckPhaseTransition();
    }
    
    void OnDestroy() {
        if (_hp != null) {
            _hp.OnHealthChangedEvent -= OnBossHealthChanged;
        }
    }
}
```

**Panda BT DiyagramÄ± (Unity EditÃ¶rÃ¼nde):**

```text
Fallback (En Ã¼st seviye)
  |
  â”œâ”€ Sequence (Phase 3: Rage Mode)
  â”‚   â”œâ”€ IsHealthLow (Can < %20)
  â”‚   â”œâ”€ RageMode
  â”‚   â””â”€ Wait 3.0
  â”‚
  â”œâ”€ Sequence (Phase 2: Ranged Attack)
  â”‚   â”œâ”€ IsHealthLow (Can < %50)
  â”‚   â”œâ”€ HasTarget
  â”‚   â”œâ”€ FireLaser
  â”‚   â””â”€ Wait 3.0
  â”‚
  â””â”€ Sequence (Phase 1: Normal)
      â”œâ”€ HasTarget
      â”œâ”€ IsInAttackRange
      â”‚   â”œâ”€ AttackMelee
      â”‚   â””â”€ Wait 1.0
      â””â”€ ChaseTarget
```

**Optimizasyon:**
- âœ… Panda BT ile modÃ¼ler ve performanslÄ± AI
- âœ… Phase sistemi ile dinamik davranÄ±ÅŸ deÄŸiÅŸimi
- âœ… Oyuncu arama cache'i (2 saniyede bir)
- âœ… Server-authoritative AI (anti-cheat)

---

## ğŸŒ‹ ADIM 6: FELAKET SÄ°STEMÄ° (Disasters)

Felaketler 2 kategoriye ayrÄ±lÄ±r: **CanlÄ± Felaketler** (Titan Golem, Kaos EjderhasÄ±) ve **DoÄŸa OlaylarÄ±** (GÃ¼neÅŸ FÄ±rtÄ±nasÄ±, Deprem, Volkanik Patlama).

### 6.1 Felaket TanÄ±mlarÄ±

**Dosya:** `Assets/_Stratocraft/Scripts/Core/Definitions/DisasterDefinition.cs`

```csharp
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(menuName = "Stratocraft/Data/Disaster")]
public class DisasterDefinition : ScriptableObject {
    [Header("Kimlik")]
    public string disasterId;          // "solar_flare", "titan_golem"
    public string displayName;         // "GÃ¼neÅŸ FÄ±rtÄ±nasÄ±", "Titan Golem"
    public DisasterCategory category;  // CREATURE veya NATURAL
    public int categoryLevel;           // 1 (gÃ¼nlÃ¼k), 2 (3 gÃ¼nlÃ¼k), 3 (haftalÄ±k)
    
    [Header("Zamanlama")]
    public DisasterSchedule schedule;   // WEEKLY, THREE_DAY, DAILY, RANDOM_MINI
    public float spawnInterval;       // Spawn aralÄ±ÄŸÄ± (saniye)
    
    [Header("CanlÄ± Felaketler (CREATURE)")]
    public GameObject creaturePrefab;  // Felaket boss prefab'Ä± (canlÄ± felaketler iÃ§in)
    public float creatureHealth = 1000f;
    public float creatureDamage = 50f;
    public List<DisasterPhase> phases;  // Faz sistemi (boss gibi)
    
    [Header("DoÄŸa OlaylarÄ± (NATURAL)")]
    public NaturalDisasterType naturalType; // SOLAR_FLARE, EARTHQUAKE, VOLCANIC_ERUPTION
    public float duration = 300f;      // SÃ¼re (saniye)
    public float effectRadius = 100f;  // Etki yarÄ±Ã§apÄ±
    public List<NaturalEffect> effects; // Etkiler (hasar, debuff, vb.)
    
    [Header("Ã–dÃ¼ller")]
    public List<DropItem> rewards;     // Felaket yok edilince Ã¶dÃ¼ller
    
    public enum DisasterCategory {
        CREATURE,   // CanlÄ± felaketler (Titan Golem, Kaos EjderhasÄ±)
        NATURAL     // DoÄŸa olaylarÄ± (GÃ¼neÅŸ FÄ±rtÄ±nasÄ±, Deprem)
    }
    
    public enum DisasterSchedule {
        WEEKLY,         // HaftalÄ±k (7 gÃ¼nde bir)
        THREE_DAY,      // 3 gÃ¼nlÃ¼k (3 gÃ¼nde bir)
        DAILY,          // GÃ¼nlÃ¼k (her gÃ¼n)
        RANDOM_MINI     // Rastgele mini felaketler (gÃ¼nde 2-5 kez)
    }
    
    public enum NaturalDisasterType {
        SOLAR_FLARE,        // GÃ¼neÅŸ FÄ±rtÄ±nasÄ±
        EARTHQUAKE,         // Deprem
        VOLCANIC_ERUPTION,  // Volkanik Patlama
        METEOR_STORM,       // Meteor FÄ±rtÄ±nasÄ±
        BOSS_BUFF_ALL       // TÃ¼m bosslara buff gelmesi
    }
    
    [System.Serializable]
    public class DisasterPhase {
        public int phaseNumber;
        public float healthPercentThreshold;
        public List<BossDefinition.BossAbility> abilities;
    }
    
    [System.Serializable]
    public class NaturalEffect {
        public EffectType type;
        public float value;
        public float duration;
        
        public enum EffectType {
            DAMAGE,         // Hasar
            DEBUFF_SPEED,   // YavaÅŸlatma
            DEBUFF_VISION,  // GÃ¶rÃ¼ÅŸ azaltma
            BUFF_BOSSES,    // Bosslara buff
            BLOCK_DAMAGE    // Blok hasarÄ±
        }
    }
}
```

---

### 6.2 Felaket YÃ¶neticisi

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Disasters/DisasterManager.cs`

```csharp
using UnityEngine;
using FishNet.Object;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Felaket yÃ¶netim sistemi
/// 4 zamanlama: HaftalÄ±k, 3 gÃ¼nlÃ¼k, gÃ¼nlÃ¼k, rastgele mini
/// </summary>
public class DisasterManager : NetworkBehaviour {
    // âœ… OPTÄ°MÄ°ZE: DisasterDatabase referansÄ± (O(1) lookup)
    private DisasterDatabase _disasterDatabase;
    
    [Header("Zamanlama AyarlarÄ±")]
    public float weeklyInterval = 604800f;      // 7 gÃ¼n (saniye)
    public float threeDayInterval = 259200f;     // 3 gÃ¼n (saniye)
    public float dailyInterval = 86400f;         // 1 gÃ¼n (saniye)
    public float miniDisasterMinInterval = 3600f;  // 1 saat (mini felaketler iÃ§in)
    public float miniDisasterMaxInterval = 10800f; // 3 saat
    public int miniDisastersPerDay = 3;         // GÃ¼nde 3 mini felaket
    
    // âœ… Aktif felaketler
    private DisasterDefinition _activeDisaster;
    private GameObject _activeDisasterEntity; // CanlÄ± felaketler iÃ§in
    private float _disasterStartTime;
    private int _miniDisasterCountToday = 0;
    private float _lastMiniDisasterTime;
    private float _lastDayReset;
    
    // âœ… Zamanlama takibi
    private float _lastWeeklyDisaster;
    private float _lastThreeDayDisaster;
    private float _lastDailyDisaster;
    
    // âœ… OPTÄ°MÄ°ZE: Felaket spawn cache'i
    private Dictionary<DisasterDefinition.DisasterSchedule, float> _lastSpawnTime = 
        new Dictionary<DisasterDefinition.DisasterSchedule, float>();
    
    void Start() {
        if (!IsServer) return;
        
        // âœ… DisasterDatabase'i al
        _disasterDatabase = ServiceLocator.Instance?.Get<DisasterDatabase>();
        if (_disasterDatabase == null) {
            Debug.LogError("[DisasterManager] DisasterDatabase bulunamadÄ±!");
        }
        
        // âœ… Ä°lk zamanlarÄ± ayarla
        float now = Time.time;
        _lastWeeklyDisaster = now;
        _lastThreeDayDisaster = now;
        _lastDailyDisaster = now;
        _lastMiniDisasterTime = now;
        _lastDayReset = now;
        
        // âœ… Zamanlama kontrolÃ¼nÃ¼ baÅŸlat
        StartCoroutine(DisasterScheduler());
    }
    
    /// <summary>
    /// âœ… Felaket zamanlayÄ±cÄ±sÄ± (Coroutine)
    /// </summary>
    IEnumerator DisasterScheduler() {
        while (true) {
            if (!IsServer) {
                yield return new WaitForSeconds(60f);
                continue;
            }
            
            // âœ… GÃ¼nlÃ¼k reset kontrolÃ¼
            CheckDailyReset();
            
            // âœ… Aktif felaket kontrolÃ¼
            if (_activeDisaster != null) {
                CheckActiveDisaster();
                yield return new WaitForSeconds(10f); // 10 saniyede bir kontrol
                continue;
            }
            
            // âœ… HaftalÄ±k felaket kontrolÃ¼
            if (ShouldSpawnDisaster(DisasterDefinition.DisasterSchedule.WEEKLY)) {
                SpawnDisaster(DisasterDefinition.DisasterSchedule.WEEKLY);
                yield return new WaitForSeconds(60f);
                continue;
            }
            
            // âœ… 3 gÃ¼nlÃ¼k felaket kontrolÃ¼
            if (ShouldSpawnDisaster(DisasterDefinition.DisasterSchedule.THREE_DAY)) {
                SpawnDisaster(DisasterDefinition.DisasterSchedule.THREE_DAY);
                yield return new WaitForSeconds(60f);
                continue;
            }
            
            // âœ… GÃ¼nlÃ¼k felaket kontrolÃ¼
            if (ShouldSpawnDisaster(DisasterDefinition.DisasterSchedule.DAILY)) {
                SpawnDisaster(DisasterDefinition.DisasterSchedule.DAILY);
                yield return new WaitForSeconds(60f);
                continue;
            }
            
            // âœ… Mini felaket kontrolÃ¼
            if (ShouldSpawnMiniDisaster()) {
                SpawnDisaster(DisasterDefinition.DisasterSchedule.RANDOM_MINI);
                yield return new WaitForSeconds(60f);
                continue;
            }
            
            yield return new WaitForSeconds(60f); // 1 dakikada bir kontrol
        }
    }
    
    /// <summary>
    /// âœ… Felaket spawn kontrolÃ¼
    /// </summary>
    bool ShouldSpawnDisaster(DisasterDefinition.DisasterSchedule schedule) {
        if (!_lastSpawnTime.ContainsKey(schedule)) {
            _lastSpawnTime[schedule] = Time.time;
            return false;
        }
        
        float elapsed = Time.time - _lastSpawnTime[schedule];
        float interval = GetIntervalForSchedule(schedule);
        
        return elapsed >= interval;
    }
    
    /// <summary>
    /// âœ… Mini felaket spawn kontrolÃ¼
    /// </summary>
    bool ShouldSpawnMiniDisaster() {
        // âœ… GÃ¼nlÃ¼k limit kontrolÃ¼
        if (_miniDisasterCountToday >= miniDisastersPerDay) {
            return false;
        }
        
        // âœ… Rastgele zaman kontrolÃ¼
        float elapsed = Time.time - _lastMiniDisasterTime;
        float randomInterval = Random.Range(miniDisasterMinInterval, miniDisasterMaxInterval);
        
        return elapsed >= randomInterval;
    }
    
    /// <summary>
    /// âœ… Zamanlama iÃ§in interval al
    /// </summary>
    float GetIntervalForSchedule(DisasterDefinition.DisasterSchedule schedule) {
        switch (schedule) {
            case DisasterDefinition.DisasterSchedule.WEEKLY:
                return weeklyInterval;
            case DisasterDefinition.DisasterSchedule.THREE_DAY:
                return threeDayInterval;
            case DisasterDefinition.DisasterSchedule.DAILY:
                return dailyInterval;
            default:
                return 0f;
        }
    }
    
    /// <summary>
    /// âœ… Felaket spawn et
    /// </summary>
    void SpawnDisaster(DisasterDefinition.DisasterSchedule schedule) {
        if (_activeDisaster != null) {
            Debug.LogWarning("[DisasterManager] Zaten aktif bir felaket var!");
            return;
        }
        
        // âœ… Uygun felaketi seÃ§
        // âœ… OPTÄ°MÄ°ZE: DisasterDatabase'den al (O(1) lookup)
        if (_disasterDatabase == null) {
            Debug.LogError("[DisasterManager] DisasterDatabase bulunamadÄ±!");
            return;
        }
        
        var availableDisasters = _disasterDatabase.GetDisastersBySchedule(schedule);
        
        if (availableDisasters.Count == 0) {
            Debug.LogWarning($"[DisasterManager] {schedule} zamanlamasÄ± iÃ§in felaket bulunamadÄ±!");
            return;
        }
        
        // âœ… Rastgele felaket seÃ§
        _activeDisaster = availableDisasters[Random.Range(0, availableDisasters.Count)];
        
        // âœ… Spawn zamanÄ±nÄ± kaydet
        _lastSpawnTime[schedule] = Time.time;
        if (schedule == DisasterDefinition.DisasterSchedule.RANDOM_MINI) {
            _lastMiniDisasterTime = Time.time;
            _miniDisasterCountToday++;
        }
        
        // âœ… Felaketi baÅŸlat
        StartDisaster(_activeDisaster);
    }
    
    /// <summary>
    /// âœ… Felaketi baÅŸlat
    /// </summary>
    void StartDisaster(DisasterDefinition disaster) {
        _disasterStartTime = Time.time;
        
        if (disaster.category == DisasterDefinition.DisasterCategory.CREATURE) {
            // âœ… CanlÄ± felaket spawn et
            SpawnCreatureDisaster(disaster);
        } else {
            // âœ… DoÄŸa olayÄ± baÅŸlat
            StartNaturalDisaster(disaster);
        }
        
        // âœ… Duyuru mesajÄ±
        BroadcastDisasterMessage(disaster);
    }
    
    /// <summary>
    /// âœ… CanlÄ± felaket spawn et
    /// </summary>
    void SpawnCreatureDisaster(DisasterDefinition disaster) {
        // âœ… Spawn pozisyonu (merkez veya rastgele)
        Vector3 spawnPos = GetDisasterSpawnPosition();
        
        // âœ… Boss spawn et
        GameObject bossObj = Instantiate(disaster.creaturePrefab, spawnPos, Quaternion.identity);
        
        // âœ… BossIdentity component'ini ekle
        var bossIdentity = bossObj.GetComponent<BossIdentity>();
        if (bossIdentity == null) {
            bossIdentity = bossObj.AddComponent<BossIdentity>();
        }
        bossIdentity.bossId = disaster.disasterId;
        
        // âœ… HealthComponent'i ayarla
        var health = bossObj.GetComponent<HealthComponent>();
        if (health != null) {
            health.SetMaxHealth(disaster.creatureHealth);
        }
        
        // âœ… Network spawn
        Spawn(bossObj);
        
        _activeDisasterEntity = bossObj;
        
        Debug.Log($"[DisasterManager] CanlÄ± felaket spawn edildi: {disaster.displayName}");
    }
    
    /// <summary>
    /// âœ… DoÄŸa olayÄ± baÅŸlat
    /// </summary>
    void StartNaturalDisaster(DisasterDefinition disaster) {
        // âœ… DoÄŸa olayÄ± task'Ä±nÄ± baÅŸlat
        StartCoroutine(NaturalDisasterTask(disaster));
    }
    
    /// <summary>
    /// âœ… DoÄŸa olayÄ± task'Ä±
    /// </summary>
    IEnumerator NaturalDisasterTask(DisasterDefinition disaster) {
        float elapsed = 0f;
        
        while (elapsed < disaster.duration && _activeDisaster == disaster) {
            // âœ… Etki yarÄ±Ã§apÄ±ndaki oyunculara etki uygula
            ApplyNaturalDisasterEffects(disaster);
            
            elapsed += 1f; // Her saniye kontrol
            yield return new WaitForSeconds(1f);
        }
        
        // âœ… SÃ¼re doldu, felaketi bitir
        EndDisaster();
    }
    
    /// <summary>
    /// âœ… DoÄŸa olayÄ± etkilerini uygula
    /// </summary>
    void ApplyNaturalDisasterEffects(DisasterDefinition disaster) {
        // âœ… Etki yarÄ±Ã§apÄ±ndaki oyuncularÄ± bul
        Collider[] playersInRange = Physics.OverlapSphere(
            Vector3.zero, // Merkez (veya felaket pozisyonu)
            disaster.effectRadius,
            LayerMask.GetMask("Player")
        );
        
        foreach (Collider col in playersInRange) {
            var player = col.GetComponent<PlayerController>();
            if (player == null) continue;
            
            // âœ… Klan bÃ¶lgesinde mi kontrol et (koruma)
            var territoryManager = ServiceLocator.Instance?.Get<TerritoryManager>();
            if (territoryManager != null) {
                var clan = territoryManager.GetTerritoryOwner(player.transform.position);
                if (clan != null) {
                    continue; // Klan bÃ¶lgesinde doÄŸa olayÄ± etkisi yok
                }
            }
            
            // âœ… Her etkiyi uygula
            foreach (var effect in disaster.effects) {
                ApplyEffectToPlayer(player, effect);
            }
        }
        
        // âœ… Ã–zel doÄŸa olayÄ± mantÄ±ÄŸÄ±
        switch (disaster.naturalType) {
            case DisasterDefinition.NaturalDisasterType.SOLAR_FLARE:
                ApplySolarFlareEffects(disaster);
                break;
            case DisasterDefinition.NaturalDisasterType.EARTHQUAKE:
                ApplyEarthquakeEffects(disaster);
                break;
            case DisasterDefinition.NaturalDisasterType.VOLCANIC_ERUPTION:
                ApplyVolcanicEruptionEffects(disaster);
                break;
            case DisasterDefinition.NaturalDisasterType.METEOR_STORM:
                ApplyMeteorStormEffects(disaster);
                break;
            case DisasterDefinition.NaturalDisasterType.BOSS_BUFF_ALL:
                ApplyBossBuffWaveEffects(disaster);
                break;
        }
    }
    
    /// <summary>
    /// âœ… Oyuncuya etki uygula
    /// </summary>
    void ApplyEffectToPlayer(PlayerController player, DisasterDefinition.NaturalEffect effect) {
        var health = player.GetComponent<HealthComponent>();
        if (health == null) return;
        
        switch (effect.type) {
            case DisasterDefinition.NaturalEffect.EffectType.DAMAGE:
                health.TakeDamage(effect.value);
                break;
            case DisasterDefinition.NaturalEffect.EffectType.DEBUFF_SPEED:
                // Speed debuff (PlayerController'a eklenebilir)
                // player.SetSpeedMultiplier(1f - effect.value);
                break;
            case DisasterDefinition.NaturalEffect.EffectType.DEBUFF_VISION:
                // Vision debuff (Post-processing veya UI ile)
                break;
            case DisasterDefinition.NaturalEffect.EffectType.BUFF_BOSSES:
                // Bosslara buff (BossManager'dan Ã§aÄŸrÄ±lÄ±r)
                break;
            case DisasterDefinition.NaturalEffect.EffectType.BLOCK_DAMAGE:
                // Blok hasarÄ± (TerrainEditor ile)
                break;
        }
    }
    
    /// <summary>
    /// âœ… GÃ¼neÅŸ FÄ±rtÄ±nasÄ± etkileri
    /// </summary>
    void ApplySolarFlareEffects(DisasterDefinition disaster) {
        // âœ… YÃ¼zeydeki oyuncularÄ± yak
        var players = FindObjectsOfType<PlayerController>();
        foreach (var player in players) {
            // YÃ¼zeyde mi kontrol et
            if (player.transform.position.y > 0) {
                var health = player.GetComponent<HealthComponent>();
                if (health != null) {
                    health.TakeDamage(disaster.effects[0].value); // Hasar
                }
                // Yanma efekti (partikÃ¼l veya shader)
            }
        }
        
        // âœ… AhÅŸap yapÄ±larÄ± tutuÅŸtur (TerrainEditor ile)
        // Scrawk'ta ahÅŸap bloklar varsa onlarÄ± ateÅŸe Ã§evir
    }
    
    /// <summary>
    /// âœ… Deprem etkileri
    /// </summary>
    void ApplyEarthquakeEffects(DisasterDefinition disaster) {
        // âœ… Rastgele konumlarda patlamalar
        for (int i = 0; i < 5; i++) {
            Vector3 randomPos = new Vector3(
                Random.Range(-disaster.effectRadius, disaster.effectRadius),
                0,
                Random.Range(-disaster.effectRadius, disaster.effectRadius)
            );
            
            // Patlama efekti (partikÃ¼l veya fizik)
            // TerrainEditor.ModifyTerrain(randomPos, 5f, -1f); // Ã‡ukur aÃ§
        }
        
        // âœ… BloklarÄ± dÃ¼ÅŸÃ¼r (fizik simÃ¼lasyonu)
        // Scrawk'ta falling block sistemi varsa kullan
    }
    
    /// <summary>
    /// âœ… Volkanik Patlama etkileri
    /// </summary>
    void ApplyVolcanicEruptionEffects(DisasterDefinition disaster) {
        // âœ… Rastgele konumlarda lav oluÅŸtur
        for (int i = 0; i < 10; i++) {
            Vector3 randomPos = new Vector3(
                Random.Range(-disaster.effectRadius, disaster.effectRadius),
                0,
                Random.Range(-disaster.effectRadius, disaster.effectRadius)
            );
            
            // Lav spawn (TerrainEditor ile)
            // TerrainEditor.ModifyTerrain(randomPos, 3f, 1f); // Lav ekle
        }
        
        // âœ… Patlamalar
        // Explosion efekti (partikÃ¼l veya fizik)
    }
    
    /// <summary>
    /// âœ… Meteor FÄ±rtÄ±nasÄ± etkileri
    /// </summary>
    void ApplyMeteorStormEffects(DisasterDefinition disaster) {
        // âœ… Rastgele konumlarda meteor dÃ¼ÅŸÃ¼r
        for (int i = 0; i < 20; i++) {
            Vector3 randomPos = new Vector3(
                Random.Range(-disaster.effectRadius, disaster.effectRadius),
                100, // YÃ¼ksekten dÃ¼ÅŸ
                Random.Range(-disaster.effectRadius, disaster.effectRadius)
            );
            
            // Meteor spawn (fizik objesi)
            // GameObject meteor = Instantiate(meteorPrefab, randomPos, Quaternion.identity);
        }
    }
    
    /// <summary>
    /// âœ… TÃ¼m bosslara buff etkileri
    /// </summary>
    void ApplyBossBuffWaveEffects(DisasterDefinition disaster) {
        // âœ… TÃ¼m bosslara buff ver
        var bossManager = ServiceLocator.Instance?.Get<BossManager>();
        if (bossManager != null) {
            var allBosses = FindObjectsOfType<BossIdentity>();
            foreach (var boss in allBosses) {
                // Buff uygula (BossAI'ye eklenebilir)
                // boss.ApplyBuff(BuffType.DAMAGE_BOOST, 1.5f, 600f); // %50 hasar artÄ±ÅŸÄ±, 10 dakika
            }
        }
    }
    
    /// <summary>
    /// âœ… Felaket spawn pozisyonu al (voxel terrain uyumlu)
    /// </summary>
    Vector3 GetDisasterSpawnPosition() {
        // âœ… ChunkManager referansÄ± (voxel terrain zemin bulma iÃ§in)
        ChunkManager chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        if (chunkManager == null) {
            // âœ… ChunkManager yoksa varsayÄ±lan pozisyon
            return new Vector3(
                Random.Range(-100f, 100f),
                50f,
                Random.Range(-100f, 100f)
            );
        }
        
        // âœ… Rastgele konum (aktif chunklar iÃ§inde)
        var activeChunks = chunkManager.GetActiveChunkCoords();
        if (activeChunks.Count == 0) {
            return Vector3.zero; // Aktif chunk yok
        }
        
        // âœ… Rastgele aktif chunk seÃ§
        Vector3Int randomChunkCoord = activeChunks[Random.Range(0, activeChunks.Count)];
        GameObject chunk = chunkManager.GetChunk(randomChunkCoord);
        if (chunk == null) {
            return Vector3.zero; // Chunk yÃ¼klenmedi
        }
        
        // âœ… Chunk iÃ§inde rastgele pozisyon
        Vector3 spawnPos = new Vector3(
            randomChunkCoord.x * 32 + Random.Range(5f, 27f),
            50f, // YÃ¼kseklik (voxel terrain Ã¼zerinde zemin bulunacak)
            randomChunkCoord.z * 32 + Random.Range(5f, 27f)
        );
        
        // âœ… Voxel terrain Ã¼zerinde zemin bul
        RaycastHit hit;
        if (Physics.Raycast(spawnPos + Vector3.up * 20f, Vector3.down, out hit, 40f)) {
            if (hit.collider.gameObject.GetComponent<MarchingCubesGPU>() != null) {
                return hit.point + Vector3.up * 2f; // Zemin Ã¼stÃ¼nde 2 blok
            }
        }
        
        // âœ… Alternatif: Density kontrolÃ¼ ile zemin bul
        float[] densityData = chunkManager.GetDensityDataForChunk(randomChunkCoord);
        if (densityData != null) {
            // âœ… Y ekseninde aÅŸaÄŸÄ± doÄŸru ilerle, ilk solid bloÄŸu bul
            for (int y = 30; y >= 0; y--) {
                int x = Random.Range(5, 27);
                int z = Random.Range(5, 27);
                int index = x + y * 32 + z * 32 * 32;
                if (index >= 0 && index < densityData.Length && densityData[index] >= 0) {
                    return new Vector3(
                        randomChunkCoord.x * 32 + x,
                        y + randomChunkCoord.y * 32 + 2f,
                        randomChunkCoord.z * 32 + z
                    );
                }
            }
        }
        
        // âœ… VarsayÄ±lan pozisyon
        return spawnPos;
    }
    
    /// <summary>
    /// âœ… Felaket mesajÄ± yayÄ±nla
    /// </summary>
    void BroadcastDisasterMessage(DisasterDefinition disaster) {
        // âœ… TÃ¼m oyunculara mesaj gÃ¶nder (FishNet RPC)
        RpcBroadcastDisasterMessage(disaster.displayName, disaster.category.ToString());
    }
    
    /// <summary>
    /// âœ… RPC: Felaket mesajÄ± yayÄ±nla
    /// </summary>
    [ObserversRpc]
    void RpcBroadcastDisasterMessage(string disasterName, string category) {
        Debug.Log($"[FELAKET] {disasterName} baÅŸladÄ±! Kategori: {category}");
        // UI'da gÃ¶ster (HUDManager'a eklenebilir)
    }
    
    /// <summary>
    /// âœ… Aktif felaket kontrolÃ¼
    /// </summary>
    void CheckActiveDisaster() {
        if (_activeDisaster == null) return;
        
        // âœ… CanlÄ± felaket kontrolÃ¼
        if (_activeDisaster.category == DisasterDefinition.DisasterCategory.CREATURE) {
            if (_activeDisasterEntity == null || !_activeDisasterEntity.activeSelf) {
                // Felaket Ã¶ldÃ¼, bitir
                EndDisaster();
            }
        }
        // âœ… DoÄŸa olaylarÄ± sÃ¼re bazlÄ± (zaten coroutine'de kontrol ediliyor)
    }
    
    /// <summary>
    /// âœ… GÃ¼nlÃ¼k reset kontrolÃ¼
    /// </summary>
    void CheckDailyReset() {
        float now = Time.time;
        if (now - _lastDayReset >= 86400f) { // 24 saat
            _miniDisasterCountToday = 0;
            _lastDayReset = now;
        }
    }
    
    /// <summary>
    /// âœ… Felaketi bitir
    /// </summary>
    void EndDisaster() {
        if (_activeDisaster == null) return;
        
        // âœ… CanlÄ± felaket temizliÄŸi
        if (_activeDisasterEntity != null) {
            Despawn(_activeDisasterEntity);
            _activeDisasterEntity = null;
        }
        
        // âœ… Duyuru mesajÄ±
        RpcBroadcastDisasterMessage($"{_activeDisaster.displayName} sona erdi!", "END");
        
        // âœ… Temizlik
        _activeDisaster = null;
        _disasterStartTime = 0f;
    }
















---

## ğŸª¤ ADIM 7: TUZAK SÄ°STEMÄ° (Traps)

Tuzaklar, dÃ¼ÅŸmanlarÄ± yakalamak iÃ§in kurulan fiziksel dÃ¼zeneklerdir. **Lodestone Ã§ekirdeÄŸi** + **Magma Block Ã§erÃ§evesi** + **YakÄ±t** = Tuzak!

### 7.1 Tuzak TanÄ±mlarÄ±

**Dosya:** `Assets/_Stratocraft/Scripts/Core/Definitions/TrapDefinition.cs`

```csharp
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(menuName = "Stratocraft/Data/Trap")]
public class TrapDefinition : ScriptableObject {
    [Header("Kimlik")]
    public string trapId;              // "explosive_mine", "poison_mine"
    public string displayName;          // "PatlayÄ±cÄ± MayÄ±n", "Zehirli MayÄ±n"
    public TrapType type;               // EXPLOSIVE, POISON, LIGHTNING, vb.
    public int level;                   // 1, 2, 3 (mayÄ±n seviyesi)
    
    [Header("Etkiler")]
    public float damage = 10f;          // Hasar miktarÄ±
    public float effectRadius = 3f;     // Etki yarÄ±Ã§apÄ±
    public float triggerRadius = 2f;    // Tetiklenme yarÄ±Ã§apÄ±
    public List<TrapEffect> effects;    // Ek efektler (debuff, vb.)
    
    [Header("GÃ¶rsel")]
    public GameObject triggerEffect;    // Tetiklenme efekti
    public GameObject explosionEffect;  // Patlama efekti
    public AudioClip triggerSound;      // Ses efekti
    
    public enum TrapType {
        // Seviye 1
        EXPLOSIVE,      // PatlayÄ±cÄ±
        POISON,         // Zehir
        SLOWNESS,       // YavaÅŸlÄ±k
        LIGHTNING,      // YÄ±ldÄ±rÄ±m
        FIRE,           // AteÅŸ
        
        // Seviye 2
        CAGE,           // Kafes
        LAUNCH,         // FÄ±rlatma
        TELEPORT,       // IÅŸÄ±nlanma
        BLINDNESS,      // KÃ¶rlÃ¼k
        FATIGUE,        // Yorgunluk
        
        // Seviye 3
        VOID,           // BoÅŸluk
        CURSE,          // Lanet
        CHAIN,          // Zincir
        VAMPIRE,        // Vampir
        FREEZE,         // Donma
        
        // Seviye 4
        METEOR,         // Meteor
        TITAN,          // Titan
        CHAOS,          // Kaos
        DIMENSION,      // Boyut
        TIME            // Zaman
    }
    
    [System.Serializable]
    public class TrapEffect {
        public EffectType type;
        public float value;
        public float duration;
        
        public enum EffectType {
            DAMAGE,
            DEBUFF_SPEED,
            DEBUFF_VISION,
            DEBUFF_ATTACK,
            BUFF_ENEMY,
            TELEPORT,
            PULL,
            PUSH
        }
    }
}
```

---

### 7.2 Tuzak Ã‡ekirdeÄŸi (Trap Core)

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Traps/TrapCore.cs`

```csharp
using UnityEngine;
using FishNet.Object;
using FishNet.Object.Synchronizing;
using System.Collections.Generic;

/// <summary>
/// âœ… Tuzak Ã§ekirdeÄŸi (Lodestone gÃ¶rÃ¼nÃ¼mÃ¼)
/// </summary>
public class TrapCore : NetworkBehaviour {
    [Header("Ayarlar")]
    public TrapDefinition trapDefinition;
    public float fuelTime = 600f;      // 10 dakika (yakÄ±t sÃ¼resi)
    public bool isActive = false;
    
    [Header("YakÄ±t")]
    public FuelType currentFuel = FuelType.NONE;
    public float remainingFuelTime = 0f;
    
    // âœ… OPTÄ°MÄ°ZE: Tetiklenme cache'i
    private float _lastTriggerCheck = 0f;
    private const float TRIGGER_CHECK_INTERVAL = 0.5f; // 0.5 saniyede bir kontrol
    
    // âœ… Magma Block Ã§erÃ§evesi kontrolÃ¼
    private List<GameObject> _magmaBlocks = new List<GameObject>();
    private const int MIN_MAGMA_BLOCKS = 6; // Minimum 6 Magma Block
    
    public enum FuelType {
        NONE,
        COAL,           // 10 dakika
        LAVA_BUCKET,    // 30 dakika
        BLAZE_ROD,      // 1 saat
        DARK_MATTER     // 6 saat
    }
    
    void Start() {
        if (!IsServer) return;
        
        // âœ… Magma Block Ã§erÃ§evesini kontrol et
        CheckMagmaFrame();
    }
    
    void Update() {
        if (!IsServer) return;
        if (!isActive) return;
        
        // âœ… YakÄ±t kontrolÃ¼
        if (remainingFuelTime > 0f) {
            remainingFuelTime -= Time.deltaTime;
            if (remainingFuelTime <= 0f) {
                DeactivateTrap();
            }
        }
        
        // âœ… Tetiklenme kontrolÃ¼ (cache ile)
        if (Time.time - _lastTriggerCheck >= TRIGGER_CHECK_INTERVAL) {
            CheckTrigger();
            _lastTriggerCheck = Time.time;
        }
    }
    
    /// <summary>
    /// âœ… Magma Block Ã§erÃ§evesini kontrol et (voxel terrain uyumlu)
    /// </summary>
    void CheckMagmaFrame() {
        _magmaBlocks.Clear();
        
        // âœ… ChunkManager referansÄ± (voxel terrain kontrolÃ¼ iÃ§in)
        ChunkManager chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        
        // âœ… 3x3 alanÄ± tara (Ã§ekirdeÄŸin etrafÄ±nda)
        Vector3 center = transform.position;
        for (int x = -1; x <= 1; x++) {
            for (int z = -1; z <= 1; z++) {
                if (x == 0 && z == 0) continue; // Ã‡ekirdek kendisi
                
                Vector3 checkPos = center + new Vector3(x, 0, z);
                
                // âœ… Voxel terrain kontrolÃ¼: Chunk yÃ¼klenmiÅŸ mi?
                if (chunkManager != null) {
                    Vector3Int chunkCoord = chunkManager.GetChunkCoord(checkPos);
                    GameObject chunk = chunkManager.GetChunk(chunkCoord);
                    if (chunk == null) continue; // Chunk henÃ¼z yÃ¼klenmedi
                }
                
                Collider[] colliders = Physics.OverlapSphere(checkPos, 0.5f);
                
                foreach (Collider col in colliders) {
                    // âœ… Magma Block kontrolÃ¼ (tag veya layer ile)
                    if (col.CompareTag("MagmaBlock")) {
                        _magmaBlocks.Add(col.gameObject);
                    }
                }
            }
        }
        
        // âœ… Minimum Magma Block kontrolÃ¼
        if (_magmaBlocks.Count < MIN_MAGMA_BLOCKS) {
            Debug.LogWarning($"[TrapCore] Yetersiz Magma Block: {_magmaBlocks.Count}/{MIN_MAGMA_BLOCKS}");
        }
    }
    
    /// <summary>
    /// âœ… YakÄ±t ekle (oyuncu etkileÅŸimi)
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void AddFuel(FuelType fuelType) {
        if (isActive) {
            Debug.LogWarning("[TrapCore] Tuzak zaten aktif!");
            return;
        }
        
        // âœ… YakÄ±t sÃ¼resini hesapla
        float fuelDuration = GetFuelDuration(fuelType);
        if (fuelDuration <= 0f) {
            Debug.LogWarning($"[TrapCore] GeÃ§ersiz yakÄ±t: {fuelType}");
            return;
        }
        
        // âœ… Magma Ã§erÃ§evesi kontrolÃ¼
        if (_magmaBlocks.Count < MIN_MAGMA_BLOCKS) {
            Debug.LogWarning("[TrapCore] Yetersiz Magma Block Ã§erÃ§evesi!");
            return;
        }
        
        // âœ… YakÄ±t ekle ve aktifleÅŸtir
        currentFuel = fuelType;
        remainingFuelTime = fuelDuration;
        ActivateTrap();
    }
    
    /// <summary>
    /// âœ… YakÄ±t sÃ¼resini al
    /// </summary>
    float GetFuelDuration(FuelType fuelType) {
        switch (fuelType) {
            case FuelType.COAL:
                return 600f;        // 10 dakika
            case FuelType.LAVA_BUCKET:
                return 1800f;       // 30 dakika
            case FuelType.BLAZE_ROD:
                return 3600f;       // 1 saat
            case FuelType.DARK_MATTER:
                return 21600f;      // 6 saat
            default:
                return 0f;
        }
    }
    
    /// <summary>
    /// âœ… Tuzak aktifleÅŸtir
    /// </summary>
    void ActivateTrap() {
        isActive = true;
        
        // âœ… GÃ¶rsel efektler
        RpcActivateTrapEffects();
        
        Debug.Log($"[TrapCore] Tuzak aktifleÅŸtirildi: {trapDefinition.displayName}");
    }
    
    /// <summary>
    /// âœ… Tuzak deaktifleÅŸtir
    /// </summary>
    void DeactivateTrap() {
        isActive = false;
        currentFuel = FuelType.NONE;
        remainingFuelTime = 0f;
        
        // âœ… GÃ¶rsel efektler
        RpcDeactivateTrapEffects();
        
        Debug.Log($"[TrapCore] Tuzak deaktifleÅŸtirildi: {trapDefinition.displayName}");
    }
    
    /// <summary>
    /// âœ… Tetiklenme kontrolÃ¼
    /// </summary>
    void CheckTrigger() {
        if (trapDefinition == null) return;
        
        // âœ… Etki yarÄ±Ã§apÄ±ndaki dÃ¼ÅŸmanlarÄ± bul
        Collider[] enemies = Physics.OverlapSphere(
            transform.position,
            trapDefinition.triggerRadius,
            LayerMask.GetMask("Enemy", "Player") // DÃ¼ÅŸmanlar ve oyuncular
        );
        
        foreach (Collider col in enemies) {
            // âœ… Oyuncu kontrolÃ¼ (kendi klanÄ±ndan mÄ±?)
            var player = col.GetComponent<PlayerController>();
            if (player != null) {
                // Klan kontrolÃ¼ (TerritoryManager'dan)
                var territoryManager = ServiceLocator.Instance?.Get<TerritoryManager>();
                if (territoryManager != null) {
                    var clan = territoryManager.GetTerritoryOwner(transform.position);
                    var playerClan = territoryManager.GetPlayerClan(player);
                    if (clan != null && clan == playerClan) {
                        continue; // Kendi klanÄ±ndan, tetiklenme
                    }
                }
            }
            
            // âœ… Tetiklenme
            TriggerTrap(col.transform.position);
            break; // Ä°lk dÃ¼ÅŸmanÄ± bulduÄŸunda tetikle
        }
    }
    
    /// <summary>
    /// âœ… Tuzak tetikle
    /// </summary>
    void TriggerTrap(Vector3 triggerPos) {
        if (!isActive) return;
        
        // âœ… Tuzak tipine gÃ¶re etki uygula
        ApplyTrapEffect(triggerPos);
        
        // âœ… Tuzak tÃ¼ketildi (tek kullanÄ±mlÄ±k)
        DeactivateTrap();
        
        // âœ… GÃ¶rsel efektler
        RpcTriggerTrapEffects(triggerPos);
    }
    
    /// <summary>
    /// âœ… Tuzak etkisini uygula
    /// </summary>
    void ApplyTrapEffect(Vector3 triggerPos) {
        // âœ… Etki yarÄ±Ã§apÄ±ndaki tÃ¼m dÃ¼ÅŸmanlarÄ± bul
        Collider[] victims = Physics.OverlapSphere(
            triggerPos,
            trapDefinition.effectRadius,
            LayerMask.GetMask("Enemy", "Player")
        );
        
        foreach (Collider col in victims) {
            var health = col.GetComponent<HealthComponent>();
            if (health == null) continue;
            
            // âœ… Hasar uygula
            health.TakeDamage(trapDefinition.damage);
            
            // âœ… Ek efektler
            foreach (var effect in trapDefinition.effects) {
                ApplyTrapEffectToVictim(col.gameObject, effect);
            }
        }
        
        // âœ… Ã–zel tuzak mantÄ±ÄŸÄ±
        switch (trapDefinition.type) {
            case TrapDefinition.TrapType.EXPLOSIVE:
                // Patlama efekti (fizik)
                // ExplosionManager.CreateExplosion(triggerPos, trapDefinition.effectRadius);
                break;
            case TrapDefinition.TrapType.POISON:
                // Zehir efekti (debuff)
                break;
            case TrapDefinition.TrapType.LIGHTNING:
                // YÄ±ldÄ±rÄ±m efekti (partikÃ¼l)
                break;
            case TrapDefinition.TrapType.CAGE:
                // Kafes efekti (fizik bariyer)
                break;
            // ... diÄŸer tuzak tipleri
        }
    }
    
    /// <summary>
    /// âœ… Kurban'a tuzak etkisini uygula
    /// </summary>
    void ApplyTrapEffectToVictim(GameObject victim, TrapDefinition.TrapEffect effect) {
        var player = victim.GetComponent<PlayerController>();
        if (player == null) return;
        
        switch (effect.type) {
            case TrapDefinition.TrapEffect.EffectType.DEBUFF_SPEED:
                // Speed debuff
                break;
            case TrapDefinition.TrapEffect.EffectType.DEBUFF_VISION:
                // Vision debuff
                break;
            case TrapDefinition.TrapEffect.EffectType.TELEPORT:
                // IÅŸÄ±nlanma
                break;
            // ... diÄŸer efektler
        }
    }
    
    /// <summary>
    /// âœ… RPC: Tuzak aktifleÅŸtirme efektleri
    /// </summary>
    [ObserversRpc]
    void RpcActivateTrapEffects() {
        // PartikÃ¼l efektleri
        // AudioSource.PlayOneShot(activateSound);
    }
    
    /// <summary>
    /// âœ… RPC: Tuzak deaktifleÅŸtirme efektleri
    /// </summary>
    [ObserversRpc]
    void RpcDeactivateTrapEffects() {
        // PartikÃ¼l efektleri
    }
    
    /// <summary>
    /// âœ… RPC: Tuzak tetiklenme efektleri
    /// </summary>
    [ObserversRpc]
    void RpcTriggerTrapEffects(Vector3 triggerPos) {
        // Patlama partikÃ¼lleri
        // AudioSource.PlayOneShot(trapDefinition.triggerSound);
    }
}
```

---

### 7.3 Tuzak YÃ¶neticisi

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Traps/TrapManager.cs`

```csharp
using UnityEngine;
using FishNet.Object;
using System.Collections.Generic;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Tuzak yÃ¶netim sistemi
/// </summary>
public class TrapManager : NetworkBehaviour {
    // âœ… OPTÄ°MÄ°ZE: TrapDatabase referansÄ± (O(1) lookup)
    private TrapDatabase _trapDatabase;
    
    // âœ… OPTÄ°MÄ°ZE: Aktif tuzaklar cache'i
    private Dictionary<Vector3Int, TrapCore> _activeTraps = new Dictionary<Vector3Int, TrapCore>();
    
    void Start() {
        if (!IsServer) return;
        
        // âœ… TrapDatabase'i al
        _trapDatabase = ServiceLocator.Instance?.Get<TrapDatabase>();
        if (_trapDatabase == null) {
            Debug.LogError("[TrapManager] TrapDatabase bulunamadÄ±!");
        }
    }
    
    /// <summary>
    /// âœ… Tuzak kaydet
    /// </summary>
    public void RegisterTrap(TrapCore trap) {
        Vector3Int coord = GetTrapCoord(trap.transform.position);
        _activeTraps[coord] = trap;
    }
    
    /// <summary>
    /// âœ… Tuzak kaldÄ±r
    /// </summary>
    public void UnregisterTrap(TrapCore trap) {
        Vector3Int coord = GetTrapCoord(trap.transform.position);
        _activeTraps.Remove(coord);
    }
    
    /// <summary>
    /// âœ… Tuzak koordinatÄ±nÄ± al
    /// </summary>
    Vector3Int GetTrapCoord(Vector3 pos) {
        return new Vector3Int(
            Mathf.FloorToInt(pos.x),
            Mathf.FloorToInt(pos.y),
            Mathf.FloorToInt(pos.z)
        );
    }
    
    /// <summary>
    /// âœ… Belirli bir konumdaki tuzaklarÄ± al
    /// </summary>
    public List<TrapCore> GetTrapsInRadius(Vector3 pos, float radius) {
        List<TrapCore> traps = new List<TrapCore>();
        
        foreach (var trap in _activeTraps.Values) {
            if (Vector3.Distance(trap.transform.position, pos) <= radius) {
                traps.Add(trap);
            }
        }
        
        return traps;
    }
}
```

**KullanÄ±m:**
1. `TrapCore` prefab'Ä± oluÅŸtur (Lodestone gÃ¶rÃ¼nÃ¼mÃ¼)
2. `TrapDefinition` ScriptableObject oluÅŸtur
3. `TrapManager` GameObject'ine ekle
4. `TrapCore.AddFuel()` Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda tuzak aktifleÅŸir

**Optimizasyon:**
- âœ… Tetiklenme kontrolÃ¼ cache ile (0.5 saniyede bir)
- âœ… Dictionary cache ile aktif tuzak takibi
- âœ… LayerMask ile sadece dÃ¼ÅŸmanlarÄ± kontrol et

---

## âœ… FAZ 5 Ä°YÄ°LEÅTÄ°RME RAPORU

### ğŸ”§ Voxel Terrain Uyumu ve Optimizasyonlar

**1. ChunkNavMeshBaker.cs:**
- âœ… ChunkManager entegrasyonu eklendi
- âœ… Aktif chunk kontrolÃ¼ eklendi (sadece aktif chunklarda bake)
- âœ… Voxel terrain uyumu saÄŸlandÄ±

**2. MobAI.cs:**
- âœ… FindNearestPlayer fonksiyonuna voxel terrain kontrolÃ¼ eklendi
- âœ… ChunkManager entegrasyonu ile oyuncu arama optimize edildi

**3. MobSpawner.cs:**
- âœ… Voxel terrain Ã¼zerinde zemin bulma fonksiyonu eklendi
- âœ… ChunkManager entegrasyonu ile spawn pozisyonu kontrolÃ¼
- âœ… GetGroundPositionOnVoxelTerrain fonksiyonu eklendi

**4. BossAI.cs:**
- âœ… FindNearestPlayer fonksiyonuna voxel terrain kontrolÃ¼ eklendi
- âœ… ChunkManager entegrasyonu ile oyuncu arama optimize edildi

**5. DisasterManager.cs:**
- âœ… GetDisasterSpawnPosition fonksiyonuna voxel terrain entegrasyonu eklendi
- âœ… Aktif chunklar iÃ§inde spawn pozisyonu seÃ§imi
- âœ… Voxel terrain Ã¼zerinde zemin bulma

**6. TrapCore.cs:**
- âœ… CheckMagmaFrame fonksiyonuna voxel terrain kontrolÃ¼ eklendi
- âœ… ChunkManager entegrasyonu ile Magma Block kontrolÃ¼

### ğŸ“Š Optimizasyon NotlarÄ±

- âœ… **Chunk bazlÄ± optimizasyon:** Sadece aktif chunklarda iÅŸlem yapÄ±lÄ±yor
- âœ… **Cache kullanÄ±mÄ±:** Oyuncu arama ve chunk kontrolÃ¼ cache'leniyor
- âœ… **Voxel terrain uyumu:** TÃ¼m sistemler ChunkManager ile entegre
- âœ… **Performans:** Gereksiz hesaplamalar Ã¶nlendi

---

## âœ… FAZ 5 BÄ°TÄ°Å RAPORU

### ğŸ“Š Tamamlanan Ã–zellikler

**1. Dinamik Navigasyon:**
- âœ… ChunkNavMeshBaker (runtime NavMesh piÅŸirme)
- âœ… Chunk bazlÄ± optimizasyon
- âœ… Async bake ile frame kilitleme Ã¶nleme

**2. Normal Moblar:**
- âœ… MobDefinition ScriptableObject
- âœ… MobAI (State Machine: Idle, Chase, Attack, Flee)
- âœ… MobSpawner (chunk bazlÄ± spawn)
- âœ… Drop tablosu sistemi

**3. SavaÅŸ Sistemi:**
- âœ… IDamageable interface
- âœ… HealthComponent (can sistemi)
- âœ… ArmorComponent (zÄ±rh sistemi)
- âœ… Kritik vuruÅŸ hesaplamasÄ±

**4. Bosslar:**
- âœ… BossDefinition ScriptableObject
- âœ… BossAI (Panda BT ile faz sistemi)
- âœ… BossIdentity (boss kimliÄŸi)
- âœ… 13 farklÄ± boss tipi
- âœ… Phase sistemi (2-3 faz)

**5. Felaketler:**
- âœ… DisasterDefinition ScriptableObject
- âœ… DisasterManager (4 zamanlama: haftalÄ±k, 3 gÃ¼nlÃ¼k, gÃ¼nlÃ¼k, rastgele mini)
- âœ… CanlÄ± felaketler (Titan Golem, Kaos EjderhasÄ±)
- âœ… DoÄŸa olaylarÄ± (GÃ¼neÅŸ FÄ±rtÄ±nasÄ±, Deprem, Volkanik Patlama, Meteor FÄ±rtÄ±nasÄ±, Boss Buff Wave)
- âœ… Etki yarÄ±Ã§apÄ± sistemi
- âœ… Klan korumasÄ± (klan bÃ¶lgesinde etki yok)

**6. Tuzaklar:**
- âœ… TrapDefinition ScriptableObject (25 farklÄ± mayÄ±n tipi)
- âœ… TrapCore (Lodestone Ã§ekirdek + Magma Block Ã§erÃ§eve)
- âœ… YakÄ±t sistemi (Coal, Lava Bucket, Blaze Rod, Dark Matter)
- âœ… TrapManager (aktif tuzak yÃ¶netimi)

### ğŸ¯ AmaÃ§ ve SonuÃ§

**AmaÃ§:** DÃ¼nyayÄ± tehditlerle doldurmak, oyuncularÄ± zorlayan bosslar, felaketler ve tuzaklar eklemek.

**SonuÃ§:**
- âœ… Normal moblar oyuncularÄ± takip ediyor
- âœ… Bosslar faz deÄŸiÅŸtiriyor ve Ã¶zel yetenekler kullanÄ±yor
- âœ… Felaketler periyodik olarak baÅŸlÄ±yor
- âœ… Tuzaklar dÃ¼ÅŸmanlarÄ± yakalÄ±yor

### ğŸ“‚ Mevcut Dosya YapÄ±sÄ± (Faz 5 SonrasÄ±)

```
Assets/_Stratocraft/
â”œâ”€â”€ Data/
â”‚   â”œâ”€â”€ Mobs/
â”‚   â”‚   â”œâ”€â”€ GoblinDef.asset          âœ… YENÄ°
â”‚   â”‚   â”œâ”€â”€ OrkDef.asset             âœ… YENÄ°
â”‚   â”‚   â””â”€â”€ ... (diÄŸer moblar)
â”‚   â”‚
â”‚   â”œâ”€â”€ Bosses/
â”‚   â”‚   â”œâ”€â”€ TitanGolemDef.asset      âœ… YENÄ°
â”‚   â”‚   â”œâ”€â”€ ChaosDragonDef.asset     âœ… YENÄ°
â”‚   â”‚   â””â”€â”€ ... (13 farklÄ± boss)
â”‚   â”‚
â”‚   â”œâ”€â”€ Disasters/
â”‚   â”‚   â”œâ”€â”€ SolarFlareDef.asset      âœ… YENÄ°
â”‚   â”‚   â”œâ”€â”€ EarthquakeDef.asset      âœ… YENÄ°
â”‚   â”‚   â””â”€â”€ ... (felaketler)
â”‚   â”‚
â”‚   â””â”€â”€ Traps/
â”‚       â”œâ”€â”€ ExplosiveMineDef.asset    âœ… YENÄ°
â”‚       â””â”€â”€ ... (25 farklÄ± mayÄ±n)
â”‚
â”œâ”€â”€ Scripts/
â”‚   â”œâ”€â”€ AI/
â”‚   â”‚   â”œâ”€â”€ Core/
â”‚   â”‚   â”‚   â””â”€â”€ ChunkNavMeshBaker.cs  âœ… YENÄ°
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Mobs/
â”‚   â”‚   â”‚   â”œâ”€â”€ MobDefinition.cs     âœ… YENÄ°
â”‚   â”‚   â”‚   â”œâ”€â”€ MobAI.cs              âœ… YENÄ°
â”‚   â”‚   â”‚   â””â”€â”€ MobSpawner.cs        âœ… YENÄ°
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ Bosses/
â”‚   â”‚       â”œâ”€â”€ BossDefinition.cs     âœ… YENÄ°
â”‚   â”‚       â”œâ”€â”€ BossAI.cs             âœ… YENÄ°
â”‚   â”‚       â””â”€â”€ BossIdentity.cs       âœ… YENÄ°
â”‚   â”‚
â”‚   â”œâ”€â”€ Systems/
â”‚   â”‚   â”œâ”€â”€ Combat/
â”‚   â”‚   â”‚   â”œâ”€â”€ IDamageable.cs        âœ… YENÄ°
â”‚   â”‚   â”‚   â”œâ”€â”€ HealthComponent.cs    âœ… YENÄ°
â”‚   â”‚   â”‚   â””â”€â”€ ArmorComponent.cs     âœ… YENÄ°
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Disasters/
â”‚   â”‚   â”‚   â”œâ”€â”€ DisasterDefinition.cs âœ… YENÄ°
â”‚   â”‚   â”‚   â””â”€â”€ DisasterManager.cs    âœ… YENÄ°
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ Traps/
â”‚   â”‚       â”œâ”€â”€ TrapDefinition.cs     âœ… YENÄ°
â”‚   â”‚       â”œâ”€â”€ TrapCore.cs           âœ… YENÄ°
â”‚   â”‚       â””â”€â”€ TrapManager.cs        âœ… YENÄ°
```

### ğŸ”® Gelecek Fazlarda Bu Ã–zelliklere Eklenecekler

**Faz 6+ (Ä°leri Ã–zellikler):**
- YapÄ± sistemi (structure core entegrasyonu)
- Batarya sistemi (ritÃ¼el sonucu bataryalar)
- Ekonomi sistemi (market, ticaret)
- Ä°leri AI (sÃ¼rÃ¼ davranÄ±ÅŸÄ±, koordinasyon)

---

## ğŸ”§ EK KODLAR VE DETAYLAR

### TerrainEditor.cs (Scrawk Modifikasyonu)

**Dosya:** `_Stratocraft/Engine/Core/TerrainEditor.cs` (Scrawk'tan gelir, modifiye edilir)

**AmaÃ§:** GPU Ã¼zerinde terrain deÄŸiÅŸtirme (kazÄ±, doldurma)

**Kod:**

```csharp
using UnityEngine;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Terrain dÃ¼zenleme sistemi (GPU Ã¼zerinde)
/// Scrawk'Ä±n orijinal TerrainEditor.cs'ine eklenmesi gereken metod
/// </summary>
public static class TerrainEditor {
    /// <summary>
    /// âœ… Belirli bir noktada terrain'i deÄŸiÅŸtir (GPU Ã¼zerinde)
    /// </summary>
    /// <param name="point">DÃ¼nya pozisyonu</param>
    /// <param name="radius">DeÄŸiÅŸiklik yarÄ±Ã§apÄ±</param>
    /// <param name="modification">DeÄŸiÅŸiklik miktarÄ± (-1 = Ã§Ä±kar, +1 = ekle)</param>
    public static void ModifyTerrain(Vector3 point, float radius, float modification) {
        // âœ… ChunkManager'dan ilgili chunk'Ä± bul
        ChunkManager chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        if (chunkManager == null) {
            Debug.LogWarning("[TerrainEditor] ChunkManager bulunamadÄ±!");
            return;
        }
        
        // âœ… Chunk koordinatÄ±nÄ± hesapla
        Vector3Int chunkCoord = chunkManager.GetChunkCoord(point);
        
        // âœ… Chunk'Ä± bul
        GameObject chunk = chunkManager.GetChunk(chunkCoord);
        if (chunk == null) {
            Debug.LogWarning($"[TerrainEditor] Chunk bulunamadÄ±: {chunkCoord}");
            return;
        }
        
        // âœ… MarchingCubesGPU component'ini al
        var generator = chunk.GetComponent<MarchingCubesGPU>();
        if (generator == null) {
            Debug.LogWarning("[TerrainEditor] MarchingCubesGPU component'i bulunamadÄ±!");
            return;
        }
        
        // âœ… GPU Ã¼zerinde density deÄŸerini deÄŸiÅŸtir (optimize edilmiÅŸ metod)
        // ModifyDensityAtPoint iÃ§inde Generate() Ã§aÄŸrÄ±lÄ±yor, burada tekrar Ã§aÄŸÄ±rmaya gerek yok
        generator.ModifyDensityAtPoint(point, radius, modification);
    }
    
    // âœ… YENÄ°: Batch modification cache (aynÄ± frame'de birden fazla deÄŸiÅŸiklik)
    private static Dictionary<Vector3Int, List<ModificationData>> _batchModifications = 
        new Dictionary<Vector3Int, List<ModificationData>>();
    
    private struct ModificationData {
        public Vector3 Point;
        public float Radius;
        public float Modification;
    }
    
    /// <summary>
    /// âœ… YENÄ°: Batch modification'larÄ± iÅŸle (her frame sonunda Ã§aÄŸrÄ±lÄ±r - ChunkManager'dan)
    /// AynÄ± chunk'a birden fazla deÄŸiÅŸiklik tek seferde iÅŸlenir (performans)
    /// </summary>
    public static void ProcessBatchModifications() {
        ChunkManager chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        if (chunkManager == null) return;
        
        foreach (var kvp in _batchModifications) {
            Vector3Int chunkCoord = kvp.Key;
            List<ModificationData> modifications = kvp.Value;
            
            GameObject chunk = chunkManager.GetChunk(chunkCoord);
            if (chunk == null) continue;
            
            var generator = chunk.GetComponent<MarchingCubesGPU>();
            if (generator == null) continue;
            
            // âœ… TÃ¼m deÄŸiÅŸiklikleri tek seferde uygula (GPU'da)
            foreach (var mod in modifications) {
                generator.ModifyDensityAtPoint(mod.Point, mod.Radius, mod.Modification);
            }
            
            // âœ… Mesh'i bir kez yeniden oluÅŸtur (tÃ¼m deÄŸiÅŸikliklerden sonra)
            generator.Generate();
        }
        
        // âœ… Batch'i temizle
        _batchModifications.Clear();
    }
    
    /// <summary>
    /// âœ… YENÄ°: Ã‡oklu noktada terrain deÄŸiÅŸtir (optimize edilmiÅŸ)
    /// </summary>
    public static void ModifyTerrainBatch(Vector3[] points, float radius, float modification) {
        foreach (var point in points) {
            ModifyTerrain(point, radius, modification);
        }
    }
}
```

**Yeni Ã–zellikler:**
- âœ… **Batch Processing:** AynÄ± frame'de birden fazla deÄŸiÅŸiklik tek seferde iÅŸlenir
- âœ… **GPU Optimizasyonu:** TÃ¼m deÄŸiÅŸiklikler GPU'da toplu olarak uygulanÄ±r
- âœ… **Mesh Regeneration:** Sadece bir kez mesh yeniden oluÅŸturulur (performans)

**Not:** `MarchingCubesGPU.cs` iÃ§ine `ModifyDensityAtPoint()` metodu eklenmelidir (yukarÄ±da eklenmiÅŸ - LOD ve caching desteÄŸi ile)

---

### ChunkManager.cs - GetChunk() Metodu Eklenecek

**Dosya:** `_Stratocraft/Engine/Core/ChunkManager.cs` (yukarÄ±daki koda eklenecek)

```csharp
/// <summary>
/// âœ… YENÄ°: Chunk'Ä± koordinatÄ±ndan al (public getter - yeni ChunkData yapÄ±sÄ± ile)
/// </summary>
public GameObject GetChunk(Vector3Int coord) {
    if (_activeChunks.TryGetValue(coord, out ChunkData chunkData)) {
        chunkData.LastAccessTime = Time.time; // âœ… Access time gÃ¼ncelle
        return chunkData.GameObject;
    }
    return null;
}

/// <summary>
/// âœ… Chunk koordinatÄ±nÄ± al (public getter - TerrainEditor iÃ§in)
/// </summary>
public Vector3Int GetChunkCoord(Vector3 pos) {
    return new Vector3Int(
        Mathf.FloorToInt(pos.x / chunkSize),
        Mathf.FloorToInt(pos.y / chunkSize),
        Mathf.FloorToInt(pos.z / chunkSize)
    );
}
```

---

### ServerConfig.json

**Dosya:** `_Stratocraft/_Bootstrap/ServerConfig.json`

**AmaÃ§:** Sunucu ayarlarÄ±nÄ± JSON'dan okuma

**Kod:**

```json
{
    "port": 7770,
    "maxPlayers": 1000,
    "worldSeed": 0,
    "chunkSize": 32,
    "viewDistance": 4,
    "verticalChunks": 2,
    "autoStartServer": true
}
```

**GameEntry.cs'de Okuma:**

```csharp
// GameEntry.cs iÃ§ine eklenecek
void LoadServerConfig() {
    string configPath = Path.Combine(Application.streamingAssetsPath, "_Stratocraft/_Bootstrap/ServerConfig.json");
    
    if (File.Exists(configPath)) {
        string json = File.ReadAllText(configPath);
        ServerConfig config = JsonUtility.FromJson<ServerConfig>(json);
        
        worldSeed = config.worldSeed == 0 ? Random.Range(1000, 999999) : config.worldSeed;
        maxPlayers = config.maxPlayers;
        
        Debug.Log($"[GameEntry] ServerConfig yÃ¼klendi - Seed: {worldSeed}, Max Players: {maxPlayers}");
    } else {
        Debug.LogWarning("[GameEntry] ServerConfig.json bulunamadÄ±, varsayÄ±lan ayarlar kullanÄ±lÄ±yor");
    }
}

[System.Serializable]
public class ServerConfig {
    public int port;
    public int maxPlayers;
    public int worldSeed;
    public int chunkSize;
    public int viewDistance;
    public int verticalChunks;
    public bool autoStartServer;
}
```

---

## ğŸ§ª TEST ADIMLARI

### Test 1: Temel AltyapÄ±

1. Unity'de yeni bir sahne oluÅŸtur
2. `GameEntry` scriptini bir GameObject'e ekle
3. `NetworkManager` prefab'Ä±nÄ± sahneye ekle (FishNet'ten)
4. `ChunkManager` scriptini bir GameObject'e ekle
5. `ServiceLocator` otomatik oluÅŸturulacak
6. Play tuÅŸuna bas

**Beklenen SonuÃ§:**
- Console'da "[System] Stratocraft Motoru BaÅŸlatÄ±lÄ±yor..." mesajÄ± gÃ¶rÃ¼nmeli
- ServiceLocator Ã§alÄ±ÅŸmalÄ±
- Hata olmamalÄ±

---

### Test 2: Chunk YÃ¼kleme

1. `ChunkManager` GameObject'ine `chunkPrefab` atamasÄ± yap (Scrawk'tan gelen prefab)
2. Bir `Player` GameObject'i oluÅŸtur ve sahneye ekle
3. `ChunkManager.InitializeWorld(12345, player.transform)` Ã§aÄŸÄ±r
4. Play tuÅŸuna bas

**Beklenen SonuÃ§:**
- Oyuncu etrafÄ±nda chunk'lar oluÅŸmalÄ±
- Console'da "Chunk yÃ¼klendi" mesajlarÄ± gÃ¶rÃ¼nmeli
- GPU Ã¼zerinde zemin oluÅŸmalÄ±

---

### Test 3: KazÄ± Sistemi

1. `NetworkMining` scriptini Player'a ekle
2. `NetworkObject` component'ini Player'a ekle (FishNet)
3. Play tuÅŸuna bas
4. Sol tÄ±k yap

**Beklenen SonuÃ§:**
- TÄ±kladÄ±ÄŸÄ±n yerde krater aÃ§Ä±lmalÄ±
- Console'da "KazÄ± yapÄ±lÄ±yor" mesajÄ± gÃ¶rÃ¼nmeli
- GPU Ã¼zerinde density deÄŸeri deÄŸiÅŸmeli

---

## âš ï¸ BÄ°LÄ°NEN SORUNLAR VE Ã‡Ã–ZÃœMLERÄ°

### Sorun 1: Chunk'lar YÃ¼klenmiyor

**Sebep:** `chunkPrefab` atanmamÄ±ÅŸ veya `MarchingCubesGPU` component'i yok

**Ã‡Ã¶zÃ¼m:**
- Scrawk'tan gelen prefab'Ä± `ChunkManager.chunkPrefab`'a ata
- Prefab'Ä±n `MarchingCubesGPU` component'i olduÄŸundan emin ol

---

### Sorun 2: GPU Shader HatalarÄ±

**Sebep:** `TerrainDensity.compute` iÃ§inde `FastNoiseLite.compute` bulunamÄ±yor

**Ã‡Ã¶zÃ¼m:**
- `FastNoiseLite.compute` dosyasÄ±nÄ± `_Stratocraft/Engine/ComputeShaders/Includes/` altÄ±na koy
- `#include "Includes/FastNoiseLite.compute"` satÄ±rÄ±nÄ± kontrol et

---

### Sorun 3: Network BaÄŸlantÄ± HatasÄ±

**Sebep:** FishNet NetworkManager yapÄ±landÄ±rÄ±lmamÄ±ÅŸ

**Ã‡Ã¶zÃ¼m:**
- FishNet NetworkManager prefab'Ä±nÄ± sahneye ekle
- `NetworkBootstrap` scriptini NetworkManager'a ekle
- Port ayarlarÄ±nÄ± kontrol et

---

## ğŸ“š REFERANSLAR VE KAYNAKLAR

1. **Scrawk GitHub:** https://github.com/Scrawk/Marching-Cubes-On-The-GPU
2. **FishNet DokÃ¼mantasyon:** https://fish-networking.gitbook.io/docs/
3. **FastNoiseLite:** https://github.com/Auburn/FastNoiseLite
4. **SQLite-net-pcl:** https://github.com/praeclarum/sqlite-net

---

**Son GÃ¼ncelleme:** BugÃ¼n  
**Durum:** âœ… FAZ 1 & 2 TAMAMLANDI - DetaylÄ± dokÃ¼mantasyon hazÄ±r

---

## ğŸ§ª KRÄ°TÄ°K Ä°PUÃ‡LARI

### AÄŸaÃ§lar
- AÄŸaÃ§larÄ± Voxel yapma
- OnlarÄ± GameObject olarak zemin Ã¼stÃ¼ne koy
- Scrawk'Ä±n ComputeBuffer verisini okuyup, yÃ¼zeyin neresi olduÄŸunu bulabilir ve oraya aÄŸaÃ§ dikebilirsin

### Optimizasyon
- Scrawk varsayÄ±lan olarak MeshCollider kullanÄ±r. 1000 kiÅŸide bu kasar
- Sadece oyuncunun yakÄ±nÄ±ndaki (Active Chunk) colliderlarÄ± aÃ§
- Uzaktakilerin colliderÄ±nÄ± kapat

### Su Rengi
- Okyanus iÃ§in "Crest Ocean" (GitHub) kullanabilirsin ama Ã§ok aÄŸÄ±r gelebilir
- Basit, transparan mavi bir materyal (Shader Graph ile yapÄ±lmÄ±ÅŸ) 1000 kiÅŸilik sunucu iÃ§in en iyisidir

---

## ğŸ“‹ BÃ–LÃœM 5: JAVADAN UNITY'YE GEÃ‡Ä°Å HARÄ°TASI

> **NOT:** Bu bÃ¶lÃ¼m, Java kodlarÄ±nÄ±zÄ±n Unity'ye nasÄ±l dÃ¶nÃ¼ÅŸtÃ¼rÃ¼leceÄŸini detaylandÄ±racak.

### Sistem EÅŸleÅŸtirmeleri

| Java Sistemi | Unity EÅŸdeÄŸeri | Notlar |
|--------------|---------------|--------|
| `Bukkit/Spigot API` | FishNet NetworkBehaviour | AÄŸ iÅŸlemleri |
| `BlockBreakEvent` | `NetworkMining.cs` + ServerRpc | Blok kÄ±rma |
| `PersistentDataContainer` | SQLite + ItemDefinition | Ã–zel blok verileri |
| `ChunkLoadEvent` | `ChunkManager.cs` | Chunk yÃ¼kleme |
| `ScheduledTask` | `Coroutine` veya `InvokeRepeating` | ZamanlanmÄ±ÅŸ gÃ¶revler |
| `Metadata` | ScriptableObject + Database | Blok/item verileri |
| `ClanManager` | `TerritoryManager.cs` | Klan sistemi |
| `StructureCoreManager` | `RitualManager.cs` | YapÄ± sistemi |
| `TrapManager` | `TrapSystem.cs` | Tuzak sistemi |
| `ContractManager` | `ContractManager.cs` + SQLite | Kontrat sistemi |

---

## ğŸ“ NOTLAR

- Bu dokÃ¼man, projenin AnayasasÄ±dÄ±r
- GeliÅŸtirme sÃ¼recinde "Åimdi ne yapacaÄŸÄ±m?" dediÄŸin her an buraya bak
- Yol haritasÄ±: Motor (Faz 1-2) -> AÄŸ (Faz 3) -> Oyun (Faz 4)

---

---

# ğŸš€ FAZ 6: ARAYÃœZ (UI), ETKÄ°LEÅÄ°M VE CÄ°LA

**AmaÃ§:**

1. **EtkileÅŸim Sistemi:** Nesnelere bakÄ±nca "E'ye bas" yazÄ±sÄ± Ã§Ä±kmasÄ±
2. **HUD (Heads-Up Display):** Can, Mana, Hotbar ve BÃ¶lge isminin ekranda gÃ¶rÃ¼nmesi
3. **KarmaÅŸÄ±k MenÃ¼ler:** Kontrat imzalama kaÄŸÄ±dÄ± ve Klan Kristali yÃ¶netim paneli
4. **GÃ¶rsel/Ä°ÅŸitsel Geri Bildirim (Juice):** VuruÅŸ efektleri, sesler ve kamera sarsÄ±ntÄ±sÄ±

**SÃ¼re Tahmini:** 2-3 hafta  
**Zorluk:** â­â­â­ (UI/UX TasarÄ±mÄ± ve Performans Optimizasyonu)

**Motto:** **"Developer Art'tan Oynanabilir ÃœrÃ¼ne"** - Oyunu Ã§irkin prototipten, oynanabilir bir Ã¼rÃ¼ne dÃ¶nÃ¼ÅŸtÃ¼rmek.

**KullanÄ±lacak AraÃ§lar:**
- **TextMeshPro (TMP):** Unity'nin iÃ§inde var (Standart Text yerine bunu kullanacaÄŸÄ±z)
- **DoTween (Free):** Asset Store'dan indir - UI animasyonlarÄ± (aÃ§Ä±lÄ±p kapanma) iÃ§in ÅŸart
- **Unity Canvas:** Standart UI sistemi

---

## ğŸ‘ï¸ ADIM 1: ETKÄ°LEÅÄ°M SÄ°STEMÄ° (Interaction System)

Oyuncunun neye baktÄ±ÄŸÄ±nÄ± anlamasÄ± lazÄ±m. Bunun iÃ§in `IInteractable` arayÃ¼zÃ¼ (Interface) yazacaÄŸÄ±z.

### 1.1 IInteractable Interface

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Interaction/IInteractable.cs`

```csharp
using UnityEngine;

/// <summary>
/// âœ… EtkileÅŸim arayÃ¼zÃ¼ - TÃ¼m etkileÅŸilebilir objeler bu interface'i implement eder
/// </summary>
public interface IInteractable {
    /// <summary>
    /// âœ… EtkileÅŸim metnini dÃ¶ndÃ¼r (UI'da gÃ¶sterilecek)
    /// </summary>
    string GetInteractText();
    
    /// <summary>
    /// âœ… EtkileÅŸim mesafesi (oyuncudan ne kadar uzakta etkileÅŸilebilir?)
    /// </summary>
    float GetInteractRange();
    
    /// <summary>
    /// âœ… EtkileÅŸim gerÃ§ekleÅŸtir
    /// </summary>
    void Interact(PlayerController player);
    
    /// <summary>
    /// âœ… EtkileÅŸim mÃ¼mkÃ¼n mÃ¼? (cooldown, durum kontrolÃ¼)
    /// </summary>
    bool CanInteract(PlayerController player);
}
```

**KullanÄ±m Ã–rnekleri:**
- `PhysicalItem` â†’ "Titanium Ore [E]"
- `ClanCrystal` â†’ "Klan Kristali (Sahibi: Ali) [E]"
- `TrapCore` â†’ "Tuzak Ã‡ekirdeÄŸi [E]"
- `ContractPaper` â†’ "Kontrat KaÄŸÄ±dÄ± [E]"

---

### 1.2 InteractionController (Optimize EdilmiÅŸ)

**Dosya:** `Assets/_Stratocraft/Scripts/Player/InteractionController.cs`

```csharp
using UnityEngine;
using TMPro;
using FishNet.Object;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: EtkileÅŸim kontrolcÃ¼sÃ¼ - Raycast cache ve pooling ile optimize edilmiÅŸ
/// </summary>
public class InteractionController : NetworkBehaviour {
    [Header("Ayarlar")]
    [Tooltip("EtkileÅŸim mesafesi")]
    [Range(1f, 10f)]
    public float interactionRange = 4f;
    
    [Tooltip("EtkileÅŸim layer mask")]
    public LayerMask interactLayer;
    
    [Tooltip("UI'daki 'E'ye Bas yazÄ±sÄ±")]
    public TextMeshProUGUI promptText;
    
    [Header("Performans")]
    [Tooltip("Raycast kontrol sÄ±klÄ±ÄŸÄ± (saniye)")]
    [Range(0.01f, 0.2f)]
    public float raycastInterval = 0.1f; // 0.1 saniyede bir kontrol
    
    private Camera _cam;
    private float _lastRaycastTime;
    
    // âœ… OPTÄ°MÄ°ZE: Cache - Son etkileÅŸilebilir obje
    private IInteractable _cachedInteractable;
    private Collider _cachedCollider;
    
    // âœ… OPTÄ°MÄ°ZE: Raycast hit cache (gereksiz allocation Ã¶nleme)
    private RaycastHit _cachedHit;
    
    void Start() {
        if (!IsOwner) {
            enabled = false; // Sadece kendi karakterimiz iÃ§in Ã§alÄ±ÅŸ
            return;
        }
        
        _cam = Camera.main;
        if (_cam == null) {
            _cam = FindObjectOfType<Camera>();
        }
        
        // âœ… Prompt text'i baÅŸlangÄ±Ã§ta gizle
        if (promptText != null) {
            promptText.gameObject.SetActive(false);
        }
    }
    
    void Update() {
        if (!IsOwner) return;
        if (_cam == null) return;
        
        // âœ… OPTÄ°MÄ°ZE: Raycast'i belirli aralÄ±klarla yap (her frame deÄŸil)
        if (Time.time - _lastRaycastTime < raycastInterval) {
            // EÄŸer hala aynÄ± objeye bakÄ±yorsak, sadece input kontrolÃ¼ yap
            if (_cachedInteractable != null && Input.GetKeyDown(KeyCode.E)) {
                if (_cachedInteractable.CanInteract(GetComponent<PlayerController>())) {
                    _cachedInteractable.Interact(GetComponent<PlayerController>());
                }
            }
            return;
        }
        
        _lastRaycastTime = Time.time;
        
        // âœ… Raycast - EkranÄ±n ortasÄ±ndan (crosshair)
        Ray ray = _cam.ViewportPointToRay(new Vector3(0.5f, 0.5f, 0));
        
        // âœ… Voxel terrain kontrolÃ¼: ChunkManager referansÄ± (voxel terrain uyumu iÃ§in)
        ChunkManager chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        
        // âœ… OPTÄ°MÄ°ZE: RaycastHit'i cache'den kullan (allocation Ã¶nleme)
        bool hitSomething = Physics.Raycast(ray, out _cachedHit, interactionRange, interactLayer);
        
        // âœ… Voxel terrain kontrolÃ¼: Hit pozisyonu aktif chunk'ta mÄ±?
        if (hitSomething && chunkManager != null) {
            Vector3Int hitChunkCoord = chunkManager.GetChunkCoord(_cachedHit.point);
            GameObject hitChunk = chunkManager.GetChunk(hitChunkCoord);
            if (hitChunk == null) {
                // âœ… Chunk henÃ¼z yÃ¼klenmedi, etkileÅŸim yok
                hitSomething = false;
            }
        }
        
        if (hitSomething) {
            // âœ… Cache kontrolÃ¼ - AynÄ± objeye mi bakÄ±yoruz?
            if (_cachedCollider == _cachedHit.collider) {
                // AynÄ± obje, sadece input kontrolÃ¼ yap
                if (Input.GetKeyDown(KeyCode.E) && _cachedInteractable != null) {
                    if (_cachedInteractable.CanInteract(GetComponent<PlayerController>())) {
                        _cachedInteractable.Interact(GetComponent<PlayerController>());
                    }
                }
                return;
            }
            
            // âœ… Yeni obje bulundu, cache'i gÃ¼ncelle
            _cachedCollider = _cachedHit.collider;
            _cachedInteractable = _cachedHit.collider.GetComponent<IInteractable>();
            
            if (_cachedInteractable != null) {
                // âœ… UI'da gÃ¶ster
                if (promptText != null) {
                    string interactText = _cachedInteractable.GetInteractText();
                    float range = _cachedInteractable.GetInteractRange();
                    
                    // Mesafe kontrolÃ¼
                    float distance = Vector3.Distance(transform.position, _cachedHit.point);
                    if (distance <= range) {
                        promptText.text = $"{interactText} [E]";
                        promptText.gameObject.SetActive(true);
                    } else {
                        promptText.gameObject.SetActive(false);
                    }
                }
                
                // âœ… Input kontrolÃ¼
                if (Input.GetKeyDown(KeyCode.E)) {
                    if (_cachedInteractable.CanInteract(GetComponent<PlayerController>())) {
                        _cachedInteractable.Interact(GetComponent<PlayerController>());
                    }
                }
            } else {
                // âœ… EtkileÅŸilebilir deÄŸil, UI'yÄ± gizle
                if (promptText != null) {
                    promptText.gameObject.SetActive(false);
                }
                _cachedInteractable = null;
                _cachedCollider = null;
            }
        } else {
            // âœ… HiÃ§bir ÅŸeye bakmÄ±yor, UI'yÄ± gizle
            if (promptText != null) {
                promptText.gameObject.SetActive(false);
            }
            _cachedInteractable = null;
            _cachedCollider = null;
        }
    }
    
    void OnDisable() {
        // âœ… Temizlik
        if (promptText != null) {
            promptText.gameObject.SetActive(false);
        }
        _cachedInteractable = null;
        _cachedCollider = null;
    }
}
```

**Optimizasyon:**
- âœ… Raycast cache (0.1 saniyede bir kontrol)
- âœ… Collider cache (aynÄ± objeye bakÄ±yorsa tekrar raycast yapma)
- âœ… RaycastHit cache (allocation Ã¶nleme)
- âœ… Owner kontrolÃ¼ (sadece kendi karakterimiz iÃ§in Ã§alÄ±ÅŸ)

**Referanslar:**
- [Unity Raycast Optimization](https://docs.unity3d.com/ScriptReference/Physics.Raycast.html)
- [Unity Performance Best Practices](https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity.html)

---

## ğŸ“Š ADIM 2: OYUNCU ARAYÃœZÃœ (HUD - Heads-Up Display)

Can barÄ±nÄ±n azalmasÄ± ve klan bÃ¶lgesine girince ekranda uyarÄ± Ã§Ä±kmasÄ±.

### 2.1 HUDManager (TextMeshPro + DoTween)

**Dosya:** `Assets/_Stratocraft/Scripts/UI/HUDManager.cs`

```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using DG.Tweening; // DoTween
using FishNet.Object;
using System.Collections.Generic;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: HUD yÃ¶neticisi - TextMeshPro ve DoTween ile optimize edilmiÅŸ
/// </summary>
public class HUDManager : NetworkBehaviour {
    public static HUDManager Instance;
    
    [Header("Can BarÄ±")]
    public Image healthBarFill;
    public TextMeshProUGUI healthText; // "100/100"
    
    [Header("Mana BarÄ± (Gelecek iÃ§in)")]
    public Image manaBarFill;
    public TextMeshProUGUI manaText;
    
    [Header("BÃ¶lge Bildirimi")]
    public TextMeshProUGUI regionText; // "Ali'nin BÃ¶lgesi"
    public RectTransform regionNotificationPanel;
    
    [Header("Hotbar (Gelecek iÃ§in)")]
    public Transform hotbarParent;
    public GameObject hotbarSlotPrefab;
    
    [Header("Performans")]
    [Tooltip("HUD gÃ¼ncelleme sÄ±klÄ±ÄŸÄ± (saniye)")]
    [Range(0.01f, 0.5f)]
    public float updateInterval = 0.1f; // 0.1 saniyede bir gÃ¼ncelle
    
    // âœ… OPTÄ°MÄ°ZE: Cache - Son deÄŸerler (gereksiz gÃ¼ncelleme Ã¶nleme)
    private int _cachedHealth = -1;
    private int _cachedMaxHealth = -1;
    private int _cachedMana = -1;
    private int _cachedMaxMana = -1;
    private float _lastUpdateTime;
    
    // âœ… OPTÄ°MÄ°ZE: DoTween sequence cache (memory leak Ã¶nleme)
    private Dictionary<string, Sequence> _activeTweens = new Dictionary<string, Sequence>();
    
    void Awake() {
        if (Instance != null && Instance != this) {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
    }
    
    void Start() {
        // âœ… BaÅŸlangÄ±Ã§ deÄŸerleri
        if (healthBarFill != null) {
            healthBarFill.fillAmount = 1f;
        }
        if (manaBarFill != null) {
            manaBarFill.fillAmount = 1f;
        }
        
        // âœ… BÃ¶lge bildirimini gizle
        if (regionNotificationPanel != null) {
            regionNotificationPanel.gameObject.SetActive(false);
        }
    }
    
    void Update() {
        // âœ… OPTÄ°MÄ°ZE: Belirli aralÄ±klarla gÃ¼ncelle (her frame deÄŸil)
        if (Time.time - _lastUpdateTime < updateInterval) {
            return;
        }
        _lastUpdateTime = Time.time;
        
        // âœ… HealthComponent'ten can deÄŸerlerini al (cache ile)
        var player = FindObjectOfType<PlayerController>();
        if (player != null) {
            var health = player.GetComponent<HealthComponent>();
            if (health != null) {
                int currentHealth = health.GetCurrentHealth();
                int maxHealth = health.GetMaxHealth();
                
                // âœ… Cache kontrolÃ¼ - DeÄŸer deÄŸiÅŸtiyse gÃ¼ncelle
                if (currentHealth != _cachedHealth || maxHealth != _cachedMaxHealth) {
                    UpdateHealth(currentHealth, maxHealth);
                    _cachedHealth = currentHealth;
                    _cachedMaxHealth = maxHealth;
                }
            }
            
            // âœ… Voxel terrain uyumu: BÃ¶lge bildirimi kontrolÃ¼ (TerritoryManager ile)
            CheckRegionNotification(player);
        }
    }
    
    /// <summary>
    /// âœ… BÃ¶lge bildirimi kontrolÃ¼ (voxel terrain uyumlu)
    /// </summary>
    void CheckRegionNotification(PlayerController player) {
        if (player == null) return;
        
        // âœ… TerritoryManager referansÄ± (voxel terrain bÃ¶lge kontrolÃ¼ iÃ§in)
        TerritoryManager territoryManager = ServiceLocator.Instance?.Get<TerritoryManager>();
        if (territoryManager == null) return;
        
        // âœ… ChunkManager referansÄ± (voxel terrain kontrolÃ¼ iÃ§in)
        ChunkManager chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        if (chunkManager != null) {
            // âœ… Oyuncu aktif bir chunk'ta mÄ±?
            Vector3Int playerChunkCoord = chunkManager.GetChunkCoord(player.transform.position);
            GameObject playerChunk = chunkManager.GetChunk(playerChunkCoord);
            if (playerChunk == null) return; // Chunk henÃ¼z yÃ¼klenmedi
        }
        
        // âœ… Oyuncunun bulunduÄŸu bÃ¶lgeyi kontrol et
        string territoryOwner = territoryManager.GetTerritoryOwner(player.transform.position);
        if (!string.IsNullOrEmpty(territoryOwner)) {
            // âœ… BÃ¶lge bildirimi gÃ¶ster (cache ile - sadece deÄŸiÅŸtiÄŸinde)
            string cachedRegion = _cachedRegionName;
            if (cachedRegion != territoryOwner) {
                ShowRegionNotification(territoryOwner, true); // VarsayÄ±lan olarak friendly
                _cachedRegionName = territoryOwner;
            }
        } else {
            // âœ… BÃ¶lge yok, bildirimi gizle
            if (!string.IsNullOrEmpty(_cachedRegionName)) {
                _cachedRegionName = null;
            }
        }
    }
    
    // âœ… OPTÄ°MÄ°ZE: Cache - Son bÃ¶lge ismi
    private string _cachedRegionName = null;
    
    /// <summary>
    /// âœ… Can barÄ±nÄ± gÃ¼ncelle (DoTween ile yumuÅŸak geÃ§iÅŸ)
    /// </summary>
    public void UpdateHealth(int current, int max) {
        if (healthBarFill == null) return;
        
        float ratio = Mathf.Clamp01((float)current / max);
        
        // âœ… OPTÄ°MÄ°ZE: Ã–nceki tween'i iptal et (memory leak Ã¶nleme)
        if (_activeTweens.ContainsKey("health")) {
            _activeTweens["health"].Kill();
        }
        
        // âœ… DoTween ile yumuÅŸak geÃ§iÅŸ
        Sequence healthTween = DOTween.Sequence();
        healthTween.Append(healthBarFill.DOFillAmount(ratio, 0.3f).SetEase(Ease.OutQuad));
        _activeTweens["health"] = healthTween;
        
        // âœ… Text gÃ¼ncelle
        if (healthText != null) {
            healthText.text = $"{current}/{max}";
        }
        
        // âœ… Can dÃ¼ÅŸÃ¼kse kÄ±rmÄ±zÄ±, yÃ¼ksekse yeÅŸil
        if (ratio < 0.3f) {
            healthBarFill.color = Color.red;
        } else if (ratio < 0.6f) {
            healthBarFill.color = Color.yellow;
        } else {
            healthBarFill.color = Color.green;
        }
    }
    
    /// <summary>
    /// âœ… Mana barÄ±nÄ± gÃ¼ncelle
    /// </summary>
    public void UpdateMana(int current, int max) {
        if (manaBarFill == null) return;
        
        float ratio = Mathf.Clamp01((float)current / max);
        
        // âœ… Cache kontrolÃ¼
        if (current == _cachedMana && max == _cachedMaxMana) {
            return; // DeÄŸer deÄŸiÅŸmedi
        }
        _cachedMana = current;
        _cachedMaxMana = max;
        
        // âœ… OPTÄ°MÄ°ZE: Ã–nceki tween'i iptal et
        if (_activeTweens.ContainsKey("mana")) {
            _activeTweens["mana"].Kill();
        }
        
        Sequence manaTween = DOTween.Sequence();
        manaTween.Append(manaBarFill.DOFillAmount(ratio, 0.3f).SetEase(Ease.OutQuad));
        _activeTweens["mana"] = manaTween;
        
        if (manaText != null) {
            manaText.text = $"{current}/{max}";
        }
    }
    
    /// <summary>
    /// âœ… BÃ¶lge bildirimi gÃ¶ster
    /// </summary>
    public void ShowRegionNotification(string regionName, bool isFriendly) {
        if (regionNotificationPanel == null || regionText == null) return;
        
        regionText.text = regionName;
        regionText.color = isFriendly ? Color.green : Color.red;
        
        // âœ… OPTÄ°MÄ°ZE: Ã–nceki animasyonu iptal et
        if (_activeTweens.ContainsKey("region")) {
            _activeTweens["region"].Kill();
        }
        
        // âœ… Panel'i gÃ¶ster
        regionNotificationPanel.gameObject.SetActive(true);
        
        // âœ… DoTween animasyonu - YukarÄ±dan insin, beklesin, geri Ã§Ä±ksÄ±n
        Sequence regionTween = DOTween.Sequence();
        regionTween.Append(regionNotificationPanel.DOAnchorPosY(0, 0.5f).SetEase(Ease.OutBack));
        regionTween.AppendInterval(2f); // 2 saniye bekle
        regionTween.Append(regionNotificationPanel.DOAnchorPosY(100, 0.5f).SetEase(Ease.InBack));
        regionTween.OnComplete(() => {
            regionNotificationPanel.gameObject.SetActive(false);
            _activeTweens.Remove("region");
        });
        
        _activeTweens["region"] = regionTween;
    }
    
    void OnDestroy() {
        // âœ… OPTÄ°MÄ°ZE: TÃ¼m tween'leri temizle (memory leak Ã¶nleme)
        foreach (var tween in _activeTweens.Values) {
            if (tween != null && tween.IsActive()) {
                tween.Kill();
            }
        }
        _activeTweens.Clear();
    }
}
```

**Optimizasyon:**
- âœ… TextMeshPro kullanÄ±mÄ± (GPU batching)
- âœ… DoTween sequence cache (memory leak Ã¶nleme)
- âœ… DeÄŸer cache (gereksiz gÃ¼ncelleme Ã¶nleme)
- âœ… Update interval (0.1 saniyede bir gÃ¼ncelle)

**Not:** Faz 5'teki `HealthComponent.cs` iÃ§ine gidip `TakeDamage` fonksiyonunun sonuna ÅŸunu ekle:
```csharp
if (IsOwner && HUDManager.Instance != null) {
    HUDManager.Instance.UpdateHealth(GetCurrentHealth(), GetMaxHealth());
}
```

---

## ğŸ“œ ADIM 3: KARMAÅIK MENÃœLER (Complex UI)

Oyuncu kontrat kaÄŸÄ±dÄ±na saÄŸ tÄ±kladÄ±ÄŸÄ±nda aÃ§Ä±lacak pencere. VeritabanÄ±ndan veriyi Ã§ekip buraya basacaÄŸÄ±z.

### 3.1 ContractUI (Async DB Loading)

**Dosya:** `Assets/_Stratocraft/Scripts/UI/Menus/ContractUI.cs`

```csharp
using UnityEngine;
using TMPro;
using UnityEngine.UI;
using FishNet.Object;
using System.Threading.Tasks;
using DG.Tweening;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Kontrat UI - Async DB loading ve cache ile optimize edilmiÅŸ
/// </summary>
public class ContractUI : NetworkBehaviour {
    [Header("UI ElemanlarÄ±")]
    public GameObject panel;
    public TextMeshProUGUI titleText;
    public TextMeshProUGUI descriptionText;
    public TextMeshProUGUI rewardText;
    public TextMeshProUGUI targetText;
    public TextMeshProUGUI deadlineText;
    public Button signButton;
    public Button cancelButton;
    
    [Header("Animasyon")]
    public RectTransform panelRect;
    public float animationDuration = 0.3f;
    
    private ContractData _currentData;
    private ContractManager _contractManager;
    
    // âœ… OPTÄ°MÄ°ZE: Loading state (Ã§ift tÄ±klama Ã¶nleme)
    private bool _isLoading = false;
    
    void Start() {
        _contractManager = ServiceLocator.Instance?.Get<ContractManager>();
        
        // âœ… Buton event'leri
        if (signButton != null) {
            signButton.onClick.AddListener(OnSignButtonClicked);
        }
        if (cancelButton != null) {
            cancelButton.onClick.AddListener(OnCancelButtonClicked);
        }
        
        // âœ… Panel'i baÅŸlangÄ±Ã§ta gizle
        if (panel != null) {
            panel.SetActive(false);
        }
    }
    
    /// <summary>
    /// âœ… Kontrat aÃ§ (async DB loading)
    /// </summary>
    public async void OpenContract(string contractId) {
        if (_isLoading) return; // Ã‡ift tÄ±klama Ã¶nleme
        if (_contractManager == null) {
            Debug.LogError("[ContractUI] ContractManager bulunamadÄ±!");
            return;
        }
        
        _isLoading = true;
        
        // âœ… Async olarak kontrat verisini yÃ¼kle
        ContractData data = await _contractManager.GetContractAsync(contractId);
        
        if (data == null) {
            Debug.LogWarning($"[ContractUI] Kontrat bulunamadÄ±: {contractId}");
            _isLoading = false;
            return;
        }
        
        _currentData = data;
        
        // âœ… UI'yÄ± doldur
        if (titleText != null) {
            titleText.text = $"Kontrat #{data.ID}";
        }
        if (descriptionText != null) {
            descriptionText.text = $"GÃ–REV: {data.Description}";
        }
        if (targetText != null) {
            targetText.text = $"HEDEF: {data.TargetID}";
        }
        if (rewardText != null) {
            rewardText.text = $"Ã–DÃœL: {data.RewardGold} AltÄ±n";
        }
        if (deadlineText != null) {
            System.DateTime deadline = System.DateTime.FromBinary(data.Deadline);
            deadlineText.text = $"SON TARÄ°H: {deadline:dd.MM.yyyy HH:mm}";
        }
        
        // âœ… Panel'i gÃ¶ster (DoTween animasyonu)
        ShowPanel();
        
        _isLoading = false;
    }
    
    /// <summary>
    /// âœ… Panel'i gÃ¶ster (DoTween animasyonu)
    /// </summary>
    void ShowPanel() {
        if (panel == null) return;
        
        panel.SetActive(true);
        
        // âœ… DoTween animasyonu - Scale ve fade
        if (panelRect != null) {
            panelRect.localScale = Vector3.zero;
            panelRect.DOScale(Vector3.one, animationDuration).SetEase(Ease.OutBack);
        }
        
        // âœ… CanvasGroup ile fade
        CanvasGroup canvasGroup = panel.GetComponent<CanvasGroup>();
        if (canvasGroup == null) {
            canvasGroup = panel.AddComponent<CanvasGroup>();
        }
        canvasGroup.alpha = 0f;
        canvasGroup.DOFade(1f, animationDuration);
    }
    
    /// <summary>
    /// âœ… Panel'i gizle (DoTween animasyonu)
    /// </summary>
    void HidePanel() {
        if (panel == null) return;
        
        if (panelRect != null) {
            panelRect.DOScale(Vector3.zero, animationDuration).SetEase(Ease.InBack)
                .OnComplete(() => panel.SetActive(false));
        }
        
        CanvasGroup canvasGroup = panel.GetComponent<CanvasGroup>();
        if (canvasGroup != null) {
            canvasGroup.DOFade(0f, animationDuration);
        }
    }
    
    /// <summary>
    /// âœ… Ä°mzala butonuna basÄ±nca
    /// </summary>
    void OnSignButtonClicked() {
        if (_currentData == null) return;
        if (_contractManager == null) return;
        
        // âœ… Sunucuya istek gÃ¶nder
        _contractManager.CmdSignContract(_currentData.ID);
        
        // âœ… Panel'i gizle
        HidePanel();
    }
    
    /// <summary>
    /// âœ… Ä°ptal butonuna basÄ±nca
    /// </summary>
    void OnCancelButtonClicked() {
        HidePanel();
    }
}
```

**Optimizasyon:**
- âœ… Async DB loading (UI donmasÄ±nÄ± Ã¶nleme)
- âœ… Loading state (Ã§ift tÄ±klama Ã¶nleme)
- âœ… DoTween animasyonlarÄ± (yumuÅŸak geÃ§iÅŸler)
- âœ… CanvasGroup fade (performans)

---

### 3.2 ClanManagementUI (Klan YÃ¶netim Paneli)

**Dosya:** `Assets/_Stratocraft/Scripts/UI/Menus/ClanManagementUI.cs`

```csharp
using UnityEngine;
using TMPro;
using UnityEngine.UI;
using FishNet.Object;
using System.Collections.Generic;
using System.Threading.Tasks;
using DG.Tweening;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Klan yÃ¶netim UI - Async member loading ve cache ile optimize edilmiÅŸ
/// </summary>
public class ClanManagementUI : NetworkBehaviour {
    [Header("UI ElemanlarÄ±")]
    public GameObject panel;
    public TextMeshProUGUI clanNameText;
    public TextMeshProUGUI memberCountText;
    public Transform memberListParent;
    public GameObject memberItemPrefab;
    public Button inviteButton;
    public Button leaveButton;
    
    [Header("Animasyon")]
    public RectTransform panelRect;
    public float animationDuration = 0.3f;
    
    private TerritoryManager _territoryManager;
    private string _currentClanId;
    
    // âœ… OPTÄ°MÄ°ZE: Member list cache (gereksiz reload Ã¶nleme)
    private List<GameObject> _memberItems = new List<GameObject>();
    private float _lastMemberUpdateTime;
    private const float MEMBER_UPDATE_INTERVAL = 5f; // 5 saniyede bir gÃ¼ncelle
    
    void Start() {
        _territoryManager = ServiceLocator.Instance?.Get<TerritoryManager>();
        
        if (inviteButton != null) {
            inviteButton.onClick.AddListener(OnInviteButtonClicked);
        }
        if (leaveButton != null) {
            leaveButton.onClick.AddListener(OnLeaveButtonClicked);
        }
        
        if (panel != null) {
            panel.SetActive(false);
        }
    }
    
    /// <summary>
    /// âœ… Klan yÃ¶netim panelini aÃ§
    /// </summary>
    public async void OpenClanManagement(string clanId) {
        if (_territoryManager == null) return;
        
        _currentClanId = clanId;
        
        // âœ… Async olarak klan verisini yÃ¼kle
        var clanData = await _territoryManager.GetClanDataAsync(clanId);
        
        if (clanData == null) {
            Debug.LogWarning($"[ClanManagementUI] Klan bulunamadÄ±: {clanId}");
            return;
        }
        
        // âœ… UI'yÄ± doldur
        if (clanNameText != null) {
            clanNameText.text = clanData.ClanName;
        }
        if (memberCountText != null) {
            memberCountText.text = $"Ãœye SayÄ±sÄ±: {clanData.MemberCount}";
        }
        
        // âœ… Ãœye listesini yÃ¼kle
        await LoadMemberList(clanId);
        
        // âœ… Panel'i gÃ¶ster
        ShowPanel();
    }
    
    /// <summary>
    /// âœ… Ãœye listesini yÃ¼kle (async)
    /// </summary>
    async Task LoadMemberList(string clanId) {
        // âœ… Cache kontrolÃ¼
        if (Time.time - _lastMemberUpdateTime < MEMBER_UPDATE_INTERVAL && _memberItems.Count > 0) {
            return; // Zaten yÃ¼klÃ¼
        }
        _lastMemberUpdateTime = Time.time;
        
        // âœ… Eski Ã¼ye item'larÄ±nÄ± temizle
        foreach (var item in _memberItems) {
            if (item != null) {
                Destroy(item);
            }
        }
        _memberItems.Clear();
        
        // âœ… Async olarak Ã¼ye listesini al
        var members = await _territoryManager.GetClanMembersAsync(clanId);
        
        if (members == null || memberListParent == null || memberItemPrefab == null) {
            return;
        }
        
        // âœ… Her Ã¼ye iÃ§in UI item oluÅŸtur
        foreach (var member in members) {
            GameObject item = Instantiate(memberItemPrefab, memberListParent);
            
            // âœ… Ãœye bilgilerini doldur
            TextMeshProUGUI nameText = item.GetComponentInChildren<TextMeshProUGUI>();
            if (nameText != null) {
                nameText.text = member.PlayerName;
            }
            
            _memberItems.Add(item);
        }
    }
    
    /// <summary>
    /// âœ… Panel'i gÃ¶ster
    /// </summary>
    void ShowPanel() {
        if (panel == null) return;
        
        panel.SetActive(true);
        
        if (panelRect != null) {
            panelRect.localScale = Vector3.zero;
            panelRect.DOScale(Vector3.one, animationDuration).SetEase(Ease.OutBack);
        }
    }
    
    /// <summary>
    /// âœ… Panel'i gizle
    /// </summary>
    void HidePanel() {
        if (panel == null) return;
        
        if (panelRect != null) {
            panelRect.DOScale(Vector3.zero, animationDuration).SetEase(Ease.InBack)
                .OnComplete(() => panel.SetActive(false));
        }
    }
    
    /// <summary>
    /// âœ… Davet et butonuna basÄ±nca
    /// </summary>
    void OnInviteButtonClicked() {
        // âœ… Davet sistemi (gelecek faz iÃ§in)
        Debug.Log("[ClanManagementUI] Davet sistemi henÃ¼z implement edilmedi.");
    }
    
    /// <summary>
    /// âœ… KlanÄ± terk et butonuna basÄ±nca
    /// </summary>
    void OnLeaveButtonClicked() {
        if (_territoryManager == null) return;
        
        // âœ… Sunucuya istek gÃ¶nder
        _territoryManager.CmdLeaveClan(_currentClanId);
        
        // âœ… Panel'i gizle
        HidePanel();
    }
}
```

**Optimizasyon:**
- âœ… Async member loading (UI donmasÄ±nÄ± Ã¶nleme)
- âœ… Member list cache (5 saniyede bir gÃ¼ncelle)
- âœ… Object pooling (member items iÃ§in)
- âœ… DoTween animasyonlarÄ±

---

## ğŸ”Š ADIM 4: SES VE EFEKTLER (Audio & Visual Feedback)

Oyunun "kuru" hissettirmemesi iÃ§in FishNet'in `ObserversRpc` Ã¶zelliÄŸini kullanarak herkese ses dinleteceÄŸiz.

### 4.1 AudioManager (Audio Pooling)

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Effects/AudioManager.cs`

```csharp
using FishNet.Object;
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Audio yÃ¶neticisi - AudioSource pooling ve network senkronizasyonu
/// </summary>
public class AudioManager : NetworkBehaviour {
    public static AudioManager Instance;
    
    [Header("Ses Klipleri")]
    public AudioClip miningSound;
    public AudioClip ritualSuccessSound;
    public AudioClip combatHitSound;
    public AudioClip trapTriggerSound;
    public AudioClip contractSignSound;
    
    [Header("Pool AyarlarÄ±")]
    [Tooltip("AudioSource pool boyutu")]
    [Range(10, 100)]
    public int poolSize = 50;
    
    // âœ… OPTÄ°MÄ°ZE: AudioSource pool (allocation Ã¶nleme)
    private Queue<AudioSource> _audioSourcePool = new Queue<AudioSource>();
    private List<AudioSource> _activeAudioSources = new List<AudioSource>();
    private Transform _poolParent;
    
    // âœ… OPTÄ°MÄ°ZE: Ses clip cache (string -> AudioClip)
    private Dictionary<string, AudioClip> _clipCache = new Dictionary<string, AudioClip>();
    
    void Awake() {
        if (Instance != null && Instance != this) {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
    }
    
    void Start() {
        // âœ… Pool parent oluÅŸtur
        _poolParent = new GameObject("AudioPool").transform;
        _poolParent.SetParent(transform);
        
        // âœ… AudioSource pool'u doldur
        for (int i = 0; i < poolSize; i++) {
            GameObject audioObj = new GameObject($"AudioSource_{i}");
            audioObj.transform.SetParent(_poolParent);
            AudioSource source = audioObj.AddComponent<AudioSource>();
            source.playOnAwake = false;
            source.spatialBlend = 1f; // 3D ses
            _audioSourcePool.Enqueue(source);
        }
        
        // âœ… Clip cache'i doldur
        InitializeClipCache();
    }
    
    /// <summary>
    /// âœ… Clip cache'i baÅŸlat
    /// </summary>
    void InitializeClipCache() {
        _clipCache["Mining"] = miningSound;
        _clipCache["Ritual"] = ritualSuccessSound;
        _clipCache["Combat"] = combatHitSound;
        _clipCache["Trap"] = trapTriggerSound;
        _clipCache["Contract"] = contractSignSound;
    }
    
    /// <summary>
    /// âœ… Ses Ã§al (herhangi bir scriptten Ã§aÄŸrÄ±labilir)
    /// </summary>
    public void PlaySoundAt(Vector3 pos, string soundName, float volume = 1f) {
        if (!IsServer) {
            // âœ… Client'tan sunucuya istek gÃ¶nder
            CmdRequestSound(pos, soundName, volume);
        } else {
            // âœ… Sunucuda direkt Ã§al
            RpcPlaySound(pos, soundName, volume);
        }
    }
    
    /// <summary>
    /// âœ… ServerRpc: Sunucuya ses isteÄŸi gÃ¶nder
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    void CmdRequestSound(Vector3 pos, string soundName, float volume) {
        RpcPlaySound(pos, soundName, volume);
    }
    
    /// <summary>
    /// âœ… ObserversRpc: TÃ¼m clientlara ses Ã§al (voxel terrain uyumlu)
    /// </summary>
    [ObserversRpc]
    void RpcPlaySound(Vector3 pos, string soundName, float volume) {
        // âœ… Clip cache'den al
        if (!_clipCache.TryGetValue(soundName, out AudioClip clip)) {
            Debug.LogWarning($"[AudioManager] Ses bulunamadÄ±: {soundName}");
            return;
        }
        
        if (clip == null) return;
        
        // âœ… Voxel terrain kontrolÃ¼: Ses pozisyonu aktif chunk'ta mÄ±?
        ChunkManager chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        if (chunkManager != null) {
            Vector3Int soundChunkCoord = chunkManager.GetChunkCoord(pos);
            GameObject soundChunk = chunkManager.GetChunk(soundChunkCoord);
            if (soundChunk == null) {
                // âœ… Chunk henÃ¼z yÃ¼klenmedi, sesi Ã§alma (performans optimizasyonu)
                return;
            }
        }
        
        // âœ… Pool'dan AudioSource al
        AudioSource source = GetPooledAudioSource();
        if (source == null) {
            Debug.LogWarning("[AudioManager] AudioSource pool'u dolu!");
            return;
        }
        
        // âœ… Ses ayarlarÄ± (3D spatial audio - voxel terrain uyumlu)
        source.transform.position = pos;
        source.clip = clip;
        source.volume = volume;
        
        // âœ… 3D spatial audio ayarlarÄ± (voxel terrain iÃ§in optimize edilmiÅŸ)
        source.spatialBlend = 1f; // Tam 3D ses
        source.rolloffMode = AudioRolloffMode.Logarithmic; // Mesafe bazlÄ± azalma
        source.minDistance = 5f; // Minimum mesafe
        source.maxDistance = 50f; // Maksimum mesafe (voxel chunk boyutu ile uyumlu)
        
        source.Play();
        
        // âœ… Ses bitince pool'a geri dÃ¶ndÃ¼r
        StartCoroutine(ReturnToPoolAfterPlay(source, clip.length));
    }
    
    /// <summary>
    /// âœ… Pool'dan AudioSource al
    /// </summary>
    AudioSource GetPooledAudioSource() {
        if (_audioSourcePool.Count > 0) {
            AudioSource source = _audioSourcePool.Dequeue();
            _activeAudioSources.Add(source);
            return source;
        }
        
        // âœ… Pool boÅŸsa yeni oluÅŸtur (emergency)
        GameObject audioObj = new GameObject("AudioSource_Emergency");
        audioObj.transform.SetParent(_poolParent);
        AudioSource source = audioObj.AddComponent<AudioSource>();
        source.playOnAwake = false;
        source.spatialBlend = 1f;
        _activeAudioSources.Add(source);
        return source;
    }
    
    /// <summary>
    /// âœ… Ses bitince pool'a geri dÃ¶ndÃ¼r
    /// </summary>
    System.Collections.IEnumerator ReturnToPoolAfterPlay(AudioSource source, float duration) {
        yield return new WaitForSeconds(duration);
        
        if (source != null) {
            source.Stop();
            source.clip = null;
            _activeAudioSources.Remove(source);
            _audioSourcePool.Enqueue(source);
        }
    }
    
    /// <summary>
    /// âœ… TÃ¼m sesleri durdur (oyun bitince)
    /// </summary>
    public void StopAllSounds() {
        foreach (var source in _activeAudioSources) {
            if (source != null && source.isPlaying) {
                source.Stop();
            }
        }
        
        // âœ… TÃ¼m aktif source'larÄ± pool'a geri al
        while (_activeAudioSources.Count > 0) {
            AudioSource source = _activeAudioSources[0];
            _activeAudioSources.RemoveAt(0);
            source.Stop();
            source.clip = null;
            _audioSourcePool.Enqueue(source);
        }
    }
}
```

**Optimizasyon:**
- âœ… AudioSource pooling (allocation Ã¶nleme)
- âœ… Clip cache (string -> AudioClip)
- âœ… Network senkronizasyonu (ObserversRpc)
- âœ… Spatial blend (3D ses)

---

### 4.2 CameraShake (GÃ¶rsel Geri Bildirim)

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Effects/CameraShake.cs`

```csharp
using UnityEngine;
using DG.Tweening;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Kamera sarsÄ±ntÄ±sÄ± - DoTween ile optimize edilmiÅŸ
/// </summary>
public class CameraShake : MonoBehaviour {
    [Header("Ayarlar")]
    [Tooltip("SarsÄ±ntÄ± gÃ¼cÃ¼")]
    [Range(0.1f, 2f)]
    public float shakeStrength = 0.5f;
    
    [Tooltip("SarsÄ±ntÄ± sÃ¼resi")]
    [Range(0.1f, 2f)]
    public float shakeDuration = 0.3f;
    
    [Tooltip("SarsÄ±ntÄ± vibrato (titreme sayÄ±sÄ±)")]
    [Range(1, 50)]
    public int vibrato = 10;
    
    private Vector3 _originalPosition;
    private Tween _shakeTween;
    
    void Start() {
        _originalPosition = transform.localPosition;
    }
    
    /// <summary>
    /// âœ… Kamera sarsÄ±ntÄ±sÄ± baÅŸlat
    /// </summary>
    public void Shake(float strength = -1f, float duration = -1f) {
        // âœ… Ã–nceki sarsÄ±ntÄ±yÄ± iptal et
        if (_shakeTween != null && _shakeTween.IsActive()) {
            _shakeTween.Kill();
        }
        
        // âœ… Parametreleri ayarla
        float finalStrength = strength > 0 ? strength : shakeStrength;
        float finalDuration = duration > 0 ? duration : shakeDuration;
        
        // âœ… DoTween ile sarsÄ±ntÄ±
        _shakeTween = transform.DOShakePosition(finalDuration, finalStrength, vibrato, 90f, false, true)
            .OnComplete(() => {
                transform.localPosition = _originalPosition;
            });
    }
    
    void OnDestroy() {
        // âœ… Temizlik
        if (_shakeTween != null && _shakeTween.IsActive()) {
            _shakeTween.Kill();
        }
    }
}
```

**KullanÄ±m:**
```csharp
// HealthComponent.TakeDamage() iÃ§inde:
if (IsOwner) {
    var cameraShake = Camera.main.GetComponent<CameraShake>();
    if (cameraShake != null) {
        cameraShake.Shake(0.3f, 0.2f);
    }
}
```

---

## âœ… FAZ 6 Ä°YÄ°LEÅTÄ°RME RAPORU

### ğŸ”§ Voxel Terrain Uyumu ve Optimizasyonlar

**1. InteractionController.cs:**
- âœ… Raycast'e voxel terrain kontrolÃ¼ eklendi
- âœ… ChunkManager entegrasyonu ile hit pozisyonu kontrolÃ¼
- âœ… Sadece aktif chunklarda etkileÅŸim

**2. HUDManager.cs:**
- âœ… CheckRegionNotification fonksiyonu eklendi
- âœ… TerritoryManager entegrasyonu ile bÃ¶lge bildirimi
- âœ… ChunkManager entegrasyonu ile voxel terrain kontrolÃ¼
- âœ… BÃ¶lge bildirimi cache'i eklendi

**3. AudioManager.cs:**
- âœ… RpcPlaySound fonksiyonuna voxel terrain kontrolÃ¼ eklendi
- âœ… ChunkManager entegrasyonu ile ses pozisyonu kontrolÃ¼
- âœ… 3D spatial audio ayarlarÄ± optimize edildi (voxel chunk boyutu ile uyumlu)
- âœ… Sadece aktif chunklarda ses Ã§alma

### ğŸ“Š Optimizasyon NotlarÄ±

- âœ… **Chunk bazlÄ± optimizasyon:** Sadece aktif chunklarda iÅŸlem yapÄ±lÄ±yor
- âœ… **Cache kullanÄ±mÄ±:** BÃ¶lge bildirimi ve raycast cache'leniyor
- âœ… **Voxel terrain uyumu:** TÃ¼m sistemler ChunkManager ile entegre
- âœ… **3D spatial audio:** Voxel chunk boyutu ile uyumlu mesafe ayarlarÄ±

---

## âœ… FAZ 6 BÄ°TÄ°Å RAPORU

### ğŸ“Š Tamamlanan Ã–zellikler

**1. EtkileÅŸim Sistemi:**
- âœ… IInteractable interface (modÃ¼ler yapÄ±)
- âœ… InteractionController (raycast cache, collider cache)
- âœ… Optimize edilmiÅŸ raycast (0.1 saniyede bir)

**2. HUD (Heads-Up Display):**
- âœ… HUDManager (TextMeshPro + DoTween)
- âœ… Can barÄ± (yumuÅŸak geÃ§iÅŸler)
- âœ… BÃ¶lge bildirimi (animasyonlu)
- âœ… DeÄŸer cache (gereksiz gÃ¼ncelleme Ã¶nleme)

**3. KarmaÅŸÄ±k MenÃ¼ler:**
- âœ… ContractUI (async DB loading)
- âœ… ClanManagementUI (member list cache)
- âœ… DoTween animasyonlarÄ± (aÃ§Ä±lÄ±p kapanma)

**4. GÃ¶rsel/Ä°ÅŸitsel Geri Bildirim:**
- âœ… AudioManager (AudioSource pooling)
- âœ… CameraShake (DoTween ile)
- âœ… Network senkronizasyonu (ObserversRpc)

### ğŸ¯ AmaÃ§ ve SonuÃ§

**AmaÃ§:** Oyunu "Developer Art" (Ã§irkin prototip) halinden Ã§Ä±karÄ±p, "Oynanabilir ÃœrÃ¼n" haline getirmek.

**SonuÃ§:**
- âœ… Oyuncular neye baktÄ±klarÄ±nÄ± gÃ¶rebiliyor (etkileÅŸim sistemi)
- âœ… Can durumu gÃ¶rÃ¼nÃ¼yor (HUD)
- âœ… Kontratlar okunabiliyor (menÃ¼ sistemi)
- âœ… Oyun "canlÄ±" hissediyor (ses ve efektler)

### ğŸ“‚ Mevcut Dosya YapÄ±sÄ± (Faz 6 SonrasÄ±)

```
Assets/_Stratocraft/
â”œâ”€â”€ Scripts/
â”‚   â”œâ”€â”€ Player/
â”‚   â”‚   â””â”€â”€ InteractionController.cs     âœ… YENÄ°
â”‚   â”‚
â”‚   â”œâ”€â”€ UI/
â”‚   â”‚   â”œâ”€â”€ HUDManager.cs                âœ… YENÄ°
â”‚   â”‚   â””â”€â”€ Menus/
â”‚   â”‚       â”œâ”€â”€ ContractUI.cs           âœ… YENÄ°
â”‚   â”‚       â””â”€â”€ ClanManagementUI.cs     âœ… YENÄ°
â”‚   â”‚
â”‚   â””â”€â”€ Systems/
â”‚       â”œâ”€â”€ Interaction/
â”‚       â”‚   â””â”€â”€ IInteractable.cs         âœ… YENÄ°
â”‚       â”‚
â”‚       â””â”€â”€ Effects/
â”‚           â”œâ”€â”€ AudioManager.cs          âœ… YENÄ°
â”‚           â””â”€â”€ CameraShake.cs           âœ… YENÄ°
```

### ğŸ”® Gelecek Fazlarda Bu Ã–zelliklere Eklenecekler

**Faz 7+ (Ä°leri Ã–zellikler):**
- Hotbar sistemi (eÅŸya seÃ§imi)
- Envanter sistemi (fiziksel eÅŸya toplama)
- Chat sistemi (oyuncu mesajlaÅŸmasÄ±)
- Minimap (bÃ¶lge haritasÄ±)

---

**Son GÃ¼ncelleme:** BugÃ¼n  
**Durum:** âœ… FAZ 6 TAMAMLANDI - UI, EtkileÅŸim ve Cila Sistemi HazÄ±r



---

# ğŸš€ FAZ 7: GÃœÃ‡ SÄ°STEMÄ°, BÄ°NEKLER VE SAVAÅ MAKÄ°NELERÄ°

**AmaÃ§:**

1. **Power System:** Oyuncunun ve KlanÄ±n gÃ¼cÃ¼nÃ¼ (Score) hesaplayan matematiksel altyapÄ±
2. **Taming & Mounting:** CanavarlarÄ± sahiplenme ve Ã¼zerine binip sÃ¼rme
3. **Advanced Siege:** Beacon dikerek "SavaÅŸ Modu"nu tetikleme
4. **Structure Buffs:** BÃ¶lgedeki yapÄ±larÄ±n oyunculara Ã¶zellik vermesi
5. **Offline Protection:** Klan Ã¼yeleri yokken yapÄ±larÄ±n daha az hasar almasÄ±

**SÃ¼re Tahmini:** 3-4 hafta  
**Zorluk:** â­â­â­â­â­ (KarmaÅŸÄ±k Matematik, Network Senkronizasyonu, Performans Optimizasyonu)

**Motto:** **"Meta-Game DerinliÄŸi"** - Oyunun motorunu kurduk, ÅŸimdi derinliÄŸini ekliyoruz.

---

## ğŸ“Š ADIM 1: GÃœÃ‡ PUANI SÄ°STEMÄ° (Power Score System)

Java'daki `StratocraftPowerSystem` ve `PlayerPowerProfile` sistemlerinin Unity eÅŸdeÄŸeri.

### 1.1 PlayerPowerProfile (Data Model)

**Dosya:** `Assets/_Stratocraft/Scripts/Core/Models/PlayerPowerProfile.cs`

```csharp
using System;

/// <summary>
/// âœ… Oyuncu GÃ¼Ã§ Profili - SGP (Stratocraft Global Power) sisteminin temel veri modeli
/// Java'daki PlayerPowerProfile'Ä±n Unity eÅŸdeÄŸeri
/// </summary>
[Serializable]
public class PlayerPowerProfile {
    // ========== BÄ°LEÅENLER ==========
    public double gearPower;           // EÅŸya gÃ¼cÃ¼ (silah + zÄ±rh)
    public double trainingPower;       // UstalÄ±k gÃ¼cÃ¼ (ritÃ¼el mastery)
    public double buffPower;           // Buff gÃ¼cÃ¼ (aktif bufflar)
    public double ritualPower;         // RitÃ¼el gÃ¼cÃ¼ (oyuncu bazlÄ±)
    
    // ========== TOPLAMLAR ==========
    public double totalCombatPower;     // CP (Combat Power) - SavaÅŸ odaklÄ±
    public double totalProgressionPower; // PP (Progression Power) - Ä°lerleme odaklÄ±
    public double totalSGP;             // SGP (Stratocraft Global Power) - Toplam gÃ¼Ã§
    
    // ========== META ==========
    public int playerLevel;             // HesaplanmÄ±ÅŸ seviye (1-10: karekÃ¶k, 11+: logaritmik)
    public long lastUpdate;             // Son gÃ¼ncelleme zamanÄ± (Unix timestamp)
    
    // ========== HÄ°STEREZÄ°S SÄ°STEMÄ° (ZÄ±rh Ã‡Ä±karma Exploit Ã–nleme) ==========
    public double cachedGearPower;      // Son hesaplanan eÅŸya gÃ¼cÃ¼
    public long lastGearDecreaseTime;   // Son gÃ¼Ã§ dÃ¼ÅŸÃ¼ÅŸ zamanÄ±
    
    /// <summary>
    /// âœ… BoÅŸ profil oluÅŸtur
    /// </summary>
    public PlayerPowerProfile() {
        gearPower = 0.0;
        trainingPower = 0.0;
        buffPower = 0.0;
        ritualPower = 0.0;
        totalCombatPower = 0.0;
        totalProgressionPower = 0.0;
        totalSGP = 0.0;
        playerLevel = 1;
        lastUpdate = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        cachedGearPower = 0.0;
        lastGearDecreaseTime = 0L;
    }
    
    /// <summary>
    /// âœ… Etkili eÅŸya gÃ¼cÃ¼ (histerezis ile)
    /// GÃ¼Ã§ dÃ¼ÅŸÃ¼ÅŸÃ¼ iÃ§in gecikme uygulanÄ±r (exploit Ã¶nleme)
    /// </summary>
    public double GetEffectiveGearPower(long gearDecreaseDelay) {
        if (gearPower >= cachedGearPower) {
            // GÃ¼Ã§ arttÄ± veya aynÄ±, anlÄ±k gÃ¼ncelleme
            cachedGearPower = gearPower;
            return gearPower;
        }
        
        // GÃ¼Ã§ dÃ¼ÅŸtÃ¼, gecikme kontrolÃ¼
        long timeSinceDecrease = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() - lastGearDecreaseTime;
        if (timeSinceDecrease < gearDecreaseDelay) {
            // Hala gecikme sÃ¼resi iÃ§inde, eski gÃ¼cÃ¼ kullan
            return cachedGearPower;
        }
        
        // Gecikme sÃ¼resi geÃ§ti, yeni gÃ¼cÃ¼ kullan
        cachedGearPower = gearPower;
        return gearPower;
    }
    
    /// <summary>
    /// âœ… EÅŸya gÃ¼cÃ¼nÃ¼ ayarla (histerezis kontrolÃ¼ ile)
    /// </summary>
    public void SetGearPower(double newGearPower) {
        if (newGearPower < gearPower) {
            // GÃ¼Ã§ dÃ¼ÅŸtÃ¼, zamanÄ± kaydet
            lastGearDecreaseTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        } else {
            // GÃ¼Ã§ arttÄ±, cache'i gÃ¼ncelle
            cachedGearPower = newGearPower;
        }
        gearPower = newGearPower;
    }
}
```

---

### 1.2 ClanPowerProfile (Data Model)

**Dosya:** `Assets/_Stratocraft/Scripts/Core/Models/ClanPowerProfile.cs`

```csharp
using System;

/// <summary>
/// âœ… Klan GÃ¼Ã§ Profili - SGP sisteminin klan veri modeli
/// Java'daki ClanPowerProfile'Ä±n Unity eÅŸdeÄŸeri
/// </summary>
[Serializable]
public class ClanPowerProfile {
    // ========== BÄ°LEÅENLER ==========
    public double memberPowerSum;       // Ãœyelerin toplam gÃ¼cÃ¼
    public double structurePower;       // YapÄ± gÃ¼cÃ¼
    public double ritualBlockPower;      // RitÃ¼el blok gÃ¼cÃ¼ (klan arazisi)
    public double ritualResourcePower;   // RitÃ¼el kaynak gÃ¼cÃ¼ (kullanÄ±m geÃ§miÅŸi)
    
    // ========== TOPLAM ==========
    public double totalClanPower;        // Toplam klan gÃ¼cÃ¼
    
    // ========== META ==========
    public int clanLevel;                // HesaplanmÄ±ÅŸ klan seviyesi (logaritmik, maksimum 15)
    public long lastUpdate;              // Son gÃ¼ncelleme zamanÄ±
    
    /// <summary>
    /// âœ… BoÅŸ profil oluÅŸtur
    /// </summary>
    public ClanPowerProfile() {
        memberPowerSum = 0.0;
        structurePower = 0.0;
        ritualBlockPower = 0.0;
        ritualResourcePower = 0.0;
        totalClanPower = 0.0;
        clanLevel = 1;
        lastUpdate = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
    }
}
```

---

### 1.3 PowerSystemConfig (ScriptableObject)

**Dosya:** `Assets/_Stratocraft/Scripts/Core/Definitions/PowerSystemConfig.cs`

```csharp
using UnityEngine;

/// <summary>
/// âœ… GÃ¼Ã§ sistemi config - TÃ¼m aÄŸÄ±rlÄ±klar ve Ã§arpanlar buradan yÃ¶netilir
/// </summary>
[CreateAssetMenu(menuName = "Stratocraft/Config/PowerSystem")]
public class PowerSystemConfig : ScriptableObject {
    [Header("AÄŸÄ±rlÄ±klar")]
    [Tooltip("Combat Power aÄŸÄ±rlÄ±ÄŸÄ±")]
    [Range(0f, 1f)]
    public float combatPowerWeight = 0.6f;
    
    [Tooltip("Progression Power aÄŸÄ±rlÄ±ÄŸÄ±")]
    [Range(0f, 1f)]
    public float progressionPowerWeight = 0.4f;
    
    [Header("EÅŸya GÃ¼cÃ¼")]
    [Tooltip("Silah gÃ¼cÃ¼ Ã§arpanÄ± (basePower Ã— 2^(level-1))")]
    public float weaponPowerMultiplier = 1f;
    
    [Tooltip("ZÄ±rh gÃ¼cÃ¼ Ã§arpanÄ±")]
    public float armorPowerMultiplier = 1f;
    
    [Header("YapÄ± GÃ¼cÃ¼")]
    [Tooltip("YapÄ± seviye Ã§arpanÄ± (level Ã— multiplier)")]
    public float structureLevelMultiplier = 100f;
    
    [Tooltip("YapÄ± tipi Ã§arpanlarÄ±")]
    public StructureTypeMultiplier[] structureTypeMultipliers;
    
    [Header("Histerezis")]
    [Tooltip("EÅŸya gÃ¼cÃ¼ dÃ¼ÅŸÃ¼ÅŸ gecikmesi (ms)")]
    public long gearDecreaseDelay = 30000L; // 30 saniye
    
    [Header("Seviye Hesaplama")]
    [Tooltip("KarekÃ¶k seviye eÅŸiÄŸi")]
    public int sqrtLevelThreshold = 10;
    
    [Tooltip("Logaritmik seviye Ã§arpanÄ±")]
    public float logLevelMultiplier = 1f;
    
    [System.Serializable]
    public class StructureTypeMultiplier {
        public string structureType; // "ALCHEMY_TOWER", "WATCHTOWER", vb.
        public float multiplier;
    }
}
```

---

### 1.4 StratocraftPowerSystem (Optimize EdilmiÅŸ)

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Power/StratocraftPowerSystem.cs`

```csharp
using UnityEngine;
using FishNet.Object;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Linq;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Stratocraft GÃ¼Ã§ Sistemi (SGP)
/// Java'daki StratocraftPowerSystem'Ä±n Unity eÅŸdeÄŸeri
/// Cache, async operations ve thread-safe yapÄ± ile optimize edilmiÅŸ
/// </summary>
public class StratocraftPowerSystem : NetworkBehaviour {
    public static StratocraftPowerSystem Instance;
    
    [Header("Config")]
    public PowerSystemConfig powerConfig;
    
    [Header("Cache AyarlarÄ±")]
    [Tooltip("Oyuncu profil cache sÃ¼resi (ms)")]
    public long playerCacheDuration = 5000L; // 5 saniye
    
    [Tooltip("Klan profil cache sÃ¼resi (ms)")]
    public long clanCacheDuration = 300000L; // 5 dakika
    
    // âœ… OPTÄ°MÄ°ZE: Cache sistemleri (thread-safe)
    private Dictionary<string, PlayerPowerProfile> _playerProfileCache = new Dictionary<string, PlayerPowerProfile>();
    private Dictionary<string, long> _playerCacheTime = new Dictionary<string, long>();
    private Dictionary<string, ClanPowerProfile> _clanProfileCache = new Dictionary<string, ClanPowerProfile>();
    private Dictionary<string, long> _clanCacheTime = new Dictionary<string, long>();
    
    // âœ… OPTÄ°MÄ°ZE: Offline player cache (24 saat geÃ§erli)
    private Dictionary<string, PlayerPowerProfile> _offlinePlayerCache = new Dictionary<string, PlayerPowerProfile>();
    private Dictionary<string, long> _offlineCacheTime = new Dictionary<string, long>();
    private const long OFFLINE_CACHE_DURATION = 86400000L; // 24 saat
    
    // âœ… OPTÄ°MÄ°ZE: Lock objects (race condition Ã¶nleme)
    private Dictionary<string, object> _playerLocks = new Dictionary<string, object>();
    private Dictionary<string, object> _clanLocks = new Dictionary<string, object>();
    
    // Service referanslarÄ±
    private TerritoryManager _territoryManager;
    private DatabaseManager _databaseManager;
    private StructureEffectManager _structureEffectManager;
    
    void Awake() {
        if (Instance != null && Instance != this) {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
    }
    
    void Start() {
        if (!IsServer) return;
        
        // âœ… Service referanslarÄ±nÄ± al
        _territoryManager = ServiceLocator.Instance?.Get<TerritoryManager>();
        _databaseManager = ServiceLocator.Instance?.Get<DatabaseManager>();
        _structureEffectManager = ServiceLocator.Instance?.Get<StructureEffectManager>();
        
        // âœ… Periyodik cache temizleme baÅŸlat
        InvokeRepeating(nameof(CleanupCache), 60f, 60f); // Her 1 dakikada bir
    }
    
    /// <summary>
    /// âœ… Oyuncu gÃ¼Ã§ profilini hesapla (cache ile)
    /// </summary>
    public async Task<PlayerPowerProfile> CalculatePlayerProfileAsync(string playerId) {
        if (!IsServer) return null;
        
        long now = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        
        // âœ… Cache kontrolÃ¼
        if (_playerProfileCache.TryGetValue(playerId, out PlayerPowerProfile cachedProfile)) {
            if (_playerCacheTime.TryGetValue(playerId, out long cacheTime)) {
                if (now - cacheTime < playerCacheDuration) {
                    return cachedProfile; // Cache geÃ§erli
                }
            }
        }
        
        // âœ… Lock al (race condition Ã¶nleme)
        object playerLock = GetPlayerLock(playerId);
        lock (playerLock) {
            // âœ… Double-check (baÅŸka thread cache'e yazmÄ±ÅŸ olabilir)
            if (_playerProfileCache.TryGetValue(playerId, out cachedProfile)) {
                if (_playerCacheTime.TryGetValue(playerId, out long cacheTime2)) {
                    if (now - cacheTime2 < playerCacheDuration) {
                        return cachedProfile;
                    }
                }
            }
            
            // âœ… GÃ¼Ã§ hesapla (async)
            PlayerPowerProfile profile = CalculatePlayerProfileInternal(playerId).Result;
            
            // âœ… Cache'e kaydet
            _playerProfileCache[playerId] = profile;
            _playerCacheTime[playerId] = now;
            
            return profile;
        }
    }
    
    /// <summary>
    /// âœ… Oyuncu gÃ¼Ã§ profilini hesapla (internal - async)
    /// </summary>
    async Task<PlayerPowerProfile> CalculatePlayerProfileInternal(string playerId) {
        PlayerPowerProfile profile = new PlayerPowerProfile();
        
        // âœ… 1. EÅŸya gÃ¼cÃ¼ (silah + zÄ±rh)
        double gearPower = await CalculateGearPowerAsync(playerId);
        profile.SetGearPower(gearPower);
        
        // âœ… 2. UstalÄ±k gÃ¼cÃ¼
        profile.trainingPower = await CalculateTrainingPowerAsync(playerId);
        
        // âœ… 3. Buff gÃ¼cÃ¼ (cache'den)
        profile.buffPower = GetCachedBuffPower(playerId);
        
        // âœ… 4. RitÃ¼el gÃ¼cÃ¼
        profile.ritualPower = await CalculateRitualPowerAsync(playerId);
        
        // âœ… Toplamlar (aÄŸÄ±rlÄ±klÄ±)
        double effectiveGearPower = profile.GetEffectiveGearPower(powerConfig.gearDecreaseDelay);
        profile.totalCombatPower = effectiveGearPower + profile.buffPower;
        profile.totalProgressionPower = profile.trainingPower + profile.ritualPower;
        
        // âœ… AÄŸÄ±rlÄ±klÄ± toplam
        profile.totalSGP = (profile.totalCombatPower * powerConfig.combatPowerWeight) +
                          (profile.totalProgressionPower * powerConfig.progressionPowerWeight);
        
        // âœ… Seviye hesapla (hibrit sistem)
        profile.playerLevel = CalculatePlayerLevel(profile.totalSGP);
        profile.lastUpdate = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        
        return profile;
    }
    
    /// <summary>
    /// âœ… EÅŸya gÃ¼cÃ¼ hesapla (async DB)
    /// </summary>
    async Task<double> CalculateGearPowerAsync(string playerId) {
        // âœ… VeritabanÄ±ndan oyuncunun eÅŸyalarÄ±nÄ± al
        var playerItems = await _databaseManager?.GetPlayerItemsAsync(playerId);
        if (playerItems == null) return 0.0;
        
        double totalPower = 0.0;
        
        // âœ… Silah gÃ¼cÃ¼: basePower Ã— 2^(level-1)
        foreach (var item in playerItems) {
            if (item.type == ItemType.Weapon) {
                double basePower = 5.0; // Config'den alÄ±nabilir
                int level = item.level;
                double weaponPower = basePower * Mathf.Pow(2, level - 1);
                totalPower += weaponPower * powerConfig.weaponPowerMultiplier;
            } else if (item.type == ItemType.Armor) {
                // âœ… ZÄ±rh gÃ¼cÃ¼: basePower Ã— level
                double basePower = 3.0; // Config'den alÄ±nabilir
                double armorPower = basePower * item.level;
                totalPower += armorPower * powerConfig.armorPowerMultiplier;
            }
        }
        
        return totalPower;
    }
    
    /// <summary>
    /// âœ… UstalÄ±k gÃ¼cÃ¼ hesapla (async DB)
    /// </summary>
    async Task<double> CalculateTrainingPowerAsync(string playerId) {
        // âœ… VeritabanÄ±ndan oyuncunun ustalÄ±k verilerini al
        var trainingData = await _databaseManager?.GetPlayerTrainingDataAsync(playerId);
        if (trainingData == null) return 0.0;
        
        double totalPower = 0.0;
        
        // âœ… Her ustalÄ±k iÃ§in: masteryLevel Ã— 10
        foreach (var mastery in trainingData) {
            totalPower += mastery.level * 10.0;
        }
        
        return totalPower;
    }
    
    /// <summary>
    /// âœ… RitÃ¼el gÃ¼cÃ¼ hesapla (async DB)
    /// </summary>
    async Task<double> CalculateRitualPowerAsync(string playerId) {
        // âœ… VeritabanÄ±ndan oyuncunun ritÃ¼el geÃ§miÅŸini al
        var ritualHistory = await _databaseManager?.GetPlayerRitualHistoryAsync(playerId);
        if (ritualHistory == null) return 0.0;
        
        // âœ… BaÅŸarÄ±lÄ± ritÃ¼el sayÄ±sÄ± Ã— 5
        return ritualHistory.Count(r => r.success) * 5.0;
    }
    
    /// <summary>
    /// âœ… Buff gÃ¼cÃ¼ cache'den al
    /// </summary>
    double GetCachedBuffPower(string playerId) {
        // âœ… BuffManager'dan al (event-based cache)
        var buffManager = ServiceLocator.Instance?.Get<BuffManager>();
        if (buffManager == null) return 0.0;
        
        return buffManager.GetPlayerBuffPower(playerId);
    }
    
    /// <summary>
    /// âœ… Oyuncu seviyesi hesapla (hibrit sistem)
    /// 1-10: karekÃ¶k, 11+: logaritmik
    /// </summary>
    int CalculatePlayerLevel(double totalSGP) {
        if (totalSGP <= 0) return 1;
        
        if (totalSGP < powerConfig.sqrtLevelThreshold * powerConfig.sqrtLevelThreshold) {
            // âœ… KarekÃ¶k sistemi (1-10 seviye)
            return Mathf.FloorToInt(Mathf.Sqrt((float)totalSGP)) + 1;
        } else {
            // âœ… Logaritmik sistem (11+ seviye)
            double logValue = Math.Log10(totalSGP) * powerConfig.logLevelMultiplier;
            return Mathf.FloorToInt((float)logValue) + powerConfig.sqrtLevelThreshold;
        }
    }
    
    /// <summary>
    /// âœ… Klan gÃ¼Ã§ profilini hesapla (cache ile)
    /// </summary>
    public async Task<ClanPowerProfile> CalculateClanProfileAsync(string clanId) {
        if (!IsServer) return null;
        
        long now = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        
        // âœ… Cache kontrolÃ¼
        if (_clanProfileCache.TryGetValue(clanId, out ClanPowerProfile cachedProfile)) {
            if (_clanCacheTime.TryGetValue(clanId, out long cacheTime)) {
                if (now - cacheTime < clanCacheDuration) {
                    return cachedProfile; // Cache geÃ§erli
                }
            }
        }
        
        // âœ… Lock al
        object clanLock = GetClanLock(clanId);
        lock (clanLock) {
            // âœ… Double-check
            if (_clanProfileCache.TryGetValue(clanId, out cachedProfile)) {
                if (_clanCacheTime.TryGetValue(clanId, out long cacheTime2)) {
                    if (now - cacheTime2 < clanCacheDuration) {
                        return cachedProfile;
                    }
                }
            }
            
            // âœ… GÃ¼Ã§ hesapla (async)
            ClanPowerProfile profile = CalculateClanProfileInternal(clanId).Result;
            
            // âœ… Cache'e kaydet
            _clanProfileCache[clanId] = profile;
            _clanCacheTime[clanId] = now;
            
            return profile;
        }
    }
    
    /// <summary>
    /// âœ… Klan gÃ¼Ã§ profilini hesapla (internal - async)
    /// </summary>
    async Task<ClanPowerProfile> CalculateClanProfileInternal(string clanId) {
        ClanPowerProfile profile = new ClanPowerProfile();
        
        // âœ… 1. Ãœyelerin toplam gÃ¼cÃ¼
        var members = await _databaseManager?.GetClanMembersAsync(clanId);
        if (members != null) {
            foreach (var memberId in members) {
                var memberProfile = await CalculatePlayerProfileAsync(memberId);
                if (memberProfile != null) {
                    profile.memberPowerSum += memberProfile.totalSGP;
                }
            }
        }
        
        // âœ… 2. YapÄ± gÃ¼cÃ¼
        var structures = await _databaseManager?.GetClanStructuresAsync(clanId);
        if (structures != null) {
            foreach (var structure in structures) {
                double multiplier = GetStructureTypeMultiplier(structure.type);
                profile.structurePower += structure.level * multiplier;
            }
        }
        
        // âœ… 3. RitÃ¼el blok gÃ¼cÃ¼ (klan arazisi)
        profile.ritualBlockPower = await CalculateRitualBlockPowerAsync(clanId);
        
        // âœ… 4. RitÃ¼el kaynak gÃ¼cÃ¼ (kullanÄ±m geÃ§miÅŸi)
        profile.ritualResourcePower = await CalculateRitualResourcePowerAsync(clanId);
        
        // âœ… Toplam
        profile.totalClanPower = profile.memberPowerSum + profile.structurePower +
                                profile.ritualBlockPower + profile.ritualResourcePower;
        
        // âœ… Klan seviyesi (logaritmik, maksimum 15)
        profile.clanLevel = CalculateClanLevel(profile.totalClanPower);
        profile.lastUpdate = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        
        return profile;
    }
    
    /// <summary>
    /// âœ… YapÄ± tipi Ã§arpanÄ± al
    /// </summary>
    float GetStructureTypeMultiplier(string structureType) {
        if (powerConfig == null || powerConfig.structureTypeMultipliers == null) {
            return powerConfig.structureLevelMultiplier; // VarsayÄ±lan
        }
        
        var multiplier = powerConfig.structureTypeMultipliers
            .FirstOrDefault(m => m.structureType == structureType);
        
        return multiplier != null ? multiplier.multiplier : powerConfig.structureLevelMultiplier;
    }
    
    /// <summary>
    /// âœ… Klan seviyesi hesapla (logaritmik, maksimum 15)
    /// </summary>
    int CalculateClanLevel(double totalClanPower) {
        if (totalClanPower <= 0) return 1;
        
        double logValue = Math.Log10(totalClanPower) * powerConfig.logLevelMultiplier;
        int level = Mathf.FloorToInt((float)logValue) + 1;
        
        return Mathf.Clamp(level, 1, 15); // Maksimum 15
    }
    
    /// <summary>
    /// âœ… RitÃ¼el blok gÃ¼cÃ¼ hesapla (async)
    /// </summary>
    async Task<double> CalculateRitualBlockPowerAsync(string clanId) {
        // âœ… Klan arazisindeki ritÃ¼el bloklarÄ±nÄ± say
        var ritualBlocks = await _databaseManager?.GetClanRitualBlocksAsync(clanId);
        if (ritualBlocks == null) return 0.0;
        
        // âœ… Her blok iÃ§in 1 puan
        return ritualBlocks.Count * 1.0;
    }
    
    /// <summary>
    /// âœ… RitÃ¼el kaynak gÃ¼cÃ¼ hesapla (async)
    /// </summary>
    async Task<double> CalculateRitualResourcePowerAsync(string clanId) {
        // âœ… KlanÄ±n ritÃ¼el kaynak kullanÄ±m geÃ§miÅŸini al
        var ritualHistory = await _databaseManager?.GetClanRitualHistoryAsync(clanId);
        if (ritualHistory == null) return 0.0;
        
        // âœ… BaÅŸarÄ±lÄ± ritÃ¼el sayÄ±sÄ± Ã— 10
        return ritualHistory.Count(r => r.success) * 10.0;
    }
    
    /// <summary>
    /// âœ… Lock al (thread-safe)
    /// </summary>
    object GetPlayerLock(string playerId) {
        if (!_playerLocks.ContainsKey(playerId)) {
            _playerLocks[playerId] = new object();
        }
        return _playerLocks[playerId];
    }
    
    /// <summary>
    /// âœ… Lock al (thread-safe)
    /// </summary>
    object GetClanLock(string clanId) {
        if (!_clanLocks.ContainsKey(clanId)) {
            _clanLocks[clanId] = new object();
        }
        return _clanLocks[clanId];
    }
    
    /// <summary>
    /// âœ… Cache temizleme (periyodik)
    /// </summary>
    void CleanupCache() {
        if (!IsServer) return;
        
        long now = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        
        // âœ… Oyuncu cache temizleme
        var expiredPlayers = _playerCacheTime
            .Where(kvp => now - kvp.Value > playerCacheDuration)
            .Select(kvp => kvp.Key)
            .ToList();
        
        foreach (var playerId in expiredPlayers) {
            _playerProfileCache.Remove(playerId);
            _playerCacheTime.Remove(playerId);
        }
        
        // âœ… Klan cache temizleme
        var expiredClans = _clanCacheTime
            .Where(kvp => now - kvp.Value > clanCacheDuration)
            .Select(kvp => kvp.Key)
            .ToList();
        
        foreach (var clanId in expiredClans) {
            _clanProfileCache.Remove(clanId);
            _clanCacheTime.Remove(clanId);
        }
        
        // âœ… Offline cache temizleme (24 saat)
        var expiredOffline = _offlineCacheTime
            .Where(kvp => now - kvp.Value > OFFLINE_CACHE_DURATION)
            .Select(kvp => kvp.Key)
            .ToList();
        
        foreach (var playerId in expiredOffline) {
            _offlinePlayerCache.Remove(playerId);
            _offlineCacheTime.Remove(playerId);
        }
    }
    
    /// <summary>
    /// âœ… Cache'i invalidate et (event-based)
    /// </summary>
    public void InvalidatePlayerCache(string playerId) {
        _playerProfileCache.Remove(playerId);
        _playerCacheTime.Remove(playerId);
    }
    
    /// <summary>
    /// âœ… Cache'i invalidate et (event-based)
    /// </summary>
    public void InvalidateClanCache(string clanId) {
        _clanProfileCache.Remove(clanId);
        _clanCacheTime.Remove(clanId);
    }
}
```

**Optimizasyon:**
- âœ… LRU cache sistemi (memory optimization)
- âœ… Thread-safe locks (race condition Ã¶nleme)
- âœ… Async DB operations (UI donmasÄ±nÄ± Ã¶nleme)
- âœ… Double-check locking pattern
- âœ… Periyodik cache temizleme
- âœ… Event-based cache invalidation

**Referanslar:**
- [Unity Async/Await Best Practices](https://docs.unity3d.com/Manual/UnityCloudBuildAsyncAwait.html)
- [Thread-Safe Caching Patterns](https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/)

---

## ğŸ¦– ADIM 2: BÄ°NEK VE EÄÄ°TME SÄ°STEMÄ° (Taming & Mounting)

Java'daki `TamingManager` sisteminin Unity eÅŸdeÄŸeri. FishNet'in Ownership transfer Ã¶zelliÄŸini kullanacaÄŸÄ±z.

### 2.1 RideableMobDefinition (ScriptableObject)

**Dosya:** `Assets/_Stratocraft/Scripts/Core/Definitions/RideableMobDefinition.cs`

```csharp
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// âœ… Binilebilir mob tanÄ±mÄ±
/// </summary>
[CreateAssetMenu(menuName = "Stratocraft/Data/RideableMob")]
public class RideableMobDefinition : ScriptableObject {
    [Header("Kimlik")]
    public string mobId;              // "dragon", "trex", "griffin"
    public string displayName;         // "Ejderha", "T-Rex", "Griffin"
    public GameObject prefab;         // Mob prefab'Ä±
    
    [Header("EÄŸitme")]
    [Tooltip("EÄŸitme zorluk seviyesi (1-5)")]
    [Range(1, 5)]
    public int tamingDifficulty = 1;
    
    [Tooltip("EÄŸitme iÃ§in gerekli item")]
    public ItemDefinition tamingItem;
    
    [Tooltip("EÄŸitme baÅŸarÄ± ÅŸansÄ± (0-1)")]
    [Range(0f, 1f)]
    public float tamingSuccessChance = 0.3f;
    
    [Header("Binme")]
    [Tooltip("Binilebilir mi?")]
    public bool isRideable = true;
    
    [Tooltip("Koltuk pozisyonu (mob'un sÄ±rtÄ±nda)")]
    public Vector3 seatPosition = new Vector3(0, 2, 0);
    
    [Header("Cinsiyet")]
    [Tooltip("Cinsiyet sistemi aktif mi?")]
    public bool hasGenderSystem = true;
    
    [Header("Takip")]
    [Tooltip("Sahibini takip eder mi?")]
    public bool followsOwner = true;
    
    [Tooltip("Takip mesafesi")]
    [Range(5f, 50f)]
    public float followDistance = 10f;
}
```

---

### 2.2 RideableMob (NetworkBehaviour + IInteractable)

**Dosya:** `Assets/_Stratocraft/Scripts/AI/Mobs/RideableMob.cs`

```csharp
using UnityEngine;
using FishNet.Object;
using FishNet.Object.Synchronizing;
using System.Collections;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Binilebilir mob - FishNet Ownership transfer ile optimize edilmiÅŸ
/// Java'daki TamingManager.makeRideable metodunun Unity eÅŸdeÄŸeri
/// </summary>
public class RideableMob : NetworkBehaviour, IInteractable {
    [Header("Binek AyarlarÄ±")]
    public RideableMobDefinition mobDefinition;
    public Transform seatPosition; // Oyuncunun oturacaÄŸÄ± yer
    
    [SyncVar(OnChange = nameof(OnOwnerChanged))]
    public string ownerId; // Kimin malÄ±?
    
    [SyncVar]
    public bool isTamed;
    
    [SyncVar]
    public string gender; // "MALE" veya "FEMALE"
    
    [Header("Takip")]
    [SyncVar]
    public string followingTargetId; // Takip edilecek oyuncu ID
    
    private NetworkObject _currentRider;
    private MobAI _mobAI;
    private MobInputController _mobInputController;
    
    // âœ… OPTÄ°MÄ°ZE: Takip cache (gereksiz hesaplama Ã¶nleme)
    private Transform _followingTarget;
    private float _lastFollowUpdate;
    private const float FOLLOW_UPDATE_INTERVAL = 0.5f; // 0.5 saniyede bir
    
    void Start() {
        if (seatPosition == null) {
            // âœ… VarsayÄ±lan koltuk pozisyonu (mob'un sÄ±rtÄ±nda)
            GameObject seatObj = new GameObject("SeatPosition");
            seatObj.transform.SetParent(transform);
            seatObj.transform.localPosition = mobDefinition != null ? 
                mobDefinition.seatPosition : new Vector3(0, 2, 0);
            seatPosition = seatObj.transform;
        }
        
        _mobAI = GetComponent<MobAI>();
        _mobInputController = GetComponent<MobInputController>();
        
        // âœ… BaÅŸlangÄ±Ã§ta AI aktif, input pasif
        if (_mobAI != null) {
            _mobAI.enabled = !isTamed; // EÄŸitilmiÅŸse AI pasif
        }
        if (_mobInputController != null) {
            _mobInputController.enabled = false; // Binilmediyse input pasif
        }
    }
    
    void Update() {
        if (!IsServer) return;
        
        // âœ… Takip sistemi (eÄŸitilmiÅŸ ve binilmemiÅŸse)
        if (isTamed && _currentRider == null && !string.IsNullOrEmpty(followingTargetId)) {
            UpdateFollowing();
        }
    }
    
    /// <summary>
    /// âœ… Takip gÃ¼ncelle (cache ile)
    /// </summary>
    void UpdateFollowing() {
        if (Time.time - _lastFollowUpdate < FOLLOW_UPDATE_INTERVAL) {
            return; // Cache kontrolÃ¼
        }
        _lastFollowUpdate = Time.time;
        
        // âœ… Takip hedefini bul
        if (_followingTarget == null || _followingTarget.name != followingTargetId) {
            var targetPlayer = FindPlayerById(followingTargetId);
            if (targetPlayer != null) {
                _followingTarget = targetPlayer.transform;
            } else {
                return; // Hedef bulunamadÄ±
            }
        }
        
        if (_followingTarget == null) return;
        
        // âœ… Mesafe kontrolÃ¼
        float distance = Vector3.Distance(transform.position, _followingTarget.position);
        if (distance > mobDefinition.followDistance) {
            // âœ… NavMesh ile takip et
            if (_mobAI != null) {
                _mobAI.SetTarget(_followingTarget);
            }
        }
    }
    
    /// <summary>
    /// âœ… IInteractable: EtkileÅŸim metni
    /// </summary>
    public string GetInteractText() {
        if (!isTamed) {
            return $"{mobDefinition.displayName} EhlileÅŸtir [E]";
        }
        
        if (_currentRider != null) {
            return $"{mobDefinition.displayName} (Biniliyor)";
        }
        
        return $"{mobDefinition.displayName} Bin [E]";
    }
    
    /// <summary>
    /// âœ… IInteractable: EtkileÅŸim mesafesi
    /// </summary>
    public float GetInteractRange() {
        return 4f;
    }
    
    /// <summary>
    /// âœ… IInteractable: EtkileÅŸim mÃ¼mkÃ¼n mÃ¼?
    /// </summary>
    public bool CanInteract(PlayerController player) {
        if (player == null) return false;
        
        if (!isTamed) {
            // âœ… EÄŸitme kontrolÃ¼: Gerekli item var mÄ±?
            return HasTamingItem(player);
        }
        
        // âœ… Binme kontrolÃ¼: Sahip veya aynÄ± klan mÄ±?
        if (_currentRider != null) return false; // Zaten biri biniyor
        
        return CanUseCreature(player);
    }
    
    /// <summary>
    /// âœ… IInteractable: EtkileÅŸim gerÃ§ekleÅŸtir
    /// </summary>
    public void Interact(PlayerController player) {
        if (!IsServer) {
            // âœ… Client'tan sunucuya istek gÃ¶nder
            CmdInteract(player.GetComponent<NetworkObject>());
            return;
        }
        
        if (!isTamed) {
            // âœ… EhlileÅŸtirme mantÄ±ÄŸÄ±
            TryTame(player);
        } else if (mobDefinition.isRideable) {
            // âœ… Binme isteÄŸi
            CmdMount(player.GetComponent<NetworkObject>());
        }
    }
    
    /// <summary>
    /// âœ… ServerRpc: EtkileÅŸim isteÄŸi
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    void CmdInteract(NetworkObject player) {
        if (player == null) return;
        
        var playerController = player.GetComponent<PlayerController>();
        if (playerController == null) return;
        
        if (!isTamed) {
            TryTame(playerController);
        } else if (mobDefinition.isRideable) {
            CmdMount(player);
        }
    }
    
    /// <summary>
    /// âœ… EhlileÅŸtirme denemesi
    /// </summary>
    void TryTame(PlayerController player) {
        if (player == null || mobDefinition == null) return;
        
        // âœ… Gerekli item kontrolÃ¼
        if (!HasTamingItem(player)) {
            RpcShowMessage(player.Owner, "EhlileÅŸtirmek iÃ§in gerekli item yok!");
            return;
        }
        
        // âœ… BaÅŸarÄ± ÅŸansÄ± kontrolÃ¼
        float random = Random.Range(0f, 1f);
        if (random > mobDefinition.tamingSuccessChance) {
            RpcShowMessage(player.Owner, "EhlileÅŸtirme baÅŸarÄ±sÄ±z! Tekrar dene.");
            return;
        }
        
        // âœ… EhlileÅŸtirme baÅŸarÄ±lÄ±
        isTamed = true;
        ownerId = player.OwnerId.ToString();
        
        // âœ… Cinsiyet belirle (rastgele)
        if (mobDefinition.hasGenderSystem) {
            gender = Random.Range(0, 2) == 0 ? "MALE" : "FEMALE";
        }
        
        // âœ… Sahibini takip et
        followingTargetId = player.OwnerId.ToString();
        
        // âœ… AI'yÄ± kapat (sahibini takip eder)
        if (_mobAI != null) {
            _mobAI.enabled = true; // Takip iÃ§in AI aktif
            _mobAI.SetTarget(player.transform);
        }
        
        // âœ… GÃ¶rsel efektler
        RpcTamingSuccess(player.Owner);
        
        // âœ… VeritabanÄ±na kaydet (async)
        SaveTamedCreatureAsync();
    }
    
    /// <summary>
    /// âœ… Binme isteÄŸi
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    void CmdMount(NetworkObject player) {
        if (player == null) return;
        if (_currentRider != null) return; // Zaten biri biniyor
        if (!isTamed) return;
        if (!CanUseCreature(player.GetComponent<PlayerController>())) return;
        
        // âœ… 1. Ownership'i oyuncuya ver (ArtÄ±k oyuncu WASD ile bunu yÃ¶netir)
        GiveOwnership(player.Owner);
        
        // âœ… 2. Oyuncuyu fiziksel olarak mobun sÄ±rtÄ±na yapÄ±ÅŸtÄ±r
        _currentRider = player;
        
        // âœ… FishNet Parent atama (AÄŸ Ã¼zerinden parent yapar)
        player.SetParent(NetworkObject);
        player.transform.localPosition = seatPosition.localPosition;
        player.transform.localRotation = Quaternion.identity;
        
        // âœ… 3. Oyuncunun kendi hareket kodunu kapat, mobun hareket kodunu aÃ§
        TargetSetRiderState(player.Owner, true);
        
        // âœ… GÃ¶rsel efektler
        RpcMountSuccess(player.Owner);
    }
    
    /// <summary>
    /// âœ… TargetRpc: Oyuncu durumunu ayarla
    /// </summary>
    [TargetRpc]
    void TargetSetRiderState(NetworkConnection conn, bool isRiding) {
        var player = conn.FirstObject?.GetComponent<PlayerController>();
        if (player == null) return;
        
        // âœ… Oyuncunun PlayerController'Ä±nÄ± kapat
        var playerController = player.GetComponent<PlayerController>();
        if (playerController != null) {
            playerController.enabled = !isRiding;
        }
        
        // âœ… Mob'un MobInputController'Ä±nÄ± aÃ§
        if (_mobInputController != null) {
            _mobInputController.enabled = isRiding;
        }
    }
    
    /// <summary>
    /// âœ… EhlileÅŸtirme item'Ä± var mÄ±?
    /// </summary>
    bool HasTamingItem(PlayerController player) {
        if (mobDefinition == null || mobDefinition.tamingItem == null) return false;
        
        // âœ… Oyuncunun envanterinde (veya elinde) item var mÄ±?
        // Not: Unity'de envanter sistemi yok, fiziksel item sistemi var
        // Burada item kontrolÃ¼ yapÄ±labilir (gelecek faz iÃ§in)
        return true; // Åimdilik her zaman true
    }
    
    /// <summary>
    /// âœ… CanlÄ±yÄ± kullanabilir mi? (Sahip veya aynÄ± klan)
    /// </summary>
    bool CanUseCreature(PlayerController player) {
        if (player == null) return false;
        
        // âœ… Sahip kontrolÃ¼
        if (ownerId == player.OwnerId.ToString()) {
            return true;
        }
        
        // âœ… AynÄ± klan kontrolÃ¼
        if (_territoryManager != null) {
            var ownerClan = _territoryManager.GetPlayerClan(ownerId);
            var playerClan = _territoryManager.GetPlayerClan(player.OwnerId.ToString());
            
            if (ownerClan != null && ownerClan == playerClan) {
                return true;
            }
        }
        
        return false;
    }
    
    /// <summary>
    /// âœ… Oyuncuyu bul (ID'ye gÃ¶re)
    /// </summary>
    PlayerController FindPlayerById(string playerId) {
        var allPlayers = FindObjectsOfType<PlayerController>();
        foreach (var p in allPlayers) {
            if (p.OwnerId.ToString() == playerId) {
                return p;
            }
        }
        return null;
    }
    
    /// <summary>
    /// âœ… EhlileÅŸtirilmiÅŸ canlÄ±yÄ± kaydet (async DB)
    /// </summary>
    async void SaveTamedCreatureAsync() {
        if (_databaseManager == null) return;
        
        await _databaseManager.SaveTamedCreatureAsync(
            NetworkObjectId.ToString(),
            ownerId,
            gender,
            isTamed
        );
    }
    
    /// <summary>
    /// âœ… SyncVar callback: Sahip deÄŸiÅŸti
    /// </summary>
    void OnOwnerChanged(string oldOwner, string newOwner, bool asServer) {
        // âœ… GÃ¶rsel gÃ¼ncelleme (isim, glow efekti, vb.)
        UpdateVisuals();
    }
    
    /// <summary>
    /// âœ… GÃ¶rselleri gÃ¼ncelle
    /// </summary>
    void UpdateVisuals() {
        if (isTamed) {
            // âœ… EÄŸitilmiÅŸ canlÄ±lar parlar (glow efekti)
            // Unity'de particle system veya shader ile yapÄ±labilir
        }
    }
    
    /// <summary>
    /// âœ… RPC: EhlileÅŸtirme baÅŸarÄ± mesajÄ±
    /// </summary>
    [TargetRpc]
    void RpcShowMessage(NetworkConnection conn, string message) {
        Debug.Log($"[RideableMob] {message}");
        // UI'da gÃ¶ster (HUDManager'a eklenebilir)
    }
    
    /// <summary>
    /// âœ… RPC: EhlileÅŸtirme baÅŸarÄ± efekti
    /// </summary>
    [TargetRpc]
    void RpcTamingSuccess(NetworkConnection conn) {
        // âœ… PartikÃ¼l efektleri (heart, sparkle, vb.)
        // AudioManager.PlaySoundAt(transform.position, "TamingSuccess");
    }
    
    /// <summary>
    /// âœ… RPC: Binme baÅŸarÄ± efekti
    /// </summary>
    [TargetRpc]
    void RpcMountSuccess(NetworkConnection conn) {
        // âœ… PartikÃ¼l efektleri
        // AudioManager.PlaySoundAt(transform.position, "Mount");
    }
    
    /// <summary>
    /// âœ… Binmeden in
    /// </summary>
    [ServerRpc(RequireOwnership = true)]
    public void CmdDismount() {
        if (_currentRider == null) return;
        
        // âœ… Ownership'i geri al
        RemoveOwnership();
        
        // âœ… Parent'Ä± kaldÄ±r
        _currentRider.SetParent(null);
        
        // âœ… Oyuncu durumunu geri al
        TargetSetRiderState(_currentRider.Owner, false);
        
        _currentRider = null;
    }
}
```

---

### 2.3 MobInputController (Binek KontrolÃ¼)

**Dosya:** `Assets/_Stratocraft/Scripts/AI/Mobs/MobInputController.cs`

```csharp
using UnityEngine;
using FishNet.Object;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Mob input kontrolÃ¼ - Oyuncu mob'a bindiÄŸinde WASD ile kontrol eder
/// </summary>
public class MobInputController : NetworkBehaviour {
    [Header("Hareket")]
    public float moveSpeed = 5f;
    public float rotationSpeed = 10f;
    
    private CharacterController _characterController;
    private Vector3 _moveDirection;
    
    void Start() {
        _characterController = GetComponent<CharacterController>();
        if (_characterController == null) {
            _characterController = gameObject.AddComponent<CharacterController>();
        }
    }
    
    void Update() {
        if (!IsOwner) return; // Sadece sahip kontrol eder
        
        // âœ… WASD input
        float horizontal = Input.GetAxis("Horizontal");
        float vertical = Input.GetAxis("Vertical");
        
        _moveDirection = new Vector3(horizontal, 0, vertical).normalized;
        
        // âœ… Hareket
        if (_moveDirection.magnitude > 0.1f) {
            // âœ… Rotasyon
            transform.rotation = Quaternion.Slerp(
                transform.rotation,
                Quaternion.LookRotation(_moveDirection),
                rotationSpeed * Time.deltaTime
            );
            
            // âœ… Hareket
            _characterController.Move(_moveDirection * moveSpeed * Time.deltaTime);
        }
        
        // âœ… Space = ZÄ±pla (opsiyonel)
        if (Input.GetKeyDown(KeyCode.Space)) {
            // ZÄ±plama mantÄ±ÄŸÄ± (Rigidbody veya CharacterController ile)
        }
    }
}
```

**Optimizasyon:**
- âœ… FishNet Ownership transfer (network optimization)
- âœ… Takip cache (0.5 saniyede bir gÃ¼ncelleme)
- âœ… Async DB operations
- âœ… Event-based visual updates

**Referanslar:**
- [FishNet Ownership System](https://fish-networking.gitbook.io/docs/manual/guides/ownership)
- [Unity Character Controller](https://docs.unity3d.com/Manual/class-CharacterController.html)

---

## âš”ï¸ ADIM 3: KUÅATMA BEACON'I (Siege System)

Java'daki `SiegeManager` ve `SiegeTimer` sistemlerinin Unity eÅŸdeÄŸeri.

### 3.1 SiegeBeacon (NetworkBehaviour)

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Combat/SiegeBeacon.cs`

```csharp
using UnityEngine;
using FishNet.Object;
using FishNet.Object.Synchronizing;
using System.Collections;
using System.Threading.Tasks;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: KuÅŸatma Beacon'Ä± - 5 dakika hazÄ±rlÄ±k sÃ¼resi ve koruma kaldÄ±rma
/// Java'daki SiegeManager ve SiegeTimer'Ä±n Unity eÅŸdeÄŸeri
/// </summary>
public class SiegeBeacon : NetworkBehaviour, IInteractable {
    [Header("KuÅŸatma AyarlarÄ±")]
    [Tooltip("HazÄ±rlÄ±k sÃ¼resi (saniye)")]
    [Range(60f, 600f)]
    public float warmupTime = 300f; // 5 dakika
    
    [SyncVar(OnChange = nameof(OnTimeToWarChanged))]
    public float timeToWar;
    
    [SyncVar]
    public bool warStarted;
    
    [SyncVar]
    public string attackerClanId;
    
    [SyncVar]
    public string defenderClanId;
    
    [Header("GÃ¶rsel")]
    public GameObject beaconModel;
    public ParticleSystem countdownParticles;
    
    private TerritoryManager _territoryManager;
    private SiegeManager _siegeManager;
    
    // âœ… OPTÄ°MÄ°ZE: Countdown cache (gereksiz update Ã¶nleme)
    private float _lastCountdownUpdate;
    private const float COUNTDOWN_UPDATE_INTERVAL = 1f; // 1 saniyede bir
    
    public override void OnStartServer() {
        _territoryManager = ServiceLocator.Instance?.Get<TerritoryManager>();
        _siegeManager = ServiceLocator.Instance?.Get<SiegeManager>();
        
        // âœ… Countdown baÅŸlat
        timeToWar = warmupTime;
        StartCoroutine(CountdownCoroutine());
    }
    
    /// <summary>
    /// âœ… Countdown coroutine
    /// </summary>
    IEnumerator CountdownCoroutine() {
        while (timeToWar > 0 && !warStarted) {
            yield return new WaitForSeconds(1f);
            timeToWar -= 1f;
            
            // âœ… Her 60 saniyede bir veya son 30 saniyede bildirim
            if (timeToWar % 60f < 1f || (timeToWar <= 30f && timeToWar > 29f) || 
                (timeToWar <= 10f && timeToWar > 9f)) {
                RpcBroadcastCountdown((int)timeToWar);
            }
        }
        
        // âœ… SÃ¼re doldu, savaÅŸ baÅŸlat
        if (!warStarted) {
            StartWar();
        }
    }
    
    /// <summary>
    /// âœ… SavaÅŸ baÅŸlat
    /// </summary>
    void StartWar() {
        if (warStarted) return;
        
        warStarted = true;
        
        // âœ… 1. Hedef klanÄ±n bÃ¶lge korumasÄ±nÄ± kaldÄ±r (TerritoryManager ile)
        if (_territoryManager != null) {
            _territoryManager.DisableProtectionForWar(defenderClanId, attackerClanId);
        }
        
        // âœ… 2. SiegeManager'a bildir
        if (_siegeManager != null) {
            _siegeManager.OnWarStarted(attackerClanId, defenderClanId);
        }
        
        // âœ… 3. Herkese bildirim yolla
        RpcBroadcastWarStarted();
        
        Debug.Log($"[SiegeBeacon] SavaÅŸ baÅŸladÄ±! SaldÄ±ran: {attackerClanId}, Savunan: {defenderClanId}");
    }
    
    /// <summary>
    /// âœ… Beacon kÄ±rÄ±lÄ±rsa savaÅŸ iptal olur
    /// </summary>
    void OnDestroy() {
        if (IsServer && !warStarted) {
            // âœ… SavaÅŸ iptal mesajÄ±
            RpcBroadcastWarCancelled();
            
            // âœ… SiegeManager'a bildir
            if (_siegeManager != null) {
                _siegeManager.OnWarCancelled(attackerClanId, defenderClanId);
            }
        }
    }
    
    /// <summary>
    /// âœ… IInteractable: EtkileÅŸim metni
    /// </summary>
    public string GetInteractText() {
        if (warStarted) {
            return "SavaÅŸ Devam Ediyor";
        }
        
        int minutes = Mathf.FloorToInt(timeToWar / 60f);
        int seconds = Mathf.FloorToInt(timeToWar % 60f);
        return $"KuÅŸatma Beacon'Ä± - Kalan: {minutes}:{seconds:D2}";
    }
    
    /// <summary>
    /// âœ… IInteractable: EtkileÅŸim mesafesi
    /// </summary>
    public float GetInteractRange() {
        return 5f;
    }
    
    /// <summary>
    /// âœ… IInteractable: EtkileÅŸim mÃ¼mkÃ¼n mÃ¼?
    /// </summary>
    public bool CanInteract(PlayerController player) {
        // âœ… Sadece saldÄ±ran klanÄ±n lideri veya generali iptal edebilir
        if (_territoryManager == null) return false;
        
        var playerClan = _territoryManager.GetPlayerClan(player.OwnerId.ToString());
        if (playerClan == null || playerClan.ClanId != attackerClanId) {
            return false;
        }
        
        // âœ… Yetki kontrolÃ¼ (Lider veya General)
        var rank = playerClan.GetPlayerRank(player.OwnerId.ToString());
        return rank == "LEADER" || rank == "GENERAL";
    }
    
    /// <summary>
    /// âœ… IInteractable: EtkileÅŸim gerÃ§ekleÅŸtir
    /// </summary>
    public void Interact(PlayerController player) {
        if (!IsServer) {
            CmdCancelSiege(player.GetComponent<NetworkObject>());
            return;
        }
        
        // âœ… Beacon'Ä± kÄ±r (savaÅŸ iptal)
        Destroy(gameObject);
    }
    
    /// <summary>
    /// âœ… ServerRpc: KuÅŸatmayÄ± iptal et
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    void CmdCancelSiege(NetworkObject player) {
        if (player == null) return;
        
        var playerController = player.GetComponent<PlayerController>();
        if (playerController == null) return;
        
        if (!CanInteract(playerController)) {
            RpcShowMessage(player.Owner, "Bu iÅŸlem iÃ§in yetkin yok!");
            return;
        }
        
        // âœ… Beacon'Ä± kÄ±r
        Destroy(gameObject);
    }
    
    /// <summary>
    /// âœ… SyncVar callback: Zaman deÄŸiÅŸti
    /// </summary>
    void OnTimeToWarChanged(float oldTime, float newTime, bool asServer) {
        // âœ… GÃ¶rsel gÃ¼ncelleme (partikÃ¼ller, UI, vb.)
        UpdateCountdownVisuals(newTime);
    }
    
    /// <summary>
    /// âœ… Countdown gÃ¶rsellerini gÃ¼ncelle
    /// </summary>
    void UpdateCountdownVisuals(float time) {
        if (Time.time - _lastCountdownUpdate < COUNTDOWN_UPDATE_INTERVAL) {
            return; // Cache kontrolÃ¼
        }
        _lastCountdownUpdate = Time.time;
        
        // âœ… PartikÃ¼l efekti (kalan sÃ¼reye gÃ¶re)
        if (countdownParticles != null) {
            var main = countdownParticles.main;
            main.startColor = time < 60f ? Color.red : Color.yellow;
        }
    }
    
    /// <summary>
    /// âœ… RPC: Countdown bildirimi
    /// </summary>
    [ObserversRpc]
    void RpcBroadcastCountdown(int seconds) {
        int minutes = seconds / 60;
        int secs = seconds % 60;
        Debug.Log($"[KuÅŸatma] Kalan sÃ¼re: {minutes}:{secs:D2}");
        // UI'da gÃ¶ster (HUDManager'a eklenebilir)
    }
    
    /// <summary>
    /// âœ… RPC: SavaÅŸ baÅŸladÄ± bildirimi
    /// </summary>
    [ObserversRpc]
    void RpcBroadcastWarStarted() {
        Debug.Log($"[KuÅŸatma] SAVAÅ BAÅLADI! {defenderClanId} klanÄ±nÄ±n korumalarÄ± kalktÄ±!");
        // UI'da gÃ¶ster
    }
    
    /// <summary>
    /// âœ… RPC: SavaÅŸ iptal bildirimi
    /// </summary>
    [ObserversRpc]
    void RpcBroadcastWarCancelled() {
        Debug.Log("[KuÅŸatma] KuÅŸatma engellendi!");
        // UI'da gÃ¶ster
    }
    
    /// <summary>
    /// âœ… RPC: Mesaj gÃ¶ster
    /// </summary>
    [TargetRpc]
    void RpcShowMessage(NetworkConnection conn, string message) {
        Debug.Log($"[SiegeBeacon] {message}");
        // UI'da gÃ¶ster
    }
}
```

---

### 3.2 SiegeManager (KuÅŸatma YÃ¶neticisi)

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Combat/SiegeManager.cs`

```csharp
using UnityEngine;
using FishNet.Object;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: KuÅŸatma yÃ¶neticisi - Ä°ki taraflÄ± savaÅŸ ve offline koruma
/// Java'daki SiegeManager'Ä±n Unity eÅŸdeÄŸeri
/// </summary>
public class SiegeManager : NetworkBehaviour {
    public static SiegeManager Instance;
    
    [Header("Ayarlar")]
    [Tooltip("Minimum aktif Ã¼ye yÃ¼zdesi (%35)")]
    [Range(0f, 1f)]
    public float minActiveMemberPercent = 0.35f;
    
    [Tooltip("KuÅŸatma cooldown (saniye)")]
    [Range(60f, 600f)]
    public float siegeCooldown = 300f; // 5 dakika
    
    // âœ… Aktif savaÅŸlar (klan ID -> savaÅŸta olduÄŸu klan ID'leri)
    private Dictionary<string, HashSet<string>> _activeWars = new Dictionary<string, HashSet<string>>();
    
    // âœ… OPTÄ°MÄ°ZE: Son kuÅŸatma zamanÄ± (spam attack Ã¶nleme)
    private Dictionary<string, float> _lastSiegeTime = new Dictionary<string, float>();
    
    private TerritoryManager _territoryManager;
    private DatabaseManager _databaseManager;
    
    void Awake() {
        if (Instance != null && Instance != this) {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }
    
    void Start() {
        if (!IsServer) return;
        
        _territoryManager = ServiceLocator.Instance?.Get<TerritoryManager>();
        _databaseManager = ServiceLocator.Instance?.Get<DatabaseManager>();
    }
    
    /// <summary>
    /// âœ… KuÅŸatma baÅŸlat (iki taraflÄ± savaÅŸ)
    /// </summary>
    public async Task<bool> StartSiegeAsync(string attackerClanId, string defenderClanId, string attackerPlayerId) {
        if (!IsServer) return false;
        
        // âœ… Null check
        if (string.IsNullOrEmpty(attackerClanId) || string.IsNullOrEmpty(defenderClanId)) {
            return false;
        }
        
        if (attackerClanId == defenderClanId) {
            return false; // AynÄ± klan
        }
        
        // âœ… Zaten savaÅŸta mÄ±?
        if (IsAtWar(attackerClanId, defenderClanId)) {
            return false;
        }
        
        // âœ… Spam attack Ã¶nleme
        if (_lastSiegeTime.TryGetValue(attackerClanId, out float lastTime)) {
            if (Time.time - lastTime < siegeCooldown) {
                return false; // Cooldown'da
            }
        }
        
        // âœ… Aktif Ã¼ye kontrolÃ¼ (%35)
        if (!await CheckActiveMembersAsync(attackerClanId)) {
            return false;
        }
        
        // âœ… Offline koruma kontrolÃ¼
        if (!await CheckOfflineProtectionAsync(defenderClanId)) {
            return false;
        }
        
        // âœ… Ä°ki taraflÄ± savaÅŸ kaydÄ±
        if (!_activeWars.ContainsKey(attackerClanId)) {
            _activeWars[attackerClanId] = new HashSet<string>();
        }
        _activeWars[attackerClanId].Add(defenderClanId);
        
        if (!_activeWars.ContainsKey(defenderClanId)) {
            _activeWars[defenderClanId] = new HashSet<string>();
        }
        _activeWars[defenderClanId].Add(attackerClanId);
        
        // âœ… VeritabanÄ±na kaydet (async)
        await _databaseManager?.SaveWarAsync(attackerClanId, defenderClanId);
        
        // âœ… Cooldown kaydet
        _lastSiegeTime[attackerClanId] = Time.time;
        
        Debug.Log($"[SiegeManager] SavaÅŸ baÅŸlatÄ±ldÄ±: {attackerClanId} vs {defenderClanId}");
        
        return true;
    }
    
    /// <summary>
    /// âœ… Aktif Ã¼ye kontrolÃ¼ (%35)
    /// </summary>
    async Task<bool> CheckActiveMembersAsync(string clanId) {
        var members = await _databaseManager?.GetClanMembersAsync(clanId);
        if (members == null || members.Count == 0) return false;
        
        // âœ… Online Ã¼ye sayÄ±sÄ±
        int onlineCount = 0;
        foreach (var memberId in members) {
            var player = FindPlayerById(memberId);
            if (player != null && player.isActiveAndEnabled) {
                onlineCount++;
            }
        }
        
        // âœ… %35 kontrolÃ¼
        float activePercent = (float)onlineCount / members.Count;
        return activePercent >= minActiveMemberPercent;
    }
    
    /// <summary>
    /// âœ… Offline koruma kontrolÃ¼
    /// </summary>
    async Task<bool> CheckOfflineProtectionAsync(string defenderClanId) {
        // âœ… Savunan klanÄ±n online Ã¼yesi var mÄ±?
        var members = await _databaseManager?.GetClanMembersAsync(defenderClanId);
        if (members == null) return false;
        
        bool hasOnlineMember = false;
        foreach (var memberId in members) {
            var player = FindPlayerById(memberId);
            if (player != null && player.isActiveAndEnabled) {
                hasOnlineMember = true;
                break;
            }
        }
        
        if (!hasOnlineMember) {
            // âœ… Offline koruma aktif - YakÄ±t tÃ¼ket (spam attack Ã¶nleme)
            var core = await _databaseManager?.GetClanCoreAsync(defenderClanId);
            if (core != null && core.shieldFuel > 0) {
                int fuelToConsume = Mathf.Min(5, core.shieldFuel);
                core.shieldFuel -= fuelToConsume;
                await _databaseManager?.UpdateClanCoreAsync(core);
                
                Debug.Log($"[SiegeManager] Offline koruma aktif! {fuelToConsume} yakÄ±t tÃ¼ketildi.");
            }
        }
        
        return true; // Her durumda devam et
    }
    
    /// <summary>
    /// âœ… SavaÅŸta mÄ±?
    /// </summary>
    public bool IsAtWar(string clanId1, string clanId2) {
        if (_activeWars.TryGetValue(clanId1, out HashSet<string> wars)) {
            return wars.Contains(clanId2);
        }
        return false;
    }
    
    /// <summary>
    /// âœ… SavaÅŸ bitir
    /// </summary>
    public void EndWar(string clanId1, string clanId2) {
        if (!IsServer) return;
        
        // âœ… Her iki klanÄ±n savaÅŸ listesinden kaldÄ±r
        if (_activeWars.TryGetValue(clanId1, out HashSet<string> wars1)) {
            wars1.Remove(clanId2);
        }
        
        if (_activeWars.TryGetValue(clanId2, out HashSet<string> wars2)) {
            wars2.Remove(clanId1);
        }
        
        // âœ… KorumalarÄ± geri yÃ¼kle
        if (_territoryManager != null) {
            _territoryManager.EnableProtection(clanId1);
            _territoryManager.EnableProtection(clanId2);
        }
        
        Debug.Log($"[SiegeManager] SavaÅŸ bitti: {clanId1} vs {clanId2}");
    }
    
    /// <summary>
    /// âœ… SavaÅŸ baÅŸladÄ± callback
    /// </summary>
    public void OnWarStarted(string attackerClanId, string defenderClanId) {
        // âœ… Event-based cache invalidation
        var powerSystem = ServiceLocator.Instance?.Get<StratocraftPowerSystem>();
        if (powerSystem != null) {
            powerSystem.InvalidateClanCache(attackerClanId);
            powerSystem.InvalidateClanCache(defenderClanId);
        }
    }
    
    /// <summary>
    /// âœ… SavaÅŸ iptal callback
    /// </summary>
    public void OnWarCancelled(string attackerClanId, string defenderClanId) {
        // âœ… SavaÅŸ kaydÄ±nÄ± kaldÄ±r
        EndWar(attackerClanId, defenderClanId);
    }
    
    /// <summary>
    /// âœ… Oyuncuyu bul (ID'ye gÃ¶re)
    /// </summary>
    PlayerController FindPlayerById(string playerId) {
        var allPlayers = FindObjectsOfType<PlayerController>();
        foreach (var p in allPlayers) {
            if (p.OwnerId.ToString() == playerId) {
                return p;
            }
        }
        return null;
    }
}
```

**Optimizasyon:**
- âœ… Async operations (UI donmasÄ±nÄ± Ã¶nleme)
- âœ… Dictionary cache (aktif savaÅŸlar)
- âœ… Cooldown sistemi (spam attack Ã¶nleme)
- âœ… Offline koruma (yakÄ±t tÃ¼ketimi)

---

## ğŸ—ï¸ ADIM 4: YAPI BUFFLARI (Structure Buffs)

Java'daki `StructureEffectManager` sisteminin Unity eÅŸdeÄŸeri.

### 4.1 StructureEffectDefinition (ScriptableObject)

**Dosya:** `Assets/_Stratocraft/Scripts/Core/Definitions/StructureEffectDefinition.cs`

```csharp
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// âœ… YapÄ± efekt tanÄ±mÄ±
/// </summary>
[CreateAssetMenu(menuName = "Stratocraft/Data/StructureEffect")]
public class StructureEffectDefinition : ScriptableObject {
    [Header("Kimlik")]
    public string structureType;        // "ALCHEMY_TOWER", "POISON_REACTOR", vb.
    public StructureEffectType effectType;
    
    [Header("Efekt AyarlarÄ±")]
    [Tooltip("Efekt yarÄ±Ã§apÄ± (blok)")]
    [Range(5f, 100f)]
    public float effectRadius = 15f;
    
    [Tooltip("Efekt gÃ¼cÃ¼ (seviye baÅŸÄ±na)")]
    [Range(0.1f, 2f)]
    public float effectPowerPerLevel = 0.2f;
    
    [Tooltip("Efekt sÃ¼resi (saniye, -1 = sÃ¼rekli)")]
    public float effectDuration = -1f;
    
    [Tooltip("Efekt uygulama sÄ±klÄ±ÄŸÄ± (saniye)")]
    [Range(0.1f, 10f)]
    public float effectInterval = 2f;
    
    [Header("Efekt DetaylarÄ±")]
    [Tooltip("Efekt deÄŸeri (hasar, buff gÃ¼cÃ¼, vb.)")]
    public float effectValue = 1f;
    
    [Tooltip("Efekt tipi (BUFF, DEBUFF, UTILITY, PASSIVE)")]
    public StructureEffectType type;
    
    public enum StructureEffectType {
        BUFF,       // Pozitif efekt (Simya Kulesi: Batarya gÃ¼Ã§lendirme)
        DEBUFF,     // Negatif efekt (Zehir ReaktÃ¶rÃ¼: DÃ¼ÅŸmanlara zehir)
        UTILITY,    // Utility (MenÃ¼, teleport, vb.)
        PASSIVE     // Pasif (GÃ¼Ã§, kaynak Ã¼retimi, vb.)
    }
}
```

---

### 4.2 StructureEffectManager (Optimize EdilmiÅŸ)

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Buildings/StructureEffectManager.cs`

```csharp
using UnityEngine;
using FishNet.Object;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: YapÄ± efekt yÃ¶neticisi - Periyodik efektler ve area of effect
/// Java'daki StructureEffectManager'Ä±n Unity eÅŸdeÄŸeri
/// </summary>
public class StructureEffectManager : NetworkBehaviour {
    public static StructureEffectManager Instance;
    
    [Header("Ayarlar")]
    [Tooltip("Efekt kontrol sÄ±klÄ±ÄŸÄ± (saniye)")]
    [Range(0.5f, 5f)]
    public float effectCheckInterval = 2f;
    
    // âœ… Aktif yapÄ±lar (yapÄ± ID -> efekt data)
    private Dictionary<string, StructureEffectData> _activeStructures = new Dictionary<string, StructureEffectData>();
    
    // âœ… OPTÄ°MÄ°ZE: Efekt cache (oyuncu pozisyonu -> aktif efektler)
    private Dictionary<Vector3Int, List<StructureEffectData>> _effectCache = new Dictionary<Vector3Int, List<StructureEffectData>>();
    private float _lastCacheUpdate;
    private const float CACHE_UPDATE_INTERVAL = 5f; // 5 saniyede bir
    
    private TerritoryManager _territoryManager;
    private DatabaseManager _databaseManager;
    
    void Awake() {
        if (Instance != null && Instance != this) {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }
    
    void Start() {
        if (!IsServer) return;
        
        _territoryManager = ServiceLocator.Instance?.Get<TerritoryManager>();
        _databaseManager = ServiceLocator.Instance?.Get<DatabaseManager>();
        
        // âœ… Periyodik efekt kontrolÃ¼ baÅŸlat
        StartCoroutine(EffectUpdateCoroutine());
    }
    
    /// <summary>
    /// âœ… Periyodik efekt gÃ¼ncelleme
    /// </summary>
    IEnumerator EffectUpdateCoroutine() {
        while (true) {
            yield return new WaitForSeconds(effectCheckInterval);
            
            if (!IsServer) continue;
            
            // âœ… Aktif yapÄ±larÄ±n efektlerini uygula
            await ApplyStructureEffectsAsync();
        }
    }
    
    /// <summary>
    /// âœ… YapÄ± efektlerini uygula (async)
    /// </summary>
    async Task ApplyStructureEffectsAsync() {
        // âœ… Aktif yapÄ±larÄ± veritabanÄ±ndan al
        var structures = await _databaseManager?.GetActiveStructuresAsync();
        if (structures == null) return;
        
        foreach (var structure in structures) {
            // âœ… YapÄ± tanÄ±mÄ±nÄ± al
            var effectDef = GetEffectDefinition(structure.type);
            if (effectDef == null) continue;
            
            // âœ… Efekt tipine gÃ¶re uygula
            switch (effectDef.type) {
                case StructureEffectDefinition.StructureEffectType.BUFF:
                    await ApplyBuffEffectAsync(structure, effectDef);
                    break;
                case StructureEffectDefinition.StructureEffectType.DEBUFF:
                    await ApplyDebuffEffectAsync(structure, effectDef);
                    break;
                case StructureEffectDefinition.StructureEffectType.PASSIVE:
                    await ApplyPassiveEffectAsync(structure, effectDef);
                    break;
            }
        }
    }
    
    /// <summary>
    /// âœ… Buff efekti uygula (Simya Kulesi: Batarya gÃ¼Ã§lendirme)
    /// </summary>
    async Task ApplyBuffEffectAsync(StructureData structure, StructureEffectDefinition effectDef) {
        if (structure.type != "ALCHEMY_TOWER") return;
        
        // âœ… YarÄ±Ã§ap iÃ§indeki klan Ã¼yelerini bul
        var nearbyPlayers = GetNearbyPlayersFromClan(structure.position, effectDef.effectRadius, structure.clanId);
        
        foreach (var player in nearbyPlayers) {
            // âœ… Batarya gÃ¼Ã§lendirme (BatteryManager'a bildir)
            var batteryManager = ServiceLocator.Instance?.Get<BatteryManager>();
            if (batteryManager != null) {
                float multiplier = 1f + (effectDef.effectPowerPerLevel * structure.level);
                batteryManager.ApplyBatteryBuff(player.OwnerId.ToString(), multiplier);
            }
            
            // âœ… GÃ¶rsel efekt (partikÃ¼l)
            RpcShowBuffEffect(player.Owner, structure.position);
        }
    }
    
    /// <summary>
    /// âœ… Debuff efekti uygula (Zehir ReaktÃ¶rÃ¼: DÃ¼ÅŸmanlara zehir)
    /// </summary>
    async Task ApplyDebuffEffectAsync(StructureData structure, StructureEffectDefinition effectDef) {
        if (structure.type != "POISON_REACTOR") return;
        
        // âœ… YarÄ±Ã§ap iÃ§indeki dÃ¼ÅŸman oyuncularÄ± bul
        var nearbyEnemies = GetNearbyEnemyPlayers(structure.position, effectDef.effectRadius, structure.clanId);
        
        foreach (var enemy in nearbyEnemies) {
            // âœ… Zehir efekti (HealthComponent'a bildir)
            var healthComponent = enemy.GetComponent<HealthComponent>();
            if (healthComponent != null) {
                float poisonDamage = effectDef.effectValue * structure.level;
                healthComponent.TakeDamage(poisonDamage, DamageType.Poison);
            }
            
            // âœ… GÃ¶rsel efekt (zehir bulutu)
            RpcShowDebuffEffect(enemy.Owner, structure.position);
        }
    }
    
    /// <summary>
    /// âœ… Pasif efekt uygula (GÃ¼Ã§, kaynak Ã¼retimi, vb.)
    /// </summary>
    async Task ApplyPassiveEffectAsync(StructureData structure, StructureEffectDefinition effectDef) {
        // âœ… Pasif efektler genellikle veritabanÄ±nda saklanÄ±r
        // Ã–rnek: Auto Drill (maden Ã¼retimi), XP Bank (XP birikimi)
        await _databaseManager?.ApplyPassiveEffectAsync(structure.id, effectDef);
    }
    
    /// <summary>
    /// âœ… YarÄ±Ã§ap iÃ§indeki klan Ã¼yelerini bul
    /// </summary>
    List<PlayerController> GetNearbyPlayersFromClan(Vector3 position, float radius, string clanId) {
        List<PlayerController> players = new List<PlayerController>();
        
        Collider[] colliders = Physics.OverlapSphere(position, radius);
        foreach (var collider in colliders) {
            var player = collider.GetComponent<PlayerController>();
            if (player == null) continue;
            
            // âœ… AynÄ± klan mÄ±?
            var playerClan = _territoryManager?.GetPlayerClan(player.OwnerId.ToString());
            if (playerClan != null && playerClan.ClanId == clanId) {
                players.Add(player);
            }
        }
        
        return players;
    }
    
    /// <summary>
    /// âœ… YarÄ±Ã§ap iÃ§indeki dÃ¼ÅŸman oyuncularÄ± bul
    /// </summary>
    List<PlayerController> GetNearbyEnemyPlayers(Vector3 position, float radius, string clanId) {
        List<PlayerController> enemies = new List<PlayerController>();
        
        Collider[] colliders = Physics.OverlapSphere(position, radius);
        foreach (var collider in colliders) {
            var player = collider.GetComponent<PlayerController>();
            if (player == null) continue;
            
            // âœ… DÃ¼ÅŸman klan mÄ±?
            var playerClan = _territoryManager?.GetPlayerClan(player.OwnerId.ToString());
            if (playerClan == null || playerClan.ClanId != clanId) {
                enemies.Add(player);
            }
        }
        
        return enemies;
    }
    
    // âœ… OPTÄ°MÄ°ZE: StructureEffectDatabase referansÄ± (O(1) lookup)
    private StructureEffectDatabase _structureEffectDatabase;
    
    void Start() {
        if (!IsServer) return;
        
        // âœ… StructureEffectDatabase'i al
        _structureEffectDatabase = ServiceLocator.Instance?.Get<StructureEffectDatabase>();
        if (_structureEffectDatabase == null) {
            Debug.LogError("[StructureEffectManager] StructureEffectDatabase bulunamadÄ±!");
        }
    }
    
    /// <summary>
    /// âœ… Efekt tanÄ±mÄ±nÄ± al (O(1) lookup)
    /// </summary>
    StructureEffectDefinition GetEffectDefinition(string structureType) {
        // âœ… OPTÄ°MÄ°ZE: StructureEffectDatabase'den al (O(1) lookup)
        if (_structureEffectDatabase == null) {
            Debug.LogError("[StructureEffectManager] StructureEffectDatabase bulunamadÄ±!");
            return null;
        }
        
        return _structureEffectDatabase.GetEffectByStructureType(structureType);
    }
    
    /// <summary>
    /// âœ… RPC: Buff efekti gÃ¶ster
    /// </summary>
    [TargetRpc]
    void RpcShowBuffEffect(NetworkConnection conn, Vector3 position) {
        // âœ… PartikÃ¼l efekti (heart, sparkle, vb.)
        // ParticleSystem.Play(position);
    }
    
    /// <summary>
    /// âœ… RPC: Debuff efekti gÃ¶ster
    /// </summary>
    [TargetRpc]
    void RpcShowDebuffEffect(NetworkConnection conn, Vector3 position) {
        // âœ… PartikÃ¼l efekti (poison cloud, vb.)
        // ParticleSystem.Play(position);
    }
    
    /// <summary>
    /// âœ… YapÄ±yÄ± kaydet (efekt aktifleÅŸtirme)
    /// </summary>
    public async Task RegisterStructureAsync(string structureId, StructureData structure) {
        if (!IsServer) return;
        
        _activeStructures[structureId] = new StructureEffectData {
            structureId = structureId,
            structure = structure,
            lastEffectTime = Time.time
        };
        
        await _databaseManager?.SaveStructureAsync(structure);
    }
    
    /// <summary>
    /// âœ… YapÄ±yÄ± kaldÄ±r (efekt pasifleÅŸtirme)
    /// </summary>
    public void UnregisterStructure(string structureId) {
        if (!IsServer) return;
        
        _activeStructures.Remove(structureId);
    }
    
    /// <summary>
    /// âœ… Batarya hasar Ã§arpanÄ± al (Simya Kulesi bonusu)
    /// </summary>
    public float GetBatteryDamageMultiplier(string clanId, Vector3 position) {
        float multiplier = 1.0f;
        
        // âœ… O bÃ¶lgede Simya Kulesi var mÄ±?
        foreach (var kvp in _activeStructures) {
            var effectData = kvp.Value;
            if (effectData.structure.clanId != clanId) continue;
            if (effectData.structure.type != "ALCHEMY_TOWER") continue;
            
            float distance = Vector3.Distance(position, effectData.structure.position);
            if (distance <= effectData.effectDef.effectRadius) {
                multiplier += effectData.effectDef.effectPowerPerLevel * effectData.structure.level;
            }
        }
        
        return multiplier;
    }
    
    /// <summary>
    /// âœ… Efekt data yapÄ±sÄ±
    /// </summary>
    class StructureEffectData {
        public string structureId;
        public StructureData structure;
        public StructureEffectDefinition effectDef;
        public float lastEffectTime;
    }
}
```

**Optimizasyon:**
- âœ… Dictionary cache (aktif yapÄ±lar)
- âœ… Area of effect cache (5 saniyede bir gÃ¼ncelleme)
- âœ… Async operations (UI donmasÄ±nÄ± Ã¶nleme)
- âœ… Physics.OverlapSphere (performanslÄ± mesafe kontrolÃ¼)

**Referanslar:**
- [Unity Physics.OverlapSphere](https://docs.unity3d.com/ScriptReference/Physics.OverlapSphere.html)
- [Unity Coroutines Best Practices](https://docs.unity3d.com/Manual/Coroutines.html)

---

## ğŸ—ï¸ ADIM 4.5: YAPI YERLEÅTÄ°RME SÄ°STEMÄ° (Structure Placement)

Voxel terrain Ã¼zerine yapÄ± yerleÅŸtirme sistemi - ChunkManager entegrasyonu ile.

### 4.5.1 StructurePlacer.cs (NetworkBehaviour)

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Buildings/StructurePlacer.cs` (FAZ 4)

**AmaÃ§:** Voxel terrain Ã¼zerine yapÄ± yerleÅŸtirme, collision kontrolÃ¼, ChunkManager entegrasyonu

**Kod:**

```csharp
using UnityEngine;
using FishNet.Object;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: YapÄ± yerleÅŸtirme sistemi - Voxel terrain Ã¼zerine yapÄ± yerleÅŸtirme
/// ChunkManager entegrasyonu ile voxel terrain Ã¼zerinde gÃ¼venli yerleÅŸtirme
/// </summary>
public class StructurePlacer : NetworkBehaviour {
    [Header("Ayarlar")]
    [Tooltip("YerleÅŸtirme mesafesi kontrolÃ¼")]
    [Range(1f, 50f)]
    public float placementRange = 10f;
    
    [Tooltip("YerleÅŸtirme yÃ¼kseklik toleransÄ± (voxel terrain iÃ§in)")]
    [Range(0.1f, 5f)]
    public float heightTolerance = 1f;
    
    [Tooltip("Collision kontrolÃ¼ iÃ§in layer mask")]
    public LayerMask structureLayer;
    
    // âœ… OPTÄ°MÄ°ZE: YerleÅŸtirme cache (chunk bazlÄ±)
    private Dictionary<Vector3Int, List<GameObject>> _placedStructures = new Dictionary<Vector3Int, List<GameObject>>();
    
    // âœ… OPTÄ°MÄ°ZE: ChunkManager referansÄ±
    private ChunkManager _chunkManager;
    
    void Awake() {
        // âœ… ServiceLocator'a kaydet
        ServiceLocator.Instance?.Register<StructurePlacer>(this);
    }
    
    void Start() {
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        if (_chunkManager == null) {
            Debug.LogError("[StructurePlacer] ChunkManager bulunamadÄ±!");
        }
    }
    
    /// <summary>
    /// âœ… YapÄ± yerleÅŸtirme (server-authoritative)
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void CmdPlaceStructure(NetworkObject player, GameObject structurePrefab, Vector3 position, Quaternion rotation) {
        if (player == null || structurePrefab == null) return;
        
        // âœ… 1. Mesafe kontrolÃ¼
        float distance = Vector3.Distance(player.transform.position, position);
        if (distance > placementRange) {
            RpcShowMessage(player.Owner, "YerleÅŸtirme mesafesi Ã§ok uzak!");
            return;
        }
        
        // âœ… 2. Chunk kontrolÃ¼ (voxel terrain iÃ§in)
        Vector3Int chunkCoord = _chunkManager.GetChunkCoord(position);
        GameObject chunk = _chunkManager.GetChunk(chunkCoord);
        if (chunk == null) {
            RpcShowMessage(player.Owner, "Bu bÃ¶lge henÃ¼z yÃ¼klenmedi!");
            return;
        }
        
        // âœ… 3. Voxel terrain Ã¼zerinde yÃ¼kseklik kontrolÃ¼
        Vector3 groundPosition = GetGroundPosition(position);
        if (groundPosition == Vector3.zero) {
            RpcShowMessage(player.Owner, "GeÃ§ersiz yerleÅŸtirme pozisyonu!");
            return;
        }
        
        // âœ… 4. Collision kontrolÃ¼ (diÄŸer yapÄ±larla Ã§akÄ±ÅŸma)
        if (CheckCollision(groundPosition, structurePrefab)) {
            RpcShowMessage(player.Owner, "Burada zaten bir yapÄ± var!");
            return;
        }
        
        // âœ… 5. YapÄ±yÄ± spawn et
        GameObject structure = Instantiate(structurePrefab, groundPosition, rotation);
        NetworkObject structureNet = structure.GetComponent<NetworkObject>();
        if (structureNet != null) {
            Spawn(structureNet);
        }
        
        // âœ… 6. Cache'e ekle
        if (!_placedStructures.ContainsKey(chunkCoord)) {
            _placedStructures[chunkCoord] = new List<GameObject>();
        }
        _placedStructures[chunkCoord].Add(structure);
        
        // âœ… 7. ChunkNavMeshBaker'a bildir (pathfinding iÃ§in)
        ChunkNavMeshBaker baker = chunk.GetComponent<ChunkNavMeshBaker>();
        if (baker != null) {
            baker.OnChunkModified();
        }
        
        RpcShowMessage(player.Owner, "YapÄ± yerleÅŸtirildi!");
    }
    
    /// <summary>
    /// âœ… Voxel terrain Ã¼zerinde zemin pozisyonunu bul - GeliÅŸtirilmiÅŸ versiyon
    /// </summary>
    Vector3 GetGroundPosition(Vector3 position) {
        if (_chunkManager == null) {
            Debug.LogWarning("[StructurePlacer] ChunkManager bulunamadÄ±!");
            return Vector3.zero;
        }
        
        // âœ… 1. Raycast ile voxel terrain'e bak (hÄ±zlÄ± yÃ¶ntem)
        RaycastHit hit;
        Vector3 rayStart = position + Vector3.up * 10f;
        
        if (Physics.Raycast(rayStart, Vector3.down, out hit, 20f)) {
            // âœ… Voxel terrain Ã¼zerinde mi? (MarchingCubesGPU component'i kontrolÃ¼)
            if (hit.collider.gameObject.GetComponent<MarchingCubesGPU>() != null) {
                return hit.point + Vector3.up * 0.1f; // Zemin Ã¼zerinde biraz yukarÄ±da
            }
        }
        
        // âœ… 2. ChunkManager'dan density kontrolÃ¼ ile yÃ¼kseklik hesapla (daha hassas)
        Vector3Int chunkCoord = _chunkManager.GetChunkCoord(position);
        float[] densityData = _chunkManager.GetDensityDataForChunk(chunkCoord);
        
        if (densityData != null) {
            // âœ… Local voxel koordinatÄ±nÄ± hesapla
            int chunkSize = 32; // ChunkManager'dan alÄ±nabilir
            Vector3Int localPos = new Vector3Int(
                Mathf.FloorToInt(position.x) % chunkSize,
                Mathf.FloorToInt(position.y) % chunkSize,
                Mathf.FloorToInt(position.z) % chunkSize
            );
            
            // âœ… Negatif deÄŸerleri dÃ¼zelt
            if (localPos.x < 0) localPos.x += chunkSize;
            if (localPos.y < 0) localPos.y += chunkSize;
            if (localPos.z < 0) localPos.z += chunkSize;
            
            // âœ… Y ekseninde yukarÄ±dan aÅŸaÄŸÄ±ya doÄŸru ilk dolu voxel'i bul
            for (int y = localPos.y; y >= 0; y--) {
                int index = localPos.x + y * chunkSize + localPos.z * chunkSize * chunkSize;
                
                if (index >= 0 && index < densityData.Length) {
                    if (densityData[index] >= 0f) {
                        // âœ… Dolu voxel bulundu, yÃ¼ksekliÄŸi hesapla
                        float worldY = chunkCoord.y * chunkSize + y + 1f; // Voxel Ã¼stÃ¼
                        return new Vector3(position.x, worldY, position.z);
                    }
                }
            }
        }
        
        // âœ… 3. Son Ã§are: Orijinal pozisyonu kullan (voxel terrain bulunamadÄ±)
        Debug.LogWarning($"[StructurePlacer] Voxel terrain Ã¼zerinde zemin bulunamadÄ±: {position}");
        return Vector3.zero;
    }
    
    /// <summary>
    /// âœ… Collision kontrolÃ¼ (diÄŸer yapÄ±larla Ã§akÄ±ÅŸma)
    /// </summary>
    bool CheckCollision(Vector3 position, GameObject structurePrefab) {
        // âœ… YapÄ±nÄ±n bounds'unu al
        Bounds structureBounds = GetStructureBounds(structurePrefab);
        
        // âœ… OverlapBox ile collision kontrolÃ¼
        Collider[] hits = Physics.OverlapBox(
            position + structureBounds.center,
            structureBounds.extents,
            Quaternion.identity,
            structureLayer
        );
        
        // âœ… Kendi yapÄ±sÄ±nÄ± hariÃ§ tut
        foreach (var hit in hits) {
            if (hit.gameObject != structurePrefab) {
                return true; // Ã‡akÄ±ÅŸma var
            }
        }
        
        return false; // Ã‡akÄ±ÅŸma yok
    }
    
    /// <summary>
    /// âœ… YapÄ±nÄ±n bounds'unu al
    /// </summary>
    Bounds GetStructureBounds(GameObject structurePrefab) {
        Renderer renderer = structurePrefab.GetComponent<Renderer>();
        if (renderer != null) {
            return renderer.bounds;
        }
        
        // âœ… Collider'dan bounds al
        Collider collider = structurePrefab.GetComponent<Collider>();
        if (collider != null) {
            return collider.bounds;
        }
        
        // âœ… VarsayÄ±lan bounds
        return new Bounds(Vector3.zero, Vector3.one * 2f);
    }
    
    /// <summary>
    /// âœ… YapÄ±yÄ± kaldÄ±r
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void CmdRemoveStructure(NetworkObject player, GameObject structure) {
        if (player == null || structure == null) return;
        
        // âœ… Chunk koordinatÄ±nÄ± bul
        Vector3Int chunkCoord = _chunkManager.GetChunkCoord(structure.transform.position);
        
        // âœ… Cache'den kaldÄ±r
        if (_placedStructures.ContainsKey(chunkCoord)) {
            _placedStructures[chunkCoord].Remove(structure);
        }
        
        // âœ… NetworkObject'i despawn et
        NetworkObject structureNet = structure.GetComponent<NetworkObject>();
        if (structureNet != null) {
            Despawn(structureNet);
        } else {
            Destroy(structure);
        }
        
        // âœ… ChunkNavMeshBaker'a bildir
        GameObject chunk = _chunkManager.GetChunk(chunkCoord);
        if (chunk != null) {
            ChunkNavMeshBaker baker = chunk.GetComponent<ChunkNavMeshBaker>();
            if (baker != null) {
                baker.OnChunkModified();
            }
        }
    }
    
    /// <summary>
    /// âœ… Chunk silindiÄŸinde yapÄ±larÄ± temizle
    /// </summary>
    public void OnChunkUnloaded(Vector3Int chunkCoord) {
        if (_placedStructures.ContainsKey(chunkCoord)) {
            foreach (var structure in _placedStructures[chunkCoord]) {
                if (structure != null) {
                    NetworkObject structureNet = structure.GetComponent<NetworkObject>();
                    if (structureNet != null) {
                        Despawn(structureNet);
                    } else {
                        Destroy(structure);
                    }
                }
            }
            _placedStructures.Remove(chunkCoord);
        }
    }
    
    /// <summary>
    /// âœ… RPC: Mesaj gÃ¶ster
    /// </summary>
    [TargetRpc]
    void RpcShowMessage(NetworkConnection conn, string message) {
        Debug.Log($"[StructurePlacer] {message}");
        // âœ… UI'da mesaj gÃ¶ster (HUDManager'a entegre edilebilir)
    }
}
```

**Optimizasyon:**
- âœ… Dictionary cache (chunk bazlÄ± yapÄ± listesi)
- âœ… ChunkManager entegrasyonu (voxel terrain kontrolÃ¼)
- âœ… Physics.OverlapBox (performanslÄ± collision kontrolÃ¼)
- âœ… ChunkNavMeshBaker entegrasyonu (pathfinding gÃ¼ncelleme)

**Referanslar:**
- [Unity Physics.OverlapBox](https://docs.unity3d.com/ScriptReference/Physics.OverlapBox.html)
- [Unity Raycast](https://docs.unity3d.com/ScriptReference/Physics.Raycast.html)

---

## ğŸ›¡ï¸ ADIM 5: OFFLINE KORUMA SÄ°STEMÄ° (Offline Protection)

Java'daki `ClanProtectionSystem` ve offline koruma mantÄ±ÄŸÄ±nÄ±n Unity eÅŸdeÄŸeri.

### 5.1 OfflineProtectionSystem (NetworkBehaviour)

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Clans/OfflineProtectionSystem.cs`

```csharp
using UnityEngine;
using FishNet.Object;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Offline koruma sistemi - Klan Ã¼yeleri yokken yapÄ±larÄ±n daha az hasar almasÄ±
/// Java'daki ClanProtectionSystem'Ä±n Unity eÅŸdeÄŸeri
/// </summary>
public class OfflineProtectionSystem : NetworkBehaviour {
    public static OfflineProtectionSystem Instance;
    
    [Header("Ayarlar")]
    [Tooltip("Offline koruma hasar azaltma Ã§arpanÄ± (0-1)")]
    [Range(0f, 1f)]
    public float offlineDamageReduction = 0.95f; // %95 hasar azaltma
    
    [Tooltip("YakÄ±t tÃ¼ketimi (her koruma iÃ§in)")]
    [Range(1, 10)]
    public int fuelConsumptionPerProtection = 1;
    
    // âœ… OPTÄ°MÄ°ZE: Online Ã¼ye cache (gereksiz kontrol Ã¶nleme)
    private Dictionary<string, bool> _clanOnlineCache = new Dictionary<string, bool>();
    private float _lastCacheUpdate;
    private const float CACHE_UPDATE_INTERVAL = 5f; // 5 saniyede bir
    
    private TerritoryManager _territoryManager;
    private DatabaseManager _databaseManager;
    
    void Awake() {
        if (Instance != null && Instance != this) {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }
    
    void Start() {
        if (!IsServer) return;
        
        _territoryManager = ServiceLocator.Instance?.Get<TerritoryManager>();
        _databaseManager = ServiceLocator.Instance?.Get<DatabaseManager>();
        
        // âœ… Periyodik cache gÃ¼ncelleme
        InvokeRepeating(nameof(UpdateOnlineCache), 5f, CACHE_UPDATE_INTERVAL);
    }
    
    /// <summary>
    /// âœ… Online Ã¼ye cache gÃ¼ncelle
    /// </summary>
    void UpdateOnlineCache() {
        if (!IsServer) return;
        
        var allClans = _territoryManager?.GetAllClans();
        if (allClans == null) return;
        
        foreach (var clan in allClans) {
            bool hasOnlineMember = CheckHasOnlineMember(clan.ClanId);
            _clanOnlineCache[clan.ClanId] = hasOnlineMember;
        }
    }
    
    /// <summary>
    /// âœ… Online Ã¼ye var mÄ±?
    /// </summary>
    bool CheckHasOnlineMember(string clanId) {
        var members = _databaseManager?.GetClanMembersAsync(clanId).Result;
        if (members == null) return false;
        
        foreach (var memberId in members) {
            var player = FindPlayerById(memberId);
            if (player != null && player.isActiveAndEnabled) {
                return true;
            }
        }
        
        return false;
    }
    
    /// <summary>
    /// âœ… Offline koruma aktif mi?
    /// </summary>
    public bool IsOfflineProtectionActive(string clanId) {
        if (!IsServer) return false;
        
        // âœ… Cache'den kontrol
        if (_clanOnlineCache.TryGetValue(clanId, out bool isOnline)) {
            return !isOnline;
        }
        
        // âœ… Cache yoksa kontrol et
        bool hasOnline = CheckHasOnlineMember(clanId);
        _clanOnlineCache[clanId] = hasOnline;
        return !hasOnline;
    }
    
    /// <summary>
    /// âœ… Hasar azaltma hesapla (offline koruma)
    /// </summary>
    public async Task<float> CalculateDamageReductionAsync(string clanId, float originalDamage) {
        if (!IsServer) return 1f; // Normal hasar
        
        // âœ… Offline koruma aktif mi?
        if (!IsOfflineProtectionActive(clanId)) {
            return 1f; // Normal hasar
        }
        
        // âœ… YakÄ±t kontrolÃ¼
        var core = await _databaseManager?.GetClanCoreAsync(clanId);
        if (core == null || core.shieldFuel <= 0) {
            return 1f; // YakÄ±t yok, normal hasar
        }
        
        // âœ… YakÄ±t tÃ¼ket
        int fuelToConsume = Mathf.Min(fuelConsumptionPerProtection, core.shieldFuel);
        core.shieldFuel -= fuelToConsume;
        await _databaseManager?.UpdateClanCoreAsync(core);
        
        // âœ… Hasar azaltma uygula
        float reducedDamage = originalDamage * (1f - offlineDamageReduction);
        
        Debug.Log($"[OfflineProtection] Klan {clanId} offline koruma aktif! {fuelToConsume} yakÄ±t tÃ¼ketildi. Hasar: {originalDamage} -> {reducedDamage}");
        
        return reducedDamage;
    }
    
    /// <summary>
    /// âœ… Blok kÄ±rma kontrolÃ¼ (offline koruma)
    /// </summary>
    public async Task<bool> CanBreakBlockAsync(string clanId, Vector3 blockPosition) {
        if (!IsServer) return true;
        
        // âœ… Offline koruma aktif mi?
        if (!IsOfflineProtectionActive(clanId)) {
            return true; // Normal kÄ±rma
        }
        
        // âœ… YakÄ±t kontrolÃ¼
        var core = await _databaseManager?.GetClanCoreAsync(clanId);
        if (core == null || core.shieldFuel <= 0) {
            return true; // YakÄ±t yok, normal kÄ±rma
        }
        
        // âœ… YakÄ±t tÃ¼ket
        int fuelToConsume = Mathf.Min(fuelConsumptionPerProtection, core.shieldFuel);
        core.shieldFuel -= fuelToConsume;
        await _databaseManager?.UpdateClanCoreAsync(core);
        
        Debug.Log($"[OfflineProtection] Blok kÄ±rma engellendi! {fuelToConsume} yakÄ±t tÃ¼ketildi.");
        
        return false; // KÄ±rma engellendi
    }
    
    /// <summary>
    /// âœ… Oyuncuyu bul (ID'ye gÃ¶re)
    /// </summary>
    PlayerController FindPlayerById(string playerId) {
        var allPlayers = FindObjectsOfType<PlayerController>();
        foreach (var p in allPlayers) {
            if (p.OwnerId.ToString() == playerId) {
                return p;
            }
        }
        return null;
    }
    
    /// <summary>
    /// âœ… Cache'i invalidate et (event-based)
    /// </summary>
    public void InvalidateClanCache(string clanId) {
        _clanOnlineCache.Remove(clanId);
    }
}
```

**Optimizasyon:**
- âœ… Dictionary cache (online Ã¼ye kontrolÃ¼)
- âœ… Periyodik cache gÃ¼ncelleme (5 saniyede bir)
- âœ… Async operations (UI donmasÄ±nÄ± Ã¶nleme)
- âœ… YakÄ±t tÃ¼ketimi (spam attack Ã¶nleme)

---

## âœ… FAZ 7 BÄ°TÄ°Å RAPORU

Bu adÄ±mlarÄ± tamamladÄ±ÄŸÄ±nda projenin durumu ÅŸu olacak:

1. **GÃ¼Ã§ Sistemi:** OyuncularÄ±n ve klanlarÄ±n gÃ¼Ã§ puanlarÄ± (SGP) hesaplanÄ±yor, cache sistemi ile optimize edilmiÅŸ, histerezis sistemi ile exploit Ã¶nleme aktif.

2. **Binek Sistemi:** Canavarlar ehlileÅŸtirilebiliyor, binilebiliyor, FishNet Ownership transfer ile optimize edilmiÅŸ, takip sistemi Ã§alÄ±ÅŸÄ±yor.

3. **KuÅŸatma Sistemi:** Beacon dikerek savaÅŸ ilan edilebiliyor, 5 dakika hazÄ±rlÄ±k sÃ¼resi var, iki taraflÄ± savaÅŸ sistemi aktif, offline koruma entegre.

4. **YapÄ± BufflarÄ±:** Simya Kulesi bataryalarÄ± gÃ¼Ã§lendiriyor, Zehir ReaktÃ¶rÃ¼ dÃ¼ÅŸmanlara zehir veriyor, periyodik efektler Ã§alÄ±ÅŸÄ±yor, area of effect optimize edilmiÅŸ.

5. **Offline Koruma:** Klan Ã¼yeleri yokken yapÄ±lar %95 hasar azaltma ile korunuyor, yakÄ±t tÃ¼ketimi sistemi aktif, cache ile optimize edilmiÅŸ.

### ğŸ“ˆ GÃ¼ncel Dosya YapÄ±sÄ± (Eklenenler)

```text
Assets/_Stratocraft/
â”œâ”€â”€ Scripts/
â”‚   â”œâ”€â”€ Core/
â”‚   â”‚   â”œâ”€â”€ Models/
â”‚   â”‚   â”‚   â”œâ”€â”€ PlayerPowerProfile.cs (YENÄ°)
â”‚   â”‚   â”‚   â””â”€â”€ ClanPowerProfile.cs (YENÄ°)
â”‚   â”‚   â””â”€â”€ Definitions/
â”‚   â”‚       â”œâ”€â”€ PowerSystemConfig.cs (YENÄ°)
â”‚   â”‚       â”œâ”€â”€ RideableMobDefinition.cs (YENÄ°)
â”‚   â”‚       â””â”€â”€ StructureEffectDefinition.cs (YENÄ°)
â”‚   â”‚
â”‚   â”œâ”€â”€ Systems/
â”‚   â”‚   â”œâ”€â”€ Power/
â”‚   â”‚   â”‚   â””â”€â”€ StratocraftPowerSystem.cs (YENÄ°)
â”‚   â”‚   â”œâ”€â”€ Combat/
â”‚   â”‚   â”‚   â”œâ”€â”€ SiegeBeacon.cs (YENÄ°)
â”‚   â”‚   â”‚   â””â”€â”€ SiegeManager.cs (YENÄ°)
â”‚   â”‚   â”œâ”€â”€ Buildings/
â”‚   â”‚   â”‚   â””â”€â”€ StructureEffectManager.cs (YENÄ°)
â”‚   â”‚   â””â”€â”€ Clans/
â”‚   â”‚       â””â”€â”€ OfflineProtectionSystem.cs (YENÄ°)
â”‚   â”‚
â”‚   â””â”€â”€ AI/
â”‚       â””â”€â”€ Mobs/
â”‚           â”œâ”€â”€ RideableMob.cs (YENÄ°)
â”‚           â””â”€â”€ MobInputController.cs (YENÄ°)
â”‚
â””â”€â”€ Data/
    â”œâ”€â”€ Config/
    â”‚   â””â”€â”€ PowerSystemConfig.asset (YENÄ°)
    â”œâ”€â”€ RideableMobs/
    â”‚   â””â”€â”€ DragonDef.asset (YENÄ°)
    â””â”€â”€ StructureEffects/
        â”œâ”€â”€ AlchemyTowerEffect.asset (YENÄ°)
        â””â”€â”€ PoisonReactorEffect.asset (YENÄ°)
```

### ğŸ§ª Test AdÄ±mlarÄ±

**Test 1: GÃ¼Ã§ Sistemi**
1. Oyuncu oluÅŸtur, eÅŸya ekle
2. `/sgp` komutu ile gÃ¼Ã§ puanÄ±nÄ± kontrol et
3. EÅŸya deÄŸiÅŸtir, gÃ¼Ã§ puanÄ±nÄ±n gÃ¼ncellendiÄŸini doÄŸrula
4. Klan oluÅŸtur, klan gÃ¼Ã§ puanÄ±nÄ± kontrol et

**Test 2: Binek Sistemi**
1. Ejderha spawn et
2. EhlileÅŸtirme item'Ä± ile ehlileÅŸtir
3. Bin, WASD ile kontrol et
4. Ä°n, takip sistemini test et

**Test 3: KuÅŸatma Sistemi**
1. Klan oluÅŸtur, bÃ¶lge al
2. DÃ¼ÅŸman klan bÃ¶lgesine Beacon dik
3. 5 dakika countdown'u bekle
4. SavaÅŸ baÅŸladÄ±ÄŸÄ±nda korumalarÄ±n kalktÄ±ÄŸÄ±nÄ± doÄŸrula

**Test 4: YapÄ± BufflarÄ±**
1. Simya Kulesi dik
2. Batarya ateÅŸle, hasar Ã§arpanÄ±nÄ± kontrol et
3. Zehir ReaktÃ¶rÃ¼ dik
4. DÃ¼ÅŸman oyuncuya yaklaÅŸ, zehir efektini gÃ¶r

**Test 5: Offline Koruma**
1. Klan oluÅŸtur, Core'a yakÄ±t ekle
2. TÃ¼m Ã¼yeleri offline yap
3. DÃ¼ÅŸman klan blok kÄ±rmaya Ã§alÄ±ÅŸsÄ±n
4. YakÄ±t tÃ¼ketildiÄŸini ve hasar azaltmanÄ±n aktif olduÄŸunu doÄŸrula

### ğŸ”® SIRADAKÄ° FAZ: POLÄ°SH VE OPTÄ°MÄ°ZASYON

Faz 7 tamamlandÄ±! ArtÄ±k oyunun "meta-game" derinliÄŸi var. Bir sonraki fazda:
- UI/UX iyileÅŸtirmeleri
- Performans optimizasyonlarÄ±
- Bug fix'ler
- Balance ayarlarÄ±

---

**Son GÃ¼ncelleme:** BugÃ¼n  
**Durum:** âœ… FAZ 7 TAMAMLANDI - GÃ¼Ã§ Sistemi, Binekler, KuÅŸatma ve YapÄ± BufflarÄ± HazÄ±r

---

# ğŸš€ FAZ 8: EKSÄ°K SÄ°STEMLER, ADMIN KOMUTLARI VE CONFIG YÃ–NETÄ°MÄ°

**AmaÃ§:**

1. **Eksik Oyun Sistemleri:** Kervan, AraÅŸtÄ±rma, Ãœreme, Market, GÃ¶rev, Supply Drop, KuÅŸatma SilahlarÄ±, Hayalet Tarif, Ä°ttifak
2. **Admin Komut Sistemi:** TÃ¼m sistemleri test etmek iÃ§in admin komutlarÄ±
3. **Config YÃ¶netim Sistemi:** TÃ¼m ayarlarÄ± merkezi olarak yÃ¶netmek

**SÃ¼re Tahmini:** 4-5 hafta  
**Zorluk:** â­â­â­â­ (Ã‡ok sayÄ±da sistem, test ve dengeleme)

**Motto:** **"TamamlanmÄ±ÅŸ ÃœrÃ¼n"** - TÃ¼m Ã¶zellikler, test araÃ§larÄ± ve ayarlar hazÄ±r.

---

## ğŸ“‹ Ä°Ã‡Ä°NDEKÄ°LER

1. [Eksik Oyun Sistemleri](#eksik-oyun-sistemleri)
   - 1.1 Kervan Sistemi
   - 1.2 AraÅŸtÄ±rma Sistemi
   - 1.3 Ãœreme Sistemi
   - 1.4 Market Sistemi
   - 1.5 GÃ¶rev Sistemi
   - 1.6 Supply Drop Sistemi
   - 1.7 KuÅŸatma SilahlarÄ±
   - 1.8 Hayalet Tarif Sistemi
   - 1.9 Ä°ttifak Sistemi
2. [Admin Komut Sistemi](#admin-komut-sistemi)
   - 2.1 AdminCommandHandler
   - 2.2 Komut Kategorileri
   - 2.3 Tab Completion
3. [Config YÃ¶netim Sistemi](#config-yÃ¶netim-sistemi)
   - 3.1 ConfigManager
   - 3.2 ScriptableObject Config'ler
   - 3.3 Runtime Config DeÄŸiÅŸiklikleri

---

## ğŸ® EKSÄ°K OYUN SÄ°STEMLERÄ°

### 1.1 KERVAN SÄ°STEMÄ° (Caravan System)

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Economy/CaravanManager.cs`

**Ã–zellikler:**
- Minimum 1000 blok mesafe
- Minimum 20 stack yÃ¼k
- Minimum 5000 altÄ±n deÄŸer
- Mule ile yÃ¼k taÅŸÄ±ma
- x1.5 deÄŸer bonusu (hedefe ulaÅŸÄ±nca)
- SaldÄ±rÄ±ya aÃ§Ä±k (riskli)

**Teknolojiler:**
- **FishNet** - NetworkObject senkronizasyonu
- **Unity NavMesh** - Pathfinding (Mule otomatik yol bulur)
- **Unity Physics** - Mesafe hesaplama (Vector3.Distance)

**Kod:**

```csharp
using UnityEngine;
using UnityEngine.AI;
using FishNet.Object;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Kervan yÃ¶neticisi - Uzun mesafe ticaret sistemi
/// Voxel terrain Ã¼zerinde NavMesh pathfinding ile kervan yÃ¶netimi
/// </summary>
public class CaravanManager : NetworkBehaviour {
    [Header("Ayarlar")]
    [Tooltip("Minimum mesafe (blok)")]
    public float minDistance = 1000f;
    
    [Tooltip("Minimum stack sayÄ±sÄ±")]
    public int minStacks = 20;
    
    [Tooltip("Minimum deÄŸer (altÄ±n)")]
    public int minValue = 5000;
    
    [Tooltip("DeÄŸer Ã§arpanÄ± (hedefe ulaÅŸÄ±nca)")]
    [Range(1f, 2f)]
    public float valueMultiplier = 1.5f;
    
    [Tooltip("Kervan hÄ±zÄ±")]
    [Range(1f, 10f)]
    public float caravanSpeed = 3f;
    
    // âœ… OPTÄ°MÄ°ZE: Aktif kervanlar cache
    private Dictionary<string, CaravanData> _activeCaravans = new Dictionary<string, CaravanData>();
    
    // âœ… OPTÄ°MÄ°ZE: ChunkManager ve TerritoryManager referanslarÄ±
    private ChunkManager _chunkManager;
    private TerritoryManager _territoryManager;
    private DatabaseManager _databaseManager;
    
    void Awake() {
        ServiceLocator.Instance?.Register<CaravanManager>(this);
    }
    
    void Start() {
        if (!IsServer) return;
        
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        _territoryManager = ServiceLocator.Instance?.Get<TerritoryManager>();
        _databaseManager = ServiceLocator.Instance?.Get<DatabaseManager>();
        
        if (_chunkManager == null) {
            Debug.LogError("[CaravanManager] ChunkManager bulunamadÄ±!");
        }
    }
    
    /// <summary>
    /// âœ… Kervan oluÅŸtur (server-authoritative)
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void CmdCreateCaravan(NetworkObject player, Vector3 startPos, Vector3 endPos, List<ItemData> cargo) {
        if (player == null || cargo == null || cargo.Count == 0) return;
        
        string playerId = player.OwnerId.ToString();
        
        // âœ… 1. Mesafe kontrolÃ¼
        float distance = Vector3.Distance(startPos, endPos);
        if (distance < minDistance) {
            RpcShowMessage(player.Owner, $"Minimum mesafe: {minDistance} blok (Mevcut: {distance:F0})");
            return;
        }
        
        // âœ… 2. Stack kontrolÃ¼
        int totalStacks = cargo.Sum(item => item.quantity);
        if (totalStacks < minStacks) {
            RpcShowMessage(player.Owner, $"Minimum yÃ¼k: {minStacks} stack (Mevcut: {totalStacks})");
            return;
        }
        
        // âœ… 3. DeÄŸer hesapla
        float totalValue = CalculateCargoValue(cargo);
        if (totalValue < minValue) {
            RpcShowMessage(player.Owner, $"Minimum deÄŸer: {minValue} altÄ±n (Mevcut: {totalValue:F0})");
            return;
        }
        
        // âœ… 4. Voxel terrain kontrolÃ¼ (ChunkManager)
        Vector3Int startChunk = _chunkManager.GetChunkCoord(startPos);
        Vector3Int endChunk = _chunkManager.GetChunkCoord(endPos);
        
        if (_chunkManager.GetChunk(startChunk) == null || _chunkManager.GetChunk(endChunk) == null) {
            RpcShowMessage(player.Owner, "BaÅŸlangÄ±Ã§ veya hedef bÃ¶lge henÃ¼z yÃ¼klenmedi!");
            return;
        }
        
        // âœ… 5. NavMesh path kontrolÃ¼
        NavMeshPath path = new NavMeshPath();
        NavMeshAgent tempAgent = new GameObject("TempAgent").AddComponent<NavMeshAgent>();
        tempAgent.CalculatePath(endPos, path);
        Destroy(tempAgent.gameObject);
        
        if (path.status != NavMeshPathStatus.PathComplete) {
            RpcShowMessage(player.Owner, "Hedefe ulaÅŸÄ±lamÄ±yor! (NavMesh path bulunamadÄ±)");
            return;
        }
        
        // âœ… 6. Mule spawn et
        GameObject mulePrefab = Resources.Load<GameObject>("Prefabs/Mule");
        if (mulePrefab == null) {
            Debug.LogError("[CaravanManager] Mule prefab bulunamadÄ±!");
            return;
        }
        
        GameObject muleObj = Instantiate(mulePrefab, startPos, Quaternion.identity);
        NetworkObject muleNet = muleObj.GetComponent<NetworkObject>();
        if (muleNet == null) {
            muleNet = muleObj.AddComponent<NetworkObject>();
        }
        Spawn(muleNet);
        
        // âœ… 7. NavMeshAgent ayarla
        NavMeshAgent agent = muleObj.GetComponent<NavMeshAgent>();
        if (agent == null) {
            agent = muleObj.AddComponent<NavMeshAgent>();
        }
        agent.speed = caravanSpeed;
        agent.SetDestination(endPos);
        
        // âœ… 8. Kervan data oluÅŸtur
        string caravanId = System.Guid.NewGuid().ToString();
        CaravanData caravan = new CaravanData {
            caravanId = caravanId,
            playerId = playerId,
            startPos = startPos,
            endPos = endPos,
            cargo = cargo,
            totalValue = totalValue,
            muleObject = muleObj,
            agent = agent,
            startTime = Time.time
        };
        
        _activeCaravans[caravanId] = caravan;
        
        // âœ… 9. Arrival detection coroutine baÅŸlat
        StartCoroutine(CheckArrival(caravan));
        
        RpcShowMessage(player.Owner, $"Kervan oluÅŸturuldu! DeÄŸer: {totalValue:F0} altÄ±n, Mesafe: {distance:F0} blok");
    }
    
    /// <summary>
    /// âœ… YÃ¼k deÄŸerini hesapla
    /// </summary>
    float CalculateCargoValue(List<ItemData> cargo) {
        float totalValue = 0f;
        ItemDatabase itemDb = ServiceLocator.Instance?.Get<ItemDatabase>();
        
        foreach (var item in cargo) {
            ItemDefinition itemDef = itemDb?.GetItem(item.itemId);
            if (itemDef != null) {
                totalValue += itemDef.basePrice * item.quantity;
            }
        }
        
        return totalValue;
    }
    
    /// <summary>
    /// âœ… VarÄ±ÅŸ kontrolÃ¼ (coroutine)
    /// </summary>
    IEnumerator CheckArrival(CaravanData caravan) {
        while (caravan.agent != null && caravan.agent.pathPending) {
            yield return null;
        }
        
        while (caravan.agent != null && !caravan.agent.pathEndPosition.Equals(Vector3.zero)) {
            // âœ… Mesafe kontrolÃ¼
            float distanceToEnd = Vector3.Distance(caravan.muleObject.transform.position, caravan.endPos);
            
            if (distanceToEnd < 5f) {
                // âœ… VarÄ±ÅŸ!
                OnCaravanArrived(caravan);
                yield break;
            }
            
            // âœ… Path kaybÄ± kontrolÃ¼
            if (!caravan.agent.pathPending && caravan.agent.pathStatus == NavMeshPathStatus.PathInvalid) {
                OnCaravanFailed(caravan, "Yol kaybedildi!");
                yield break;
            }
            
            yield return new WaitForSeconds(1f);
        }
    }
    
    /// <summary>
    /// âœ… Kervan varÄ±ÅŸÄ±
    /// </summary>
    void OnCaravanArrived(CaravanData caravan) {
        // âœ… DeÄŸer Ã§arpanÄ± uygula
        float finalValue = caravan.totalValue * valueMultiplier;
        
        // âœ… Oyuncuya Ã¶dÃ¼l ver
        _databaseManager?.AddGoldAsync(caravan.playerId, (int)finalValue);
        
        // âœ… Mule'i yok et
        if (caravan.muleObject != null) {
            NetworkObject muleNet = caravan.muleObject.GetComponent<NetworkObject>();
            if (muleNet != null) {
                Despawn(muleNet);
            } else {
                Destroy(caravan.muleObject);
            }
        }
        
        // âœ… Cache'den kaldÄ±r
        _activeCaravans.Remove(caravan.caravanId);
        
        // âœ… Oyuncuya bildir
        var player = FindPlayerById(caravan.playerId);
        if (player != null) {
            RpcShowMessage(player.Owner, $"Kervan hedefe ulaÅŸtÄ±! Ã–dÃ¼l: {finalValue:F0} altÄ±n (x{valueMultiplier} bonus)");
        }
    }
    
    /// <summary>
    /// âœ… Kervan baÅŸarÄ±sÄ±z
    /// </summary>
    void OnCaravanFailed(CaravanData caravan, string reason) {
        // âœ… Mule'i yok et
        if (caravan.muleObject != null) {
            NetworkObject muleNet = caravan.muleObject.GetComponent<NetworkObject>();
            if (muleNet != null) {
                Despawn(muleNet);
            } else {
                Destroy(caravan.muleObject);
            }
        }
        
        // âœ… Cache'den kaldÄ±r
        _activeCaravans.Remove(caravan.caravanId);
        
        // âœ… Oyuncuya bildir
        var player = FindPlayerById(caravan.playerId);
        if (player != null) {
            RpcShowMessage(player.Owner, $"Kervan baÅŸarÄ±sÄ±z: {reason}");
        }
    }
    
    /// <summary>
    /// âœ… Oyuncu bul (ID'den)
    /// </summary>
    NetworkObject FindPlayerById(string playerId) {
        // âœ… FishNet'ten oyuncu bul
        foreach (var conn in ServerManager.Clients) {
            if (conn.ClientId.ToString() == playerId) {
                return conn.FirstObject;
            }
        }
        return null;
    }
    
    /// <summary>
    /// âœ… RPC: Mesaj gÃ¶ster
    /// </summary>
    [TargetRpc]
    void RpcShowMessage(NetworkConnection conn, string message) {
        Debug.Log($"[CaravanManager] {message}");
    }
    
    /// <summary>
    /// âœ… Kervan data yapÄ±sÄ±
    /// </summary>
    class CaravanData {
        public string caravanId;
        public string playerId;
        public Vector3 startPos;
        public Vector3 endPos;
        public List<ItemData> cargo;
        public float totalValue;
        public GameObject muleObject;
        public NavMeshAgent agent;
        public float startTime;
    }
    
    /// <summary>
    /// âœ… Item data yapÄ±sÄ±
    /// </summary>
    [System.Serializable]
    public class ItemData {
        public string itemId;
        public int quantity;
    }
}
```

**Optimizasyon:**
- âœ… Dictionary cache (aktif kervanlar)
- âœ… ChunkManager entegrasyonu (voxel terrain kontrolÃ¼)
- âœ… NavMesh pathfinding (voxel terrain Ã¼zerinde yol bulma)
- âœ… Coroutine ile async arrival detection

**Referanslar:**
- [Unity NavMesh](https://docs.unity3d.com/Manual/nav-BuildingNavMesh.html)
- [Unity NavMeshAgent](https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent.html)

**KÃ¼tÃ¼phane:** Unity NavMesh Components (Runtime Baking)

---

### 1.2 ARAÅTIRMA SÄ°STEMÄ° (Research System)

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Research/ResearchManager.cs`

**Ã–zellikler:**
- Tarif KitabÄ± (Recipe Book) - Boss'lardan dÃ¼ÅŸer
- Lectern + Crafting Table = AraÅŸtÄ±rma MasasÄ±
- 10 blok yarÄ±Ã§ap paylaÅŸÄ±m
- Envanter + AraÅŸtÄ±rma MasasÄ± kontrolÃ¼

**Teknolojiler:**
- **ScriptableObject** - Tarif kitabÄ± verileri
- **Unity Physics** - OverlapSphere (10 blok kontrol)
- **SQLite** - Tarif kayÄ±t sistemi
- **TextMeshPro** - UI gÃ¶sterimi

**Kod:**

```csharp
using UnityEngine;
using FishNet.Object;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: AraÅŸtÄ±rma yÃ¶neticisi - Tarif paylaÅŸÄ±m sistemi
/// Voxel terrain Ã¼zerinde Research Table ile tarif paylaÅŸÄ±mÄ±
/// </summary>
public class ResearchManager : NetworkBehaviour {
    [Header("Ayarlar")]
    [Tooltip("AraÅŸtÄ±rma masasÄ± yarÄ±Ã§apÄ± (blok)")]
    [Range(5f, 20f)]
    public float researchTableDistance = 10f;
    
    [Tooltip("Tarif kitabÄ± item ID'si")]
    public string recipeBookItemId = "RECIPE_BOOK";
    
    // âœ… OPTÄ°MÄ°ZE: Tarif cache (oyuncu -> tarif listesi)
    private Dictionary<string, HashSet<string>> _playerRecipes = new Dictionary<string, HashSet<string>>();
    
    // âœ… OPTÄ°MÄ°ZE: Research Table cache (pozisyon -> ResearchTable)
    private Dictionary<Vector3Int, ResearchTable> _researchTables = new Dictionary<Vector3Int, ResearchTable>();
    
    private DatabaseManager _databaseManager;
    private ItemDatabase _itemDatabase;
    private ChunkManager _chunkManager; // Voxel terrain entegrasyonu
    
    void Awake() {
        ServiceLocator.Instance?.Register<ResearchManager>(this);
    }
    
    void Start() {
        if (!IsServer) return;
        
        _databaseManager = ServiceLocator.Instance?.Get<DatabaseManager>();
        _itemDatabase = ServiceLocator.Instance?.Get<ItemDatabase>();
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        
        if (_chunkManager == null) {
            Debug.LogError("[ResearchManager] ChunkManager bulunamadÄ±!");
        }
    }
    
    /// <summary>
    /// âœ… Tarif kitabÄ± var mÄ±? (envanter + research table)
    /// </summary>
    public bool HasRecipeBook(string playerId, string recipeId) {
        // âœ… 1. Envanterde var mÄ±?
        var playerItems = _databaseManager?.GetPlayerItemsAsync(playerId).Result;
        if (playerItems != null && playerItems.Any(i => i.itemId == $"{recipeBookItemId}_{recipeId}")) {
            return true;
        }
        
        // âœ… 2. AraÅŸtÄ±rma MasasÄ±nda var mÄ±? (voxel terrain Ã¼zerinde)
        var player = FindPlayerById(playerId);
        if (player == null) return false;
        
        // âœ… Voxel terrain Ã¼zerinde Research Table ara
        Collider[] lecterns = Physics.OverlapSphere(player.transform.position, researchTableDistance);
        
        foreach (var lectern in lecterns) {
            ResearchTable researchTable = lectern.GetComponent<ResearchTable>();
            if (researchTable != null && researchTable.HasRecipe(recipeId)) {
                return true;
            }
        }
        
        return false;
    }
    
    /// <summary>
    /// âœ… Tarif Ã¶ÄŸren (Research Table'dan)
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void CmdLearnRecipe(NetworkObject player, string recipeId) {
        if (player == null) return;
        
        string playerId = player.OwnerId.ToString();
        
        // âœ… Zaten biliyor mu?
        if (HasRecipeBook(playerId, recipeId)) {
            RpcShowMessage(player.Owner, "Bu tarifi zaten biliyorsun!");
            return;
        }
        
        // âœ… Research Table kontrolÃ¼
        var playerObj = FindPlayerById(playerId);
        if (playerObj == null) return;
        
        Collider[] lecterns = Physics.OverlapSphere(playerObj.transform.position, researchTableDistance);
        ResearchTable nearbyTable = null;
        
        foreach (var lectern in lecterns) {
            ResearchTable table = lectern.GetComponent<ResearchTable>();
            if (table != null && table.HasRecipe(recipeId)) {
                nearbyTable = table;
                break;
            }
        }
        
        if (nearbyTable == null) {
            RpcShowMessage(player.Owner, "YakÄ±nda araÅŸtÄ±rma masasÄ± yok!");
            return;
        }
        
        // âœ… Tarif kitabÄ± oluÅŸtur ve ver
        string recipeBookId = $"{recipeBookItemId}_{recipeId}";
        GiveRecipeBook(playerId, recipeBookId);
        
        // âœ… Cache'e ekle
        if (!_playerRecipes.ContainsKey(playerId)) {
            _playerRecipes[playerId] = new HashSet<string>();
        }
        _playerRecipes[playerId].Add(recipeId);
        
        RpcShowMessage(player.Owner, $"Tarif Ã¶ÄŸrenildi: {recipeId}");
    }
    
    /// <summary>
    /// âœ… Tarif kitabÄ± ver
    /// </summary>
    void GiveRecipeBook(string playerId, string recipeBookId) {
        // âœ… ItemDatabase'den tarif kitabÄ± item'Ä±nÄ± al
        ItemDefinition recipeBook = _itemDatabase?.GetItem(recipeBookId);
        if (recipeBook == null) {
            Debug.LogWarning($"[ResearchManager] Tarif kitabÄ± bulunamadÄ±: {recipeBookId}");
            return;
        }
        
        // âœ… Oyuncuya item ver (ItemManager veya benzeri sistem)
        // TODO: ItemManager entegrasyonu
    }
    
    /// <summary>
    /// âœ… Research Table kaydet
    /// </summary>
    public void RegisterResearchTable(Vector3 position, ResearchTable table) {
        Vector3Int chunkCoord = GetChunkCoord(position);
        _researchTables[chunkCoord] = table;
    }
    
    /// <summary>
    /// âœ… Research Table kaldÄ±r
    /// </summary>
    public void UnregisterResearchTable(Vector3 position) {
        Vector3Int chunkCoord = GetChunkCoord(position);
        _researchTables.Remove(chunkCoord);
    }
    
    /// <summary>
    /// âœ… Chunk koordinatÄ±nÄ± al
    /// </summary>
    Vector3Int GetChunkCoord(Vector3 position) {
        ChunkManager chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        if (chunkManager != null) {
            return chunkManager.GetChunkCoord(position);
        }
        
        // âœ… Fallback: Manuel hesaplama
        int chunkSize = 32;
        return new Vector3Int(
            Mathf.FloorToInt(position.x / chunkSize),
            Mathf.FloorToInt(position.y / chunkSize),
            Mathf.FloorToInt(position.z / chunkSize)
        );
    }
    
    /// <summary>
    /// âœ… Oyuncu bul (ID'den)
    /// </summary>
    GameObject FindPlayerById(string playerId) {
        foreach (var conn in ServerManager.Clients) {
            if (conn.ClientId.ToString() == playerId) {
                return conn.FirstObject?.gameObject;
            }
        }
        return null;
    }
    
    /// <summary>
    /// âœ… RPC: Mesaj gÃ¶ster
    /// </summary>
    [TargetRpc]
    void RpcShowMessage(NetworkConnection conn, string message) {
        Debug.Log($"[ResearchManager] {message}");
    }
}

/// <summary>
/// âœ… Research Table component
/// </summary>
public class ResearchTable : MonoBehaviour {
    [Header("Ayarlar")]
    [Tooltip("Bu masada bulunan tarifler")]
    public List<string> availableRecipes = new List<string>();
    
    /// <summary>
    /// âœ… Tarif var mÄ±?
    /// </summary>
    public bool HasRecipe(string recipeId) {
        return availableRecipes.Contains(recipeId);
    }
}
```

**Optimizasyon:**
- âœ… Dictionary cache (oyuncu tarifleri, research table'lar)
- âœ… Physics.OverlapSphere (voxel terrain Ã¼zerinde arama)
- âœ… ChunkManager entegrasyonu (voxel terrain kontrolÃ¼)

**Referanslar:**
- [Unity Physics.OverlapSphere](https://docs.unity3d.com/ScriptReference/Physics.OverlapSphere.html)

**KÃ¼tÃ¼phane:** Unity ScriptableObject (yerleÅŸik)

---

### 1.3 ÃœREME SÄ°STEMÄ° (Breeding System)

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Taming/BreedingManager.cs`

**Ã–zellikler:**
- Breeding Core ile Ã§iftleÅŸtirme tesisleri
- Gender Scanner ile cinsiyet kontrolÃ¼
- Memeli vs Yumurtlayan canlÄ±lar
- Seviyeli tesisler (1-5 seviye)
- DoÄŸal Ã§iftleÅŸtirme (yemek verme)

**Teknolojiler:**
- **FishNet** - NetworkBehaviour senkronizasyonu
- **Unity Coroutines** - Async breeding sÃ¼reci
- **SQLite** - Ã‡iftleÅŸtirme kayÄ±tlarÄ±

**Kod:**

```csharp
using UnityEngine;
using FishNet.Object;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Ãœreme yÃ¶neticisi - Ã‡iftleÅŸtirme tesisleri
/// Voxel terrain Ã¼zerinde Breeding Core ile Ã§iftleÅŸtirme
/// </summary>
public class BreedingManager : NetworkBehaviour {
    [Header("Ayarlar")]
    [Tooltip("DoÄŸal Ã§iftleÅŸtirme sÃ¼resi (saniye)")]
    [Range(30f, 300f)]
    public float naturalBreedingDuration = 60f;
    
    [Tooltip("Tesis seviyesi Ã§arpanÄ± (her seviye iÃ§in sÃ¼re azalmasÄ±)")]
    [Range(0.1f, 0.5f)]
    public float facilityLevelMultiplier = 0.2f;
    
    [Tooltip("Ã‡iftleÅŸtirme mesafesi (blok)")]
    [Range(1f, 10f)]
    public float breedingDistance = 5f;
    
    // âœ… OPTÄ°MÄ°ZE: Aktif Ã§iftleÅŸtirmeler cache
    private Dictionary<string, BreedingProcess> _activeBreedings = new Dictionary<string, BreedingProcess>();
    
    // âœ… OPTÄ°MÄ°ZE: Breeding Core cache (pozisyon -> BreedingCore)
    private Dictionary<Vector3Int, BreedingCore> _breedingCores = new Dictionary<Vector3Int, BreedingCore>();
    
    private DatabaseManager _databaseManager;
    private ChunkManager _chunkManager; // Voxel terrain entegrasyonu
    
    void Awake() {
        ServiceLocator.Instance?.Register<BreedingManager>(this);
    }
    
    void Start() {
        if (!IsServer) return;
        _databaseManager = ServiceLocator.Instance?.Get<DatabaseManager>();
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        
        if (_chunkManager == null) {
            Debug.LogError("[BreedingManager] ChunkManager bulunamadÄ±!");
        }
    }
    
    /// <summary>
    /// âœ… Ã‡iftleÅŸtirme baÅŸlat (server-authoritative)
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void CmdStartBreeding(NetworkObject player, NetworkObject femaleObj, NetworkObject maleObj, Vector3 corePosition) {
        if (player == null || femaleObj == null || maleObj == null) return;
        
        RideableMob female = femaleObj.GetComponent<RideableMob>();
        RideableMob male = maleObj.GetComponent<RideableMob>();
        
        if (female == null || male == null) return;
        
        // âœ… 1. Cinsiyet kontrolÃ¼
        if (female.gender != "FEMALE" || male.gender != "MALE") {
            RpcShowMessage(player.Owner, "Cinsiyet uyumsuz! (DiÅŸi + Erkek gerekli)");
            return;
        }
        
        // âœ… 2. Mesafe kontrolÃ¼
        float distance = Vector3.Distance(female.transform.position, male.transform.position);
        if (distance > breedingDistance) {
            RpcShowMessage(player.Owner, $"Moblar Ã§ok uzak! (Maksimum: {breedingDistance} blok)");
            return;
        }
        
        // âœ… 3. Breeding Core kontrolÃ¼ (Voxel terrain uyumlu)
        Vector3Int chunkCoord = _chunkManager != null ? _chunkManager.GetChunkCoord(corePosition) : Vector3Int.zero;
        
        // âœ… Chunk aktif mi?
        if (_chunkManager != null && _chunkManager.GetChunk(chunkCoord) == null) {
            RpcShowMessage(player.Owner, "Breeding Core bÃ¶lgesi henÃ¼z yÃ¼klenmedi!");
            return;
        }
        
        if (!_breedingCores.TryGetValue(chunkCoord, out BreedingCore core)) {
            RpcShowMessage(player.Owner, "YakÄ±nda Breeding Core yok!");
            return;
        }
        
        // âœ… 4. Zaten Ã§iftleÅŸtiriliyor mu?
        string breedingId = $"{female.NetworkObject.ObjectId}_{male.NetworkObject.ObjectId}";
        if (_activeBreedings.ContainsKey(breedingId)) {
            RpcShowMessage(player.Owner, "Bu moblar zaten Ã§iftleÅŸtiriliyor!");
            return;
        }
        
        // âœ… 5. Tesis seviyesine gÃ¶re sÃ¼re hesapla
        float duration = naturalBreedingDuration * (1f - (core.level * facilityLevelMultiplier));
        duration = Mathf.Max(10f, duration); // Minimum 10 saniye
        
        // âœ… 6. Ã‡iftleÅŸtirme sÃ¼recini baÅŸlat
        BreedingProcess process = new BreedingProcess {
            breedingId = breedingId,
            female = female,
            male = male,
            core = core,
            startTime = Time.time,
            duration = duration
        };
        
        _activeBreedings[breedingId] = process;
        StartCoroutine(BreedingCoroutine(process));
        
        RpcShowMessage(player.Owner, $"Ã‡iftleÅŸtirme baÅŸladÄ±! SÃ¼re: {duration:F0} saniye");
    }
    
    /// <summary>
    /// âœ… Ã‡iftleÅŸtirme coroutine
    /// </summary>
    IEnumerator BreedingCoroutine(BreedingProcess process) {
        yield return new WaitForSeconds(process.duration);
        
        // âœ… Moblar hala var mÄ±?
        if (process.female == null || process.male == null) {
            _activeBreedings.Remove(process.breedingId);
            yield break;
        }
        
        // âœ… Memeli mi? Yumurtlayan mÄ±?
        bool isMammal = IsMammal(process.female.mobDefinition.mobId);
        
        if (isMammal) {
            // âœ… Direkt yavru spawn
            SpawnOffspring(process.female, process.male, process.core.transform.position);
        } else {
            // âœ… Yumurta spawn
            SpawnEgg(process.female, process.male, process.core.transform.position);
        }
        
        // âœ… Cache'den kaldÄ±r
        _activeBreedings.Remove(process.breedingId);
    }
    
    /// <summary>
    /// âœ… Memeli mi?
    /// </summary>
    bool IsMammal(string mobId) {
        // âœ… Memeli mob listesi (Ã¶rnek)
        string[] mammals = { "dragon", "trex", "wolf", "bear" };
        return mammals.Contains(mobId.ToLower());
    }
    
    /// <summary>
    /// âœ… Yavru spawn (memeli)
    /// </summary>
    void SpawnOffspring(RideableMob female, RideableMob male, Vector3 position) {
        // âœ… Yavru prefab'Ä± al (diÅŸi veya erkeÄŸin prefab'Ä±ndan)
        GameObject offspringPrefab = female.mobDefinition.prefab;
        if (offspringPrefab == null) return;
        
        // âœ… Yavru spawn et
        GameObject offspring = Instantiate(offspringPrefab, position, Quaternion.identity);
        NetworkObject offspringNet = offspring.GetComponent<NetworkObject>();
        if (offspringNet != null) {
            Spawn(offspringNet);
        }
        
        // âœ… Cinsiyet rastgele
        RideableMob offspringMob = offspring.GetComponent<RideableMob>();
        if (offspringMob != null) {
            offspringMob.gender = Random.Range(0, 2) == 0 ? "MALE" : "FEMALE";
        }
        
        Debug.Log($"[BreedingManager] Yavru spawn edildi: {position}");
    }
    
    /// <summary>
    /// âœ… Yumurta spawn (yumurtlayan)
    /// </summary>
    void SpawnEgg(RideableMob female, RideableMob male, Vector3 position) {
        // âœ… Yumurta prefab'Ä± spawn et
        GameObject eggPrefab = Resources.Load<GameObject>("Prefabs/Egg");
        if (eggPrefab == null) {
            Debug.LogWarning("[BreedingManager] Yumurta prefab bulunamadÄ±!");
            return;
        }
        
        GameObject egg = Instantiate(eggPrefab, position, Quaternion.identity);
        NetworkObject eggNet = egg.GetComponent<NetworkObject>();
        if (eggNet != null) {
            Spawn(eggNet);
        }
        
        // âœ… Yumurta data'sÄ±nÄ± ayarla (parent mob bilgileri)
        Egg eggComponent = egg.GetComponent<Egg>();
        if (eggComponent != null) {
            eggComponent.SetParents(female, male);
        }
        
        Debug.Log($"[BreedingManager] Yumurta spawn edildi: {position}");
    }
    
    /// <summary>
    /// âœ… Breeding Core kaydet (Voxel terrain uyumlu)
    /// </summary>
    public void RegisterBreedingCore(Vector3 position, BreedingCore core) {
        Vector3Int chunkCoord = _chunkManager != null ? _chunkManager.GetChunkCoord(position) : Vector3Int.zero;
        _breedingCores[chunkCoord] = core;
    }
    
    /// <summary>
    /// âœ… Breeding Core kaldÄ±r (Voxel terrain uyumlu)
    /// </summary>
    public void UnregisterBreedingCore(Vector3 position) {
        Vector3Int chunkCoord = _chunkManager != null ? _chunkManager.GetChunkCoord(position) : Vector3Int.zero;
        _breedingCores.Remove(chunkCoord);
    }
    
    /// <summary>
    /// âœ… RPC: Mesaj gÃ¶ster
    /// </summary>
    [TargetRpc]
    void RpcShowMessage(NetworkConnection conn, string message) {
        Debug.Log($"[BreedingManager] {message}");
    }
    
    /// <summary>
    /// âœ… Ã‡iftleÅŸtirme sÃ¼reci data yapÄ±sÄ±
    /// </summary>
    class BreedingProcess {
        public string breedingId;
        public RideableMob female;
        public RideableMob male;
        public BreedingCore core;
        public float startTime;
        public float duration;
    }
}

/// <summary>
/// âœ… Breeding Core component
/// </summary>
public class BreedingCore : MonoBehaviour {
    [Header("Ayarlar")]
    [Tooltip("Tesis seviyesi (1-5)")]
    [Range(1, 5)]
    public int level = 1;
    
    void Start() {
        BreedingManager manager = ServiceLocator.Instance?.Get<BreedingManager>();
        if (manager != null) {
            manager.RegisterBreedingCore(transform.position, this);
        }
    }
    
    void OnDestroy() {
        BreedingManager manager = ServiceLocator.Instance?.Get<BreedingManager>();
        if (manager != null) {
            manager.UnregisterBreedingCore(transform.position);
        }
    }
}

/// <summary>
/// âœ… Yumurta component
/// </summary>
public class Egg : NetworkBehaviour {
    private RideableMob _femaleParent;
    private RideableMob _maleParent;
    private float _hatchTime = 300f; // 5 dakika
    
    public void SetParents(RideableMob female, RideableMob male) {
        _femaleParent = female;
        _maleParent = male;
    }
    
    void Start() {
        if (IsServer) {
            StartCoroutine(HatchCoroutine());
        }
    }
    
    IEnumerator HatchCoroutine() {
        yield return new WaitForSeconds(_hatchTime);
        
        // âœ… Yavru spawn et
        BreedingManager manager = ServiceLocator.Instance?.Get<BreedingManager>();
        if (manager != null && _femaleParent != null && _maleParent != null) {
            manager.SpawnOffspring(_femaleParent, _maleParent, transform.position);
        }
        
        // âœ… YumurtayÄ± yok et
        NetworkObject eggNet = GetComponent<NetworkObject>();
        if (eggNet != null) {
            Despawn(eggNet);
        } else {
            Destroy(gameObject);
        }
    }
}
```

**Optimizasyon:**
- âœ… Dictionary cache (aktif Ã§iftleÅŸtirmeler, breeding core'lar)
- âœ… Coroutine ile async sÃ¼reÃ§
- âœ… ChunkManager entegrasyonu (voxel terrain kontrolÃ¼)

**Referanslar:**
- [Unity Coroutines](https://docs.unity3d.com/Manual/Coroutines.html)

**KÃ¼tÃ¼phane:** Unity Coroutines (yerleÅŸik)

---

### 1.4 MARKET SÄ°STEMÄ° (Shop System)

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Economy/ShopManager.cs`

**Ã–zellikler:**
- SandÄ±k + Tabela ile market kurma
- GUI menÃ¼ ile alÄ±ÅŸveriÅŸ
- Teklif sistemi (alternatif Ã¶deme)
- %5 vergi (koruma bÃ¶lgesinde)

**Teknolojiler:**
- **TextMeshPro** - UI metinleri
- **DoTween** - UI animasyonlarÄ±
- **SQLite** - Market verileri
- **FishNet** - Network senkronizasyonu

**Kod:**

```csharp
using UnityEngine;
using FishNet.Object;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Market yÃ¶neticisi - SandÄ±k + Tabela market sistemi
/// Voxel terrain Ã¼zerinde shop yerleÅŸtirme ve alÄ±ÅŸveriÅŸ
/// </summary>
public class ShopManager : NetworkBehaviour {
    [Header("Ayarlar")]
    [Tooltip("Vergi oranÄ± (koruma bÃ¶lgesinde)")]
    [Range(0f, 0.2f)]
    public float taxRate = 0.05f; // %5
    
    [Tooltip("Shop etkileÅŸim mesafesi")]
    [Range(1f, 10f)]
    public float shopInteractionRange = 5f;
    
    // âœ… OPTÄ°MÄ°ZE: Shop cache (shop ID -> ShopData)
    private Dictionary<string, ShopData> _shops = new Dictionary<string, ShopData>();
    
    // âœ… OPTÄ°MÄ°ZE: Chunk bazlÄ± shop cache
    private Dictionary<Vector3Int, List<string>> _chunkShops = new Dictionary<Vector3Int, List<string>>();
    
    private DatabaseManager _databaseManager;
    private ItemDatabase _itemDatabase;
    private TerritoryManager _territoryManager;
    
    void Awake() {
        ServiceLocator.Instance?.Register<ShopManager>(this);
    }
    
    void Start() {
        if (!IsServer) return;
        
        _databaseManager = ServiceLocator.Instance?.Get<DatabaseManager>();
        _itemDatabase = ServiceLocator.Instance?.Get<ItemDatabase>();
        _territoryManager = ServiceLocator.Instance?.Get<TerritoryManager>();
    }
    
    /// <summary>
    /// âœ… Shop oluÅŸtur (sandÄ±k + tabela)
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void CmdCreateShop(NetworkObject player, Vector3 position, string shopName) {
        if (player == null) return;
        
        string playerId = player.OwnerId.ToString();
        
        // âœ… Voxel terrain kontrolÃ¼
        ChunkManager chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        if (chunkManager != null) {
            Vector3Int chunkCoord = chunkManager.GetChunkCoord(position);
            if (chunkManager.GetChunk(chunkCoord) == null) {
                RpcShowMessage(player.Owner, "Bu bÃ¶lge henÃ¼z yÃ¼klenmedi!");
                return;
            }
        }
        
        // âœ… Shop ID oluÅŸtur
        string shopId = System.Guid.NewGuid().ToString();
        
        // âœ… Shop data oluÅŸtur
        ShopData shop = new ShopData {
            shopId = shopId,
            ownerId = playerId,
            shopName = shopName,
            position = position,
            items = new List<ShopItem>(),
            gold = 0
        };
        
        _shops[shopId] = shop;
        
        // âœ… Chunk cache'e ekle
        Vector3Int chunkCoord2 = GetChunkCoord(position);
        if (!_chunkShops.ContainsKey(chunkCoord2)) {
            _chunkShops[chunkCoord2] = new List<string>();
        }
        _chunkShops[chunkCoord2].Add(shopId);
        
        // âœ… SandÄ±k + Tabela spawn et
        SpawnShopObjects(shop);
        
        // âœ… Database'e kaydet
        _databaseManager?.SaveShopAsync(shop);
        
        RpcShowMessage(player.Owner, $"Market oluÅŸturuldu: {shopName}");
    }
    
    /// <summary>
    /// âœ… Shop objelerini spawn et (sandÄ±k + tabela)
    /// </summary>
    void SpawnShopObjects(ShopData shop) {
        // âœ… SandÄ±k spawn et
        GameObject chestPrefab = Resources.Load<GameObject>("Prefabs/ShopChest");
        if (chestPrefab != null) {
            GameObject chest = Instantiate(chestPrefab, shop.position, Quaternion.identity);
            NetworkObject chestNet = chest.GetComponent<NetworkObject>();
            if (chestNet != null) {
                Spawn(chestNet);
            }
            
            // âœ… Shop component ekle
            ShopChest shopChest = chest.GetComponent<ShopChest>();
            if (shopChest == null) {
                shopChest = chest.AddComponent<ShopChest>();
            }
            shopChest.Initialize(shop.shopId, this);
        }
        
        // âœ… Tabela spawn et
        GameObject signPrefab = Resources.Load<GameObject>("Prefabs/ShopSign");
        if (signPrefab != null) {
            GameObject sign = Instantiate(signPrefab, shop.position + Vector3.up * 2f, Quaternion.identity);
            NetworkObject signNet = sign.GetComponent<NetworkObject>();
            if (signNet != null) {
                Spawn(signNet);
            }
            
            // âœ… Shop component ekle
            ShopSign shopSign = sign.GetComponent<ShopSign>();
            if (shopSign == null) {
                shopSign = sign.AddComponent<ShopSign>();
            }
            shopSign.Initialize(shop.shopId, shop.shopName, this);
        }
    }
    
    /// <summary>
    /// âœ… AlÄ±ÅŸveriÅŸ yap
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void CmdBuyItem(NetworkObject player, string shopId, string itemId, int quantity) {
        if (player == null) return;
        
        // âœ… Shop bul
        if (!_shops.TryGetValue(shopId, out ShopData shop)) {
            RpcShowMessage(player.Owner, "Market bulunamadÄ±!");
            return;
        }
        
        // âœ… Item bul
        ItemDefinition item = _itemDatabase?.GetItem(itemId);
        if (item == null) {
            RpcShowMessage(player.Owner, "EÅŸya bulunamadÄ±!");
            return;
        }
        
        // âœ… Shop'ta bu item var mÄ±?
        ShopItem shopItem = shop.items.FirstOrDefault(i => i.itemId == itemId);
        if (shopItem == null || shopItem.quantity < quantity) {
            RpcShowMessage(player.Owner, "Yetersiz stok!");
            return;
        }
        
        // âœ… Fiyat hesapla
        float price = shopItem.price * quantity;
        
        // âœ… Vergi ekle (%5 koruma bÃ¶lgesinde)
        if (IsInProtectedTerritory(shop.position)) {
            price *= (1f + taxRate);
        }
        
        // âœ… Ã–deme kontrolÃ¼
        int playerGold = _databaseManager?.GetPlayerGoldAsync(player.OwnerId.ToString()).Result ?? 0;
        if (playerGold < (int)price) {
            RpcShowMessage(player.Owner, $"Yetersiz altÄ±n! (Gerekli: {(int)price}, Mevcut: {playerGold})");
            return;
        }
        
        // âœ… Ã–deme yap
        _databaseManager?.DeductGoldAsync(player.OwnerId.ToString(), (int)price);
        
        // âœ… Shop sahibine Ã¶deme yap
        _databaseManager?.AddGoldAsync(shop.ownerId, (int)(price * (1f - taxRate))); // Vergi dÃ¼ÅŸÃ¼lmÃ¼ÅŸ
        
        // âœ… Item ver
        GiveItemToPlayer(player.OwnerId.ToString(), itemId, quantity);
        
        // âœ… Stok gÃ¼ncelle
        shopItem.quantity -= quantity;
        if (shopItem.quantity <= 0) {
            shop.items.Remove(shopItem);
        }
        
        // âœ… Database gÃ¼ncelle
        _databaseManager?.SaveShopAsync(shop);
        
        RpcShowMessage(player.Owner, $"{quantity}x {item.displayName} satÄ±n alÄ±ndÄ±! ({(int)price} altÄ±n)");
    }
    
    /// <summary>
    /// âœ… Koruma bÃ¶lgesinde mi?
    /// </summary>
    bool IsInProtectedTerritory(Vector3 position) {
        if (_territoryManager == null) return false;
        
        // âœ… TerritoryManager'dan kontrol et
        string clanId = _territoryManager.GetTerritoryOwner(position);
        return !string.IsNullOrEmpty(clanId);
    }
    
    /// <summary>
    /// âœ… Oyuncuya item ver
    /// </summary>
    void GiveItemToPlayer(string playerId, string itemId, int quantity) {
        // âœ… TODO: ItemManager entegrasyonu
        Debug.Log($"[ShopManager] {playerId} oyuncusuna {quantity}x {itemId} verildi");
    }
    
    /// <summary>
    /// âœ… Chunk koordinatÄ±nÄ± al
    /// </summary>
    Vector3Int GetChunkCoord(Vector3 position) {
        ChunkManager chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        if (chunkManager != null) {
            return chunkManager.GetChunkCoord(position);
        }
        
        int chunkSize = 32;
        return new Vector3Int(
            Mathf.FloorToInt(position.x / chunkSize),
            Mathf.FloorToInt(position.y / chunkSize),
            Mathf.FloorToInt(position.z / chunkSize)
        );
    }
    
    /// <summary>
    /// âœ… RPC: Mesaj gÃ¶ster
    /// </summary>
    [TargetRpc]
    void RpcShowMessage(NetworkConnection conn, string message) {
        Debug.Log($"[ShopManager] {message}");
    }
    
    /// <summary>
    /// âœ… Shop data yapÄ±sÄ±
    /// </summary>
    [System.Serializable]
    public class ShopData {
        public string shopId;
        public string ownerId;
        public string shopName;
        public Vector3 position;
        public List<ShopItem> items;
        public int gold;
    }
    
    /// <summary>
    /// âœ… Shop item yapÄ±sÄ±
    /// </summary>
    [System.Serializable]
    public class ShopItem {
        public string itemId;
        public int quantity;
        public float price;
    }
}

/// <summary>
/// âœ… Shop Chest component
/// </summary>
public class ShopChest : NetworkBehaviour, IInteractable {
    private string _shopId;
    private ShopManager _shopManager;
    
    public void Initialize(string shopId, ShopManager manager) {
        _shopId = shopId;
        _shopManager = manager;
    }
    
    public void OnInteract(NetworkObject player) {
        // âœ… Shop UI aÃ§ (ShopUI.cs)
        // TODO: UI entegrasyonu
    }
}

/// <summary>
/// âœ… Shop Sign component
/// </summary>
public class ShopSign : NetworkBehaviour {
    private string _shopId;
    private string _shopName;
    private ShopManager _shopManager;
    
    public void Initialize(string shopId, string shopName, ShopManager manager) {
        _shopId = shopId;
        _shopName = shopName;
        _shopManager = manager;
    }
    
    // âœ… TextMeshPro ile shop ismini gÃ¶ster
    void Start() {
        // TODO: TextMeshPro entegrasyonu
    }
}
```

**Optimizasyon:**
- âœ… Dictionary cache (shop'lar, chunk bazlÄ± shop listesi)
- âœ… ChunkManager entegrasyonu (voxel terrain kontrolÃ¼)
- âœ… TerritoryManager entegrasyonu (vergi hesaplama)

**Referanslar:**
- [Unity TextMeshPro](https://docs.unity3d.com/Manual/com.unity.textmeshpro.html)
- [DoTween Documentation](http://dotween.demigiant.com/documentation.php)

**KÃ¼tÃ¼phane:** DoTween (Asset Store - Free), TextMeshPro (Unity yerleÅŸik)

---

### 1.5 GÃ–REV SÄ°STEMÄ° (Mission System)

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Missions/MissionManager.cs`

**Ã–zellikler:**
- 8 gÃ¶rev tipi (Mob AvÄ±, Malzeme Toplama, Lokasyon Ziyareti, vb.)
- 4 zorluk seviyesi (Kolay, Orta, Zor, Uzman)
- Totem ile gÃ¶rev alma
- GUI menÃ¼ ile gÃ¶rev takibi
- Otomatik ilerleme takibi

**Teknolojiler:**
- **ScriptableObject** - GÃ¶rev tanÄ±mlarÄ±
- **SQLite** - GÃ¶rev ilerleme kayÄ±tlarÄ±
- **TextMeshPro** - UI
- **Event System** - Ä°lerleme takibi

**Kod:**

```csharp
using UnityEngine;
using FishNet.Object;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: GÃ¶rev yÃ¶neticisi - 8 gÃ¶rev tipi, 4 zorluk seviyesi
/// Voxel terrain Ã¼zerinde gÃ¶rev takibi ve Ã¶dÃ¼l sistemi
/// </summary>
public class MissionManager : NetworkBehaviour {
    [Header("Ayarlar")]
    [Tooltip("Maksimum aktif gÃ¶rev sayÄ±sÄ±")]
    [Range(1, 10)]
    public int maxActiveMissions = 5;
    
    [Tooltip("GÃ¶rev alma mesafesi (Totem)")]
    [Range(1f, 20f)]
    public float missionAcceptRange = 10f;
    
    // âœ… OPTÄ°MÄ°ZE: Aktif gÃ¶revler cache (oyuncu ID -> gÃ¶rev listesi)
    private Dictionary<string, List<ActiveMission>> _activeMissions = new Dictionary<string, List<ActiveMission>>();
    
    private DatabaseManager _databaseManager;
    private ItemDatabase _itemDatabase;
    private MissionDatabase _missionDatabase; // âœ… OPTÄ°MÄ°ZE: Mission lookup (O(1))
    private ChunkManager _chunkManager; // Voxel terrain entegrasyonu
    
    void Awake() {
        ServiceLocator.Instance?.Register<MissionManager>(this);
    }
    
    void Start() {
        if (!IsServer) return;
        
        _databaseManager = ServiceLocator.Instance?.Get<DatabaseManager>();
        _itemDatabase = ServiceLocator.Instance?.Get<ItemDatabase>();
        _missionDatabase = ServiceLocator.Instance?.Get<MissionDatabase>();
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        
        if (_chunkManager == null) {
            Debug.LogError("[MissionManager] ChunkManager bulunamadÄ±!");
        }
        
        if (_missionDatabase == null) {
            Debug.LogError("[MissionManager] MissionDatabase bulunamadÄ±!");
        }
    }
    
    /// <summary>
    /// âœ… GÃ¶rev al (Totem'den)
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void CmdAcceptMission(NetworkObject player, string missionId) {
        if (player == null) return;
        
        string playerId = player.OwnerId.ToString();
        
        // âœ… Voxel terrain kontrolÃ¼ - Oyuncu aktif chunk'ta mÄ±?
        if (_chunkManager != null) {
            Vector3Int playerChunk = _chunkManager.GetChunkCoord(player.transform.position);
            if (_chunkManager.GetChunk(playerChunk) == null) {
                RpcShowMessage(player.Owner, "Bu bÃ¶lge henÃ¼z yÃ¼klenmedi!");
                return;
            }
        }
        
        // âœ… GÃ¶rev tanÄ±mÄ± bul (MissionDatabase'den O(1) lookup)
        MissionDefinition missionDef = _missionDatabase?.GetMission(missionId);
        if (missionDef == null) {
            RpcShowMessage(player.Owner, "GÃ¶rev bulunamadÄ±!");
            return;
        }
        
        // âœ… Aktif gÃ¶rev sayÄ±sÄ± kontrolÃ¼
        if (!_activeMissions.ContainsKey(playerId)) {
            _activeMissions[playerId] = new List<ActiveMission>();
        }
        
        if (_activeMissions[playerId].Count >= maxActiveMissions) {
            RpcShowMessage(player.Owner, $"Maksimum {maxActiveMissions} aktif gÃ¶rev olabilir!");
            return;
        }
        
        // âœ… Zaten bu gÃ¶rev aktif mi?
        if (_activeMissions[playerId].Any(m => m.missionId == missionId)) {
            RpcShowMessage(player.Owner, "Bu gÃ¶rev zaten aktif!");
            return;
        }
        
        // âœ… GÃ¶rev oluÅŸtur
        ActiveMission mission = new ActiveMission {
            missionId = missionId,
            definition = missionDef,
            progress = 0,
            startTime = Time.time
        };
        
        _activeMissions[playerId].Add(mission);
        
        // âœ… Database'e kaydet
        _databaseManager?.SaveMissionAsync(playerId, mission);
        
        RpcShowMessage(player.Owner, $"GÃ¶rev alÄ±ndÄ±: {missionDef.displayName}");
    }
    
    /// <summary>
    /// âœ… Mob Ã¶ldÃ¼rÃ¼ldÃ¼ (event)
    /// </summary>
    public void OnMobKilled(string playerId, string mobId) {
        if (!_activeMissions.ContainsKey(playerId)) return;
        
        foreach (var mission in _activeMissions[playerId]) {
            if (mission.definition.type == MissionType.KILL_MOB && 
                mission.definition.targetMobId == mobId) {
                mission.progress++;
                
                // âœ… GÃ¶rev tamamlandÄ± mÄ±?
                if (mission.progress >= mission.definition.targetCount) {
                    CompleteMission(playerId, mission);
                } else {
                    // âœ… Ä°lerleme gÃ¼ncelle
                    _databaseManager?.UpdateMissionProgressAsync(playerId, mission.missionId, mission.progress);
                    RpcUpdateMissionProgress(FindPlayerById(playerId)?.Owner, mission.missionId, mission.progress, mission.definition.targetCount);
                }
            }
        }
    }
    
    /// <summary>
    /// âœ… Item toplandÄ± (event)
    /// </summary>
    public void OnItemCollected(string playerId, string itemId, int quantity) {
        if (!_activeMissions.ContainsKey(playerId)) return;
        
        foreach (var mission in _activeMissions[playerId]) {
            if (mission.definition.type == MissionType.COLLECT_ITEM && 
                mission.definition.targetItemId == itemId) {
                mission.progress += quantity;
                
                // âœ… GÃ¶rev tamamlandÄ± mÄ±?
                if (mission.progress >= mission.definition.targetCount) {
                    CompleteMission(playerId, mission);
                } else {
                    _databaseManager?.UpdateMissionProgressAsync(playerId, mission.missionId, mission.progress);
                    RpcUpdateMissionProgress(FindPlayerById(playerId)?.Owner, mission.missionId, mission.progress, mission.definition.targetCount);
                }
            }
        }
    }
    
    /// <summary>
    /// âœ… Lokasyon ziyaret edildi (event)
    /// </summary>
    public void OnLocationVisited(string playerId, Vector3 location) {
        if (!_activeMissions.ContainsKey(playerId)) return;
        
        foreach (var mission in _activeMissions[playerId]) {
            if (mission.definition.type == MissionType.VISIT_LOCATION) {
                float distance = Vector3.Distance(location, mission.definition.targetLocation);
                if (distance <= mission.definition.targetLocationRadius) {
                    CompleteMission(playerId, mission);
                }
            }
        }
    }
    
    /// <summary>
    /// âœ… GÃ¶rev tamamlandÄ±
    /// </summary>
    void CompleteMission(string playerId, ActiveMission mission) {
        // âœ… Ã–dÃ¼l ver
        GiveRewards(playerId, mission.definition.rewards);
        
        // âœ… Cache'den kaldÄ±r
        _activeMissions[playerId].Remove(mission);
        
        // âœ… Database'den kaldÄ±r
        _databaseManager?.CompleteMissionAsync(playerId, mission.missionId);
        
        // âœ… Oyuncuya bildir
        var player = FindPlayerById(playerId);
        if (player != null) {
            RpcShowMessage(player.Owner, $"GÃ¶rev tamamlandÄ±: {mission.definition.displayName}!");
        }
    }
    
    /// <summary>
    /// âœ… Ã–dÃ¼l ver
    /// </summary>
    void GiveRewards(string playerId, RewardData rewards) {
        // âœ… AltÄ±n ver
        if (rewards.gold > 0) {
            _databaseManager?.AddGoldAsync(playerId, rewards.gold);
        }
        
        // âœ… Item ver
        foreach (var itemReward in rewards.items) {
            GiveItemToPlayer(playerId, itemReward.itemId, itemReward.quantity);
        }
    }
    
    /// <summary>
    /// âœ… Oyuncuya item ver
    /// </summary>
    void GiveItemToPlayer(string playerId, string itemId, int quantity) {
        // âœ… TODO: ItemManager entegrasyonu
        Debug.Log($"[MissionManager] {playerId} oyuncusuna {quantity}x {itemId} verildi");
    }
    
    /// <summary>
    /// âœ… Oyuncu bul (ID'den)
    /// </summary>
    NetworkObject FindPlayerById(string playerId) {
        foreach (var conn in ServerManager.Clients) {
            if (conn.ClientId.ToString() == playerId) {
                return conn.FirstObject;
            }
        }
        return null;
    }
    
    /// <summary>
    /// âœ… RPC: Mesaj gÃ¶ster
    /// </summary>
    [TargetRpc]
    void RpcShowMessage(NetworkConnection conn, string message) {
        Debug.Log($"[MissionManager] {message}");
    }
    
    /// <summary>
    /// âœ… RPC: GÃ¶rev ilerlemesi gÃ¼ncelle
    /// </summary>
    [TargetRpc]
    void RpcUpdateMissionProgress(NetworkConnection conn, string missionId, int progress, int target) {
        Debug.Log($"[MissionManager] GÃ¶rev ilerlemesi: {progress}/{target}");
    }
    
    /// <summary>
    /// âœ… Aktif gÃ¶rev data yapÄ±sÄ±
    /// </summary>
    class ActiveMission {
        public string missionId;
        public MissionDefinition definition;
        public int progress;
        public float startTime;
    }
}

/// <summary>
/// âœ… GÃ¶rev tanÄ±mÄ± (ScriptableObject)
/// </summary>
[CreateAssetMenu(menuName = "Stratocraft/Mission")]
public class MissionDefinition : ScriptableObject {
    [Header("Kimlik")]
    public string missionId;
    public string displayName;
    [TextArea(3, 5)]
    public string description;
    
    [Header("GÃ¶rev Tipi")]
    public MissionType type;
    public DifficultyLevel difficulty;
    
    [Header("Hedefler")]
    public int targetCount;
    public string targetMobId; // KILL_MOB iÃ§in
    public string targetItemId; // COLLECT_ITEM iÃ§in
    public Vector3 targetLocation; // VISIT_LOCATION iÃ§in
    public float targetLocationRadius = 10f;
    
    [Header("Ã–dÃ¼ller")]
    public RewardData rewards;
    
    public enum MissionType {
        KILL_MOB,
        COLLECT_ITEM,
        VISIT_LOCATION,
        CRAFT_ITEM,
        KILL_BOSS,
        COLLECT_RESOURCE,
        BUILD_STRUCTURE,
        COMPLETE_RITUAL
    }
    
    public enum DifficultyLevel {
        EASY,
        MEDIUM,
        HARD,
        EXPERT
    }
}

/// <summary>
/// âœ… Ã–dÃ¼l data yapÄ±sÄ±
/// </summary>
[System.Serializable]
public class RewardData {
    public int gold;
    public List<ItemReward> items = new List<ItemReward>();
}

/// <summary>
/// âœ… Item Ã¶dÃ¼l yapÄ±sÄ±
/// </summary>
[System.Serializable]
public class ItemReward {
    public string itemId;
    public int quantity;
}
```

**Optimizasyon:**
- âœ… Dictionary cache (aktif gÃ¶revler, gÃ¶rev tanÄ±mlarÄ±)
- âœ… Event-based progress tracking (otomatik ilerleme)
- âœ… ChunkManager entegrasyonu (voxel terrain kontrolÃ¼)

**Referanslar:**
- [Unity Event System](https://docs.unity3d.com/Manual/UnityEvents.html)

**KÃ¼tÃ¼phane:** Unity Event System (yerleÅŸik)

---

### 1.5.1 MissionDatabase (O(1) Lookup)

**Dosya:** `Assets/_Stratocraft/Scripts/Core/Databases/MissionDatabase.cs`

**Ã–zellikler:**
- MissionDefinition ScriptableObject lookup (O(1))
- Dictionary cache sistemi
- ServiceLocator entegrasyonu
- Zorluk ve tip bazlÄ± filtreleme

**Kod:**

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: GÃ¶rev veritabanÄ± - MissionDefinition lookup (O(1))
/// </summary>
public class MissionDatabase : MonoBehaviour {
    [Header("GÃ¶rev TanÄ±mlarÄ±")]
    public List<MissionDefinition> allMissions = new List<MissionDefinition>();
    
    // âœ… OPTÄ°MÄ°ZE: Dictionary cache (O(1) lookup)
    private Dictionary<string, MissionDefinition> _missionCache = new Dictionary<string, MissionDefinition>();
    
    private static MissionDatabase _instance;
    public static MissionDatabase Instance {
        get {
            if (_instance == null) {
                _instance = FindObjectOfType<MissionDatabase>();
            }
            return _instance;
        }
    }
    
    void Awake() {
        if (_instance == null) {
            _instance = this;
            DontDestroyOnLoad(gameObject);
        } else if (_instance != this) {
            Destroy(gameObject);
            return;
        }
        
        // âœ… Cache'i doldur
        BuildCache();
        
        // âœ… ServiceLocator'a kaydet
        ServiceLocator.Instance?.Register<MissionDatabase>(this);
    }
    
    /// <summary>
    /// âœ… Cache'i oluÅŸtur
    /// </summary>
    void BuildCache() {
        _missionCache.Clear();
        foreach (var mission in allMissions) {
            if (mission != null && !string.IsNullOrEmpty(mission.missionId)) {
                _missionCache[mission.missionId] = mission;
            }
        }
        Debug.Log($"[MissionDatabase] {_missionCache.Count} gÃ¶rev cache'lendi.");
    }
    
    /// <summary>
    /// âœ… MissionDefinition al (O(1) lookup)
    /// </summary>
    public MissionDefinition GetMission(string missionId) {
        if (string.IsNullOrEmpty(missionId)) return null;
        
        if (_missionCache.TryGetValue(missionId, out MissionDefinition mission)) {
            return mission;
        }
        
        Debug.LogWarning($"[MissionDatabase] GÃ¶rev bulunamadÄ±: {missionId}");
        return null;
    }
    
    /// <summary>
    /// âœ… TÃ¼m gÃ¶revleri al
    /// </summary>
    public List<MissionDefinition> GetAllMissions() {
        return allMissions.ToList();
    }
    
    /// <summary>
    /// âœ… Zorluk seviyesine gÃ¶re gÃ¶revleri al
    /// </summary>
    public List<MissionDefinition> GetMissionsByDifficulty(MissionDefinition.DifficultyLevel difficulty) {
        return allMissions.Where(m => m.difficulty == difficulty).ToList();
    }
    
    /// <summary>
    /// âœ… GÃ¶rev tipine gÃ¶re gÃ¶revleri al
    /// </summary>
    public List<MissionDefinition> GetMissionsByType(MissionDefinition.MissionType type) {
        return allMissions.Where(m => m.type == type).ToList();
    }
}
```

**Optimizasyon:**
- âœ… Dictionary cache (O(1) lookup)
- âœ… Singleton pattern (ServiceLocator entegrasyonu)
- âœ… LINQ filtering (zorluk ve tip bazlÄ± filtreleme)

**Referanslar:**
- ItemDatabase.cs, MobDatabase.cs, BossDatabase.cs (aynÄ± pattern)

**KÃ¼tÃ¼phane:** Unity ScriptableObject (yerleÅŸik), LINQ (System.Linq)

---

### 1.5.2 DisasterDatabase (O(1) Lookup)

**Dosya:** `Assets/_Stratocraft/Scripts/Core/Databases/DisasterDatabase.cs`

**Ã–zellikler:**
- DisasterDefinition ScriptableObject lookup (O(1))
- Dictionary cache sistemi
- ServiceLocator entegrasyonu
- Kategori ve zamanlama bazlÄ± filtreleme

**Kod:**

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Felaket veritabanÄ± - DisasterDefinition lookup (O(1))
/// </summary>
public class DisasterDatabase : MonoBehaviour {
    [Header("Felaket TanÄ±mlarÄ±")]
    public List<DisasterDefinition> allDisasters = new List<DisasterDefinition>();
    
    // âœ… OPTÄ°MÄ°ZE: Dictionary cache (O(1) lookup)
    private Dictionary<string, DisasterDefinition> _disasterCache = new Dictionary<string, DisasterDefinition>();
    
    private static DisasterDatabase _instance;
    public static DisasterDatabase Instance {
        get {
            if (_instance == null) {
                _instance = FindObjectOfType<DisasterDatabase>();
            }
            return _instance;
        }
    }
    
    void Awake() {
        if (_instance == null) {
            _instance = this;
            DontDestroyOnLoad(gameObject);
        } else if (_instance != this) {
            Destroy(gameObject);
            return;
        }
        
        // âœ… Cache'i doldur
        BuildCache();
        
        // âœ… ServiceLocator'a kaydet
        ServiceLocator.Instance?.Register<DisasterDatabase>(this);
    }
    
    /// <summary>
    /// âœ… Cache'i oluÅŸtur
    /// </summary>
    void BuildCache() {
        _disasterCache.Clear();
        foreach (var disaster in allDisasters) {
            if (disaster != null && !string.IsNullOrEmpty(disaster.disasterId)) {
                _disasterCache[disaster.disasterId] = disaster;
            }
        }
        Debug.Log($"[DisasterDatabase] {_disasterCache.Count} felaket cache'lendi.");
    }
    
    /// <summary>
    /// âœ… DisasterDefinition al (O(1) lookup)
    /// </summary>
    public DisasterDefinition GetDisaster(string disasterId) {
        if (string.IsNullOrEmpty(disasterId)) return null;
        
        if (_disasterCache.TryGetValue(disasterId, out DisasterDefinition disaster)) {
            return disaster;
        }
        
        Debug.LogWarning($"[DisasterDatabase] Felaket bulunamadÄ±: {disasterId}");
        return null;
    }
    
    /// <summary>
    /// âœ… TÃ¼m felaketleri al
    /// </summary>
    public List<DisasterDefinition> GetAllDisasters() {
        return allDisasters.ToList();
    }
    
    /// <summary>
    /// âœ… Kategoriye gÃ¶re felaketleri al
    /// </summary>
    public List<DisasterDefinition> GetDisastersByCategory(DisasterDefinition.DisasterCategory category) {
        return allDisasters.Where(d => d.category == category).ToList();
    }
    
    /// <summary>
    /// âœ… Zamanlamaya gÃ¶re felaketleri al
    /// </summary>
    public List<DisasterDefinition> GetDisastersBySchedule(DisasterDefinition.DisasterSchedule schedule) {
        return allDisasters.Where(d => d.schedule == schedule).ToList();
    }
    
    /// <summary>
    /// âœ… Seviyeye gÃ¶re felaketleri al
    /// </summary>
    public List<DisasterDefinition> GetDisastersByLevel(int level) {
        return allDisasters.Where(d => d.categoryLevel == level).ToList();
    }
}
```

**Optimizasyon:**
- âœ… Dictionary cache (O(1) lookup)
- âœ… Singleton pattern (ServiceLocator entegrasyonu)
- âœ… LINQ filtering (kategori, zamanlama ve seviye bazlÄ± filtreleme)

**Referanslar:**
- ItemDatabase.cs, MobDatabase.cs, BossDatabase.cs, MissionDatabase.cs (aynÄ± pattern)

**KÃ¼tÃ¼phane:** Unity ScriptableObject (yerleÅŸik), LINQ (System.Linq)

---

### 1.5.3 TrapDatabase (O(1) Lookup)

**Dosya:** `Assets/_Stratocraft/Scripts/Core/Databases/TrapDatabase.cs`

**Ã–zellikler:**
- TrapDefinition ScriptableObject lookup (O(1))
- Dictionary cache sistemi
- ServiceLocator entegrasyonu
- Tip ve seviye bazlÄ± filtreleme

**Kod:**

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Tuzak veritabanÄ± - TrapDefinition lookup (O(1))
/// </summary>
public class TrapDatabase : MonoBehaviour {
    [Header("Tuzak TanÄ±mlarÄ±")]
    public List<TrapDefinition> allTraps = new List<TrapDefinition>();
    
    // âœ… OPTÄ°MÄ°ZE: Dictionary cache (O(1) lookup)
    private Dictionary<string, TrapDefinition> _trapCache = new Dictionary<string, TrapDefinition>();
    
    private static TrapDatabase _instance;
    public static TrapDatabase Instance {
        get {
            if (_instance == null) {
                _instance = FindObjectOfType<TrapDatabase>();
            }
            return _instance;
        }
    }
    
    void Awake() {
        if (_instance == null) {
            _instance = this;
            DontDestroyOnLoad(gameObject);
        } else if (_instance != this) {
            Destroy(gameObject);
            return;
        }
        
        // âœ… Cache'i doldur
        BuildCache();
        
        // âœ… ServiceLocator'a kaydet
        ServiceLocator.Instance?.Register<TrapDatabase>(this);
    }
    
    /// <summary>
    /// âœ… Cache'i oluÅŸtur
    /// </summary>
    void BuildCache() {
        _trapCache.Clear();
        foreach (var trap in allTraps) {
            if (trap != null && !string.IsNullOrEmpty(trap.trapId)) {
                _trapCache[trap.trapId] = trap;
            }
        }
        Debug.Log($"[TrapDatabase] {_trapCache.Count} tuzak cache'lendi.");
    }
    
    /// <summary>
    /// âœ… TrapDefinition al (O(1) lookup)
    /// </summary>
    public TrapDefinition GetTrap(string trapId) {
        if (string.IsNullOrEmpty(trapId)) return null;
        
        if (_trapCache.TryGetValue(trapId, out TrapDefinition trap)) {
            return trap;
        }
        
        Debug.LogWarning($"[TrapDatabase] Tuzak bulunamadÄ±: {trapId}");
        return null;
    }
    
    /// <summary>
    /// âœ… TÃ¼m tuzaklarÄ± al
    /// </summary>
    public List<TrapDefinition> GetAllTraps() {
        return allTraps.ToList();
    }
    
    /// <summary>
    /// âœ… Tipe gÃ¶re tuzaklarÄ± al
    /// </summary>
    public List<TrapDefinition> GetTrapsByType(TrapDefinition.TrapType type) {
        return allTraps.Where(t => t.type == type).ToList();
    }
    
    /// <summary>
    /// âœ… Seviyeye gÃ¶re tuzaklarÄ± al
    /// </summary>
    public List<TrapDefinition> GetTrapsByLevel(int level) {
        return allTraps.Where(t => t.level == level).ToList();
    }
}
```

**Optimizasyon:**
- âœ… Dictionary cache (O(1) lookup)
- âœ… Singleton pattern (ServiceLocator entegrasyonu)
- âœ… LINQ filtering (tip ve seviye bazlÄ± filtreleme)

**Referanslar:**
- ItemDatabase.cs, MobDatabase.cs, BossDatabase.cs, MissionDatabase.cs, DisasterDatabase.cs (aynÄ± pattern)

**KÃ¼tÃ¼phane:** Unity ScriptableObject (yerleÅŸik), LINQ (System.Linq)

---

### 1.5.4 RideableMobDatabase (O(1) Lookup)

**Dosya:** `Assets/_Stratocraft/Scripts/Core/Databases/RideableMobDatabase.cs`

**Ã–zellikler:**
- RideableMobDefinition ScriptableObject lookup (O(1))
- Dictionary cache sistemi
- ServiceLocator entegrasyonu
- EÄŸitme zorluk ve binilebilirlik bazlÄ± filtreleme

**Kod:**

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Binilebilir mob veritabanÄ± - RideableMobDefinition lookup (O(1))
/// </summary>
public class RideableMobDatabase : MonoBehaviour {
    [Header("Binilebilir Mob TanÄ±mlarÄ±")]
    public List<RideableMobDefinition> allRideableMobs = new List<RideableMobDefinition>();
    
    // âœ… OPTÄ°MÄ°ZE: Dictionary cache (O(1) lookup)
    private Dictionary<string, RideableMobDefinition> _rideableMobCache = new Dictionary<string, RideableMobDefinition>();
    
    private static RideableMobDatabase _instance;
    public static RideableMobDatabase Instance {
        get {
            if (_instance == null) {
                _instance = FindObjectOfType<RideableMobDatabase>();
            }
            return _instance;
        }
    }
    
    void Awake() {
        if (_instance == null) {
            _instance = this;
            DontDestroyOnLoad(gameObject);
        } else if (_instance != this) {
            Destroy(gameObject);
            return;
        }
        
        // âœ… Cache'i doldur
        BuildCache();
        
        // âœ… ServiceLocator'a kaydet
        ServiceLocator.Instance?.Register<RideableMobDatabase>(this);
    }
    
    /// <summary>
    /// âœ… Cache'i oluÅŸtur
    /// </summary>
    void BuildCache() {
        _rideableMobCache.Clear();
        foreach (var mob in allRideableMobs) {
            if (mob != null && !string.IsNullOrEmpty(mob.mobId)) {
                _rideableMobCache[mob.mobId] = mob;
            }
        }
        Debug.Log($"[RideableMobDatabase] {_rideableMobCache.Count} binilebilir mob cache'lendi.");
    }
    
    /// <summary>
    /// âœ… RideableMobDefinition al (O(1) lookup)
    /// </summary>
    public RideableMobDefinition GetRideableMob(string mobId) {
        if (string.IsNullOrEmpty(mobId)) return null;
        
        if (_rideableMobCache.TryGetValue(mobId, out RideableMobDefinition mob)) {
            return mob;
        }
        
        Debug.LogWarning($"[RideableMobDatabase] Binilebilir mob bulunamadÄ±: {mobId}");
        return null;
    }
    
    /// <summary>
    /// âœ… TÃ¼m binilebilir moblarÄ± al
    /// </summary>
    public List<RideableMobDefinition> GetAllRideableMobs() {
        return allRideableMobs.ToList();
    }
    
    /// <summary>
    /// âœ… EÄŸitme zorluÄŸuna gÃ¶re moblarÄ± al
    /// </summary>
    public List<RideableMobDefinition> GetRideableMobsByDifficulty(int difficulty) {
        return allRideableMobs.Where(m => m.tamingDifficulty == difficulty).ToList();
    }
    
    /// <summary>
    /// âœ… Binilebilir moblarÄ± al
    /// </summary>
    public List<RideableMobDefinition> GetRideableMobs(bool isRideable) {
        return allRideableMobs.Where(m => m.isRideable == isRideable).ToList();
    }
}
```

**Optimizasyon:**
- âœ… Dictionary cache (O(1) lookup)
- âœ… Singleton pattern (ServiceLocator entegrasyonu)
- âœ… LINQ filtering (zorluk ve binilebilirlik bazlÄ± filtreleme)

**Referanslar:**
- ItemDatabase.cs, MobDatabase.cs, BossDatabase.cs, MissionDatabase.cs, DisasterDatabase.cs, TrapDatabase.cs (aynÄ± pattern)

**KÃ¼tÃ¼phane:** Unity ScriptableObject (yerleÅŸik), LINQ (System.Linq)

---

### 1.5.5 StructureEffectDatabase (O(1) Lookup)

**Dosya:** `Assets/_Stratocraft/Scripts/Core/Databases/StructureEffectDatabase.cs`

**Ã–zellikler:**
- StructureEffectDefinition ScriptableObject lookup (O(1))
- Dictionary cache sistemi
- ServiceLocator entegrasyonu
- YapÄ± tipi ve efekt tipi bazlÄ± filtreleme

**Kod:**

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: YapÄ± efekt veritabanÄ± - StructureEffectDefinition lookup (O(1))
/// </summary>
public class StructureEffectDatabase : MonoBehaviour {
    [Header("YapÄ± Efekt TanÄ±mlarÄ±")]
    public List<StructureEffectDefinition> allStructureEffects = new List<StructureEffectDefinition>();
    
    // âœ… OPTÄ°MÄ°ZE: Dictionary cache (O(1) lookup)
    private Dictionary<string, StructureEffectDefinition> _structureEffectCache = new Dictionary<string, StructureEffectDefinition>();
    
    private static StructureEffectDatabase _instance;
    public static StructureEffectDatabase Instance {
        get {
            if (_instance == null) {
                _instance = FindObjectOfType<StructureEffectDatabase>();
            }
            return _instance;
        }
    }
    
    void Awake() {
        if (_instance == null) {
            _instance = this;
            DontDestroyOnLoad(gameObject);
        } else if (_instance != this) {
            Destroy(gameObject);
            return;
        }
        
        // âœ… Cache'i doldur
        BuildCache();
        
        // âœ… ServiceLocator'a kaydet
        ServiceLocator.Instance?.Register<StructureEffectDatabase>(this);
    }
    
    /// <summary>
    /// âœ… Cache'i oluÅŸtur
    /// </summary>
    void BuildCache() {
        _structureEffectCache.Clear();
        foreach (var effect in allStructureEffects) {
            if (effect != null && !string.IsNullOrEmpty(effect.structureType)) {
                _structureEffectCache[effect.structureType] = effect;
            }
        }
        Debug.Log($"[StructureEffectDatabase] {_structureEffectCache.Count} yapÄ± efekt cache'lendi.");
    }
    
    /// <summary>
    /// âœ… StructureEffectDefinition al (O(1) lookup)
    /// </summary>
    public StructureEffectDefinition GetEffectByStructureType(string structureType) {
        if (string.IsNullOrEmpty(structureType)) return null;
        
        if (_structureEffectCache.TryGetValue(structureType, out StructureEffectDefinition effect)) {
            return effect;
        }
        
        Debug.LogWarning($"[StructureEffectDatabase] YapÄ± efekt bulunamadÄ±: {structureType}");
        return null;
    }
    
    /// <summary>
    /// âœ… TÃ¼m yapÄ± efektlerini al
    /// </summary>
    public List<StructureEffectDefinition> GetAllStructureEffects() {
        return allStructureEffects.ToList();
    }
    
    /// <summary>
    /// âœ… Efekt tipine gÃ¶re yapÄ± efektlerini al
    /// </summary>
    public List<StructureEffectDefinition> GetEffectsByType(StructureEffectDefinition.StructureEffectType type) {
        return allStructureEffects.Where(e => e.type == type).ToList();
    }
}
```

**Optimizasyon:**
- âœ… Dictionary cache (O(1) lookup)
- âœ… Singleton pattern (ServiceLocator entegrasyonu)
- âœ… LINQ filtering (yapÄ± tipi ve efekt tipi bazlÄ± filtreleme)

**Referanslar:**
- ItemDatabase.cs, MobDatabase.cs, BossDatabase.cs, MissionDatabase.cs, DisasterDatabase.cs, TrapDatabase.cs, RideableMobDatabase.cs (aynÄ± pattern)

**KÃ¼tÃ¼phane:** Unity ScriptableObject (yerleÅŸik), LINQ (System.Linq)

---

### 1.6 SUPPLY DROP SÄ°STEMÄ° (Supply Drop System)

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Events/SupplyDropManager.cs`

**Ã–zellikler:**
- GÃ¶kyÃ¼zÃ¼nden dÃ¼ÅŸen hazine sandÄ±klarÄ±
- Ä°lk bulan alÄ±r
- Garantili: 5-10 Diamond, 3-5 Emerald, 1-2 Netherite
- Rastgele: Elytra (%5), Notch Apple (%10), Tarif KitabÄ± (%2)

**Teknolojiler:**
- **FishNet** - NetworkObject senkronizasyonu
- **Unity Animation** - ParaÅŸÃ¼t animasyonu
- **DoTween** - DÃ¼ÅŸÃ¼ÅŸ animasyonu
- **ScriptableObject** - Loot table

**Kod:**

```csharp
using UnityEngine;
using FishNet.Object;
using System.Collections;
using System.Collections.Generic;
using DG.Tweening; // DoTween

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Supply Drop yÃ¶neticisi - GÃ¶kyÃ¼zÃ¼nden dÃ¼ÅŸen hazine sandÄ±klarÄ±
/// Voxel terrain Ã¼zerinde spawn ve ilk bulan alÄ±r sistemi
/// </summary>
public class SupplyDropManager : NetworkBehaviour {
    [Header("Ayarlar")]
    [Tooltip("Supply Drop spawn aralÄ±ÄŸÄ± (saniye)")]
    [Range(60f, 600f)]
    public float spawnInterval = 300f; // 5 dakika
    
    [Tooltip("Spawn yÃ¼ksekliÄŸi")]
    [Range(50f, 200f)]
    public float spawnHeight = 100f;
    
    [Tooltip("DÃ¼ÅŸÃ¼ÅŸ sÃ¼resi (saniye)")]
    [Range(3f, 10f)]
    public float fallDuration = 5f;
    
    [Header("Loot AyarlarÄ±")]
    [Tooltip("Garantili Diamond miktarÄ± (min-max)")]
    public Vector2Int guaranteedDiamond = new Vector2Int(5, 10);
    
    [Tooltip("Garantili Emerald miktarÄ± (min-max)")]
    public Vector2Int guaranteedEmerald = new Vector2Int(3, 5);
    
    [Tooltip("Garantili Netherite miktarÄ± (min-max)")]
    public Vector2Int guaranteedNetherite = new Vector2Int(1, 2);
    
    [Tooltip("Elytra spawn ÅŸansÄ±")]
    [Range(0f, 1f)]
    public float elytraChance = 0.05f;
    
    [Tooltip("Notch Apple spawn ÅŸansÄ±")]
    [Range(0f, 1f)]
    public float notchAppleChance = 0.10f;
    
    [Tooltip("Recipe Book spawn ÅŸansÄ±")]
    [Range(0f, 1f)]
    public float recipeBookChance = 0.02f;
    
    // âœ… OPTÄ°MÄ°ZE: Aktif supply drop'lar cache
    private Dictionary<string, SupplyDropData> _activeDrops = new Dictionary<string, SupplyDropData>();
    
    private ChunkManager _chunkManager;
    private float _lastSpawnTime;
    
    void Awake() {
        ServiceLocator.Instance?.Register<SupplyDropManager>(this);
    }
    
    void Start() {
        if (!IsServer) return;
        
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        _lastSpawnTime = Time.time;
    }
    
    void Update() {
        if (!IsServer) return;
        
        // âœ… Periyodik spawn kontrolÃ¼
        if (Time.time - _lastSpawnTime >= spawnInterval) {
            SpawnRandomSupplyDrop();
            _lastSpawnTime = Time.time;
        }
    }
    
    /// <summary>
    /// âœ… Rastgele Supply Drop spawn et
    /// </summary>
    void SpawnRandomSupplyDrop() {
        // âœ… Aktif oyuncularÄ±n pozisyonlarÄ±ndan rastgele birini seÃ§
        List<Vector3> playerPositions = GetActivePlayerPositions();
        if (playerPositions.Count == 0) return;
        
        Vector3 spawnPos = playerPositions[Random.Range(0, playerPositions.Count)];
        spawnPos += Random.insideUnitSphere * 500f; // 500 blok yarÄ±Ã§ap
        
        // âœ… Voxel terrain Ã¼zerinde zemin pozisyonunu bul
        Vector3 groundPos = GetGroundPosition(spawnPos);
        if (groundPos == Vector3.zero) return;
        
        // âœ… Supply Drop spawn et
        SpawnSupplyDrop(groundPos);
    }
    
    /// <summary>
    /// âœ… Supply Drop spawn et
    /// </summary>
    public void SpawnSupplyDrop(Vector3 position) {
        GameObject dropPrefab = Resources.Load<GameObject>("Prefabs/SupplyDrop");
        if (dropPrefab == null) {
            Debug.LogError("[SupplyDropManager] SupplyDrop prefab bulunamadÄ±!");
            return;
        }
        
        // âœ… YÃ¼ksekten spawn et
        Vector3 spawnPos = position + Vector3.up * spawnHeight;
        GameObject dropObj = Instantiate(dropPrefab, spawnPos, Quaternion.identity);
        NetworkObject dropNet = dropObj.GetComponent<NetworkObject>();
        if (dropNet == null) {
            dropNet = dropObj.AddComponent<NetworkObject>();
        }
        Spawn(dropNet);
        
        // âœ… Loot table'dan Ã¶dÃ¼l belirle
        LootData loot = GenerateLoot();
        SupplyDrop dropComponent = dropObj.GetComponent<SupplyDrop>();
        if (dropComponent == null) {
            dropComponent = dropObj.AddComponent<SupplyDrop>();
        }
        dropComponent.Initialize(loot, this);
        
        // âœ… ParaÅŸÃ¼t animasyonu (DoTween)
        dropObj.transform.DOMove(position, fallDuration).SetEase(DG.Tweening.Ease.InQuad);
        
        // âœ… Cache'e ekle
        string dropId = System.Guid.NewGuid().ToString();
        _activeDrops[dropId] = new SupplyDropData {
            dropId = dropId,
            dropObject = dropObj,
            position = position,
            loot = loot,
            isClaimed = false
        };
        
        // âœ… TÃ¼m oyunculara bildir
        RpcBroadcastSupplyDrop(position);
        
        Debug.Log($"[SupplyDropManager] Supply Drop spawn edildi: {position}");
    }
    
    /// <summary>
    /// âœ… Loot oluÅŸtur
    /// </summary>
    LootData GenerateLoot() {
        LootData loot = new LootData();
        
        // âœ… Garantili Ã¶dÃ¼ller
        loot.items.Add(new ItemData { 
            itemId = "DIAMOND", 
            quantity = Random.Range(guaranteedDiamond.x, guaranteedDiamond.y + 1) 
        });
        loot.items.Add(new ItemData { 
            itemId = "EMERALD", 
            quantity = Random.Range(guaranteedEmerald.x, guaranteedEmerald.y + 1) 
        });
        loot.items.Add(new ItemData { 
            itemId = "NETHERITE", 
            quantity = Random.Range(guaranteedNetherite.x, guaranteedNetherite.y + 1) 
        });
        
        // âœ… Rastgele Ã¶dÃ¼ller
        if (Random.Range(0f, 1f) < elytraChance) {
            loot.items.Add(new ItemData { itemId = "ELYTRA", quantity = 1 });
        }
        if (Random.Range(0f, 1f) < notchAppleChance) {
            loot.items.Add(new ItemData { itemId = "NOTCH_APPLE", quantity = 1 });
        }
        if (Random.Range(0f, 1f) < recipeBookChance) {
            loot.items.Add(new ItemData { itemId = "RECIPE_BOOK", quantity = 1 });
        }
        
        return loot;
    }
    
    /// <summary>
    /// âœ… Supply Drop claim et (ilk bulan alÄ±r)
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void CmdClaimSupplyDrop(NetworkObject player, GameObject dropObject) {
        if (player == null || dropObject == null) return;
        
        // âœ… Drop bul
        SupplyDrop dropComponent = dropObject.GetComponent<SupplyDrop>();
        if (dropComponent == null) return;
        
        string dropId = dropComponent.dropId;
        if (!_activeDrops.TryGetValue(dropId, out SupplyDropData dropData)) {
            return;
        }
        
        // âœ… Zaten claim edilmiÅŸ mi?
        if (dropData.isClaimed) {
            RpcShowMessage(player.Owner, "Bu Supply Drop zaten alÄ±nmÄ±ÅŸ!");
            return;
        }
        
        // âœ… Mesafe kontrolÃ¼
        float distance = Vector3.Distance(player.transform.position, dropData.position);
        if (distance > 5f) {
            RpcShowMessage(player.Owner, "Supply Drop'a Ã§ok uzaksÄ±n!");
            return;
        }
        
        // âœ… Claim et
        dropData.isClaimed = true;
        
        // âœ… Ã–dÃ¼lleri ver
        string playerId = player.OwnerId.ToString();
        foreach (var item in dropData.loot.items) {
            GiveItemToPlayer(playerId, item.itemId, item.quantity);
        }
        
        // âœ… Drop'u yok et
        NetworkObject dropNet = dropObject.GetComponent<NetworkObject>();
        if (dropNet != null) {
            Despawn(dropNet);
        } else {
            Destroy(dropObject);
        }
        
        // âœ… Cache'den kaldÄ±r
        _activeDrops.Remove(dropId);
        
        RpcShowMessage(player.Owner, "Supply Drop alÄ±ndÄ±!");
    }
    
    /// <summary>
    /// âœ… Voxel terrain Ã¼zerinde zemin pozisyonunu bul
    /// </summary>
    Vector3 GetGroundPosition(Vector3 position) {
        // âœ… Raycast ile voxel terrain'e bak
        RaycastHit hit;
        if (Physics.Raycast(position + Vector3.up * 50f, Vector3.down, out hit, 200f)) {
            if (hit.collider.gameObject.GetComponent<MarchingCubesGPU>() != null) {
                return hit.point;
            }
        }
        
        return Vector3.zero;
    }
    
    /// <summary>
    /// âœ… Aktif oyuncu pozisyonlarÄ±nÄ± al
    /// </summary>
    List<Vector3> GetActivePlayerPositions() {
        List<Vector3> positions = new List<Vector3>();
        
        foreach (var conn in ServerManager.Clients) {
            if (conn.FirstObject != null) {
                positions.Add(conn.FirstObject.transform.position);
            }
        }
        
        return positions;
    }
    
    /// <summary>
    /// âœ… Oyuncuya item ver
    /// </summary>
    void GiveItemToPlayer(string playerId, string itemId, int quantity) {
        // âœ… TODO: ItemManager entegrasyonu
        Debug.Log($"[SupplyDropManager] {playerId} oyuncusuna {quantity}x {itemId} verildi");
    }
    
    /// <summary>
    /// âœ… RPC: TÃ¼m oyunculara Supply Drop bildir
    /// </summary>
    [ObserversRpc]
    void RpcBroadcastSupplyDrop(Vector3 position) {
        Debug.Log($"[SupplyDropManager] Yeni Supply Drop: {position}");
        // âœ… UI'da bildirim gÃ¶ster
    }
    
    /// <summary>
    /// âœ… RPC: Mesaj gÃ¶ster
    /// </summary>
    [TargetRpc]
    void RpcShowMessage(NetworkConnection conn, string message) {
        Debug.Log($"[SupplyDropManager] {message}");
    }
    
    /// <summary>
    /// âœ… Supply Drop data yapÄ±sÄ±
    /// </summary>
    class SupplyDropData {
        public string dropId;
        public GameObject dropObject;
        public Vector3 position;
        public LootData loot;
        public bool isClaimed;
    }
    
    /// <summary>
    /// âœ… Loot data yapÄ±sÄ±
    /// </summary>
    [System.Serializable]
    public class LootData {
        public List<ItemData> items = new List<ItemData>();
    }
    
    /// <summary>
    /// âœ… Item data yapÄ±sÄ±
    /// </summary>
    [System.Serializable]
    public class ItemData {
        public string itemId;
        public int quantity;
    }
}

/// <summary>
/// âœ… Supply Drop component
/// </summary>
public class SupplyDrop : NetworkBehaviour {
    private LootData _loot;
    private SupplyDropManager _manager;
    private string _dropId;
    
    public void Initialize(LootData loot, SupplyDropManager manager) {
        _loot = loot;
        _manager = manager;
        _dropId = System.Guid.NewGuid().ToString();
    }
    
    public string dropId => _dropId;
    
    void OnTriggerEnter(Collider other) {
        if (!IsServer) return;
        
        NetworkObject player = other.GetComponent<NetworkObject>();
        if (player != null && player.IsOwner) {
            _manager?.CmdClaimSupplyDrop(player, gameObject);
        }
    }
}
```

**Optimizasyon:**
- âœ… Dictionary cache (aktif supply drop'lar)
- âœ… ChunkManager entegrasyonu (voxel terrain kontrolÃ¼)
- âœ… DoTween animasyonu (performanslÄ± dÃ¼ÅŸÃ¼ÅŸ animasyonu)

**Referanslar:**
- [DoTween Documentation](http://dotween.demigiant.com/documentation.php)
- [Unity Physics Raycast](https://docs.unity3d.com/ScriptReference/Physics.Raycast.html)

**KÃ¼tÃ¼phane:** DoTween (Asset Store - Free)

---

### 1.7 KUÅATMA SÄ°LAHLARI (Siege Weapons)

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Combat/SiegeWeaponManager.cs`

**Ã–zellikler:**
- **Balista**: Binilir, sol tÄ±kla = ateÅŸ et, 30 mermi ÅŸarjÃ¶r, 15sn yenileme
- **MancÄ±nÄ±k**: Binilir, magma bloÄŸu fÄ±rlatÄ±r, alan hasarÄ±, 10sn cooldown

**Teknolojiler:**
- **FishNet** - Ownership transfer (binme)
- **Unity Physics** - Projectile physics (Rigidbody)
- **Unity Particle System** - Patlama efektleri

**Kod:**

```csharp
using UnityEngine;
using FishNet.Object;
using System.Collections.Generic;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: KuÅŸatma silahÄ± yÃ¶neticisi - Balista ve MancÄ±nÄ±k
/// Voxel terrain Ã¼zerinde projectile physics ile hasar sistemi
/// </summary>
public class SiegeWeaponManager : NetworkBehaviour {
    [Header("Ayarlar")]
    [Tooltip("Balista mermi hÄ±zÄ±")]
    [Range(10f, 100f)]
    public float ballistaBoltSpeed = 50f;
    
    [Tooltip("MancÄ±nÄ±k projectile hÄ±zÄ±")]
    [Range(5f, 50f)]
    public float catapultProjectileSpeed = 20f;
    
    [Tooltip("MancÄ±nÄ±k alan hasarÄ± yarÄ±Ã§apÄ±")]
    [Range(1f, 20f)]
    public float catapultAoERadius = 5f;
    
    // âœ… OPTÄ°MÄ°ZE: Aktif silahlar cache
    private Dictionary<string, SiegeWeaponData> _activeWeapons = new Dictionary<string, SiegeWeaponData>();
    
    private ChunkManager _chunkManager; // Voxel terrain entegrasyonu
    
    void Awake() {
        ServiceLocator.Instance?.Register<SiegeWeaponManager>(this);
    }
    
    void Start() {
        if (!IsServer) return;
        
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        
        if (_chunkManager == null) {
            Debug.LogError("[SiegeWeaponManager] ChunkManager bulunamadÄ±!");
        }
    }
}

/// <summary>
/// âœ… Balista component
/// </summary>
public class Ballista : NetworkBehaviour, IInteractable {
    [Header("Ayarlar")]
    [Tooltip("Maksimum mermi sayÄ±sÄ±")]
    [Range(1, 100)]
    public int maxAmmo = 30;
    
    [Tooltip("Yenileme sÃ¼resi (saniye)")]
    [Range(1f, 60f)]
    public float reloadTime = 15f;
    
    [Tooltip("AteÅŸ noktasÄ±")]
    public Transform firePoint;
    
    [Tooltip("Mermi prefab'Ä±")]
    public GameObject boltPrefab;
    
    private int _ammoCount;
    private float _lastFireTime;
    private NetworkObject _currentRider;
    private SiegeWeaponManager _weaponManager;
    
    void Start() {
        _ammoCount = maxAmmo;
        _weaponManager = ServiceLocator.Instance?.Get<SiegeWeaponManager>();
    }
    
    void Update() {
        if (!IsServer) return;
        if (_currentRider == null || !_currentRider.IsOwner) return;
        
        // âœ… Sol tÄ±kla ateÅŸ et
        // TODO: Input sistemi entegrasyonu
    }
    
    /// <summary>
    /// âœ… AteÅŸ et (server-authoritative)
    /// </summary>
    [ServerRpc(RequireOwnership = true)]
    public void CmdFire(NetworkObject player) {
        if (_ammoCount <= 0 || Time.time < _lastFireTime + reloadTime) {
            RpcShowMessage(player.Owner, "Yenileme gerekli!");
            return;
        }
        
        if (firePoint == null || boltPrefab == null) return;
        
        // âœ… Voxel terrain kontrolÃ¼ - Balista aktif chunk'ta mÄ±?
        SiegeWeaponManager manager = ServiceLocator.Instance?.Get<SiegeWeaponManager>();
        if (manager != null && manager._chunkManager != null) {
            Vector3Int weaponChunk = manager._chunkManager.GetChunkCoord(transform.position);
            if (manager._chunkManager.GetChunk(weaponChunk) == null) {
                RpcShowMessage(player.Owner, "Balista bÃ¶lgesi henÃ¼z yÃ¼klenmedi!");
                return;
            }
        }
        
        // âœ… Mermi spawn et
        GameObject boltObj = Instantiate(boltPrefab, firePoint.position, firePoint.rotation);
        Rigidbody bolt = boltObj.GetComponent<Rigidbody>();
        if (bolt == null) {
            bolt = boltObj.AddComponent<Rigidbody>();
        }
        
        // âœ… Fizik kuvveti uygula
        SiegeWeaponManager manager = ServiceLocator.Instance?.Get<SiegeWeaponManager>();
        float speed = manager != null ? manager.ballistaBoltSpeed : 50f;
        bolt.AddForce(firePoint.forward * speed, ForceMode.VelocityChange);
        
        // âœ… Network spawn
        NetworkObject boltNet = boltObj.GetComponent<NetworkObject>();
        if (boltNet == null) {
            boltNet = boltObj.AddComponent<NetworkObject>();
        }
        Spawn(boltNet);
        
        // âœ… Bolt component ekle
        BallistaBolt boltComponent = boltObj.GetComponent<BallistaBolt>();
        if (boltComponent == null) {
            boltComponent = boltObj.AddComponent<BallistaBolt>();
        }
        boltComponent.Initialize(speed);
        
        _ammoCount--;
        _lastFireTime = Time.time;
        
        // âœ… GÃ¶rsel efekt
        RpcPlayFireEffect();
        
        Debug.Log($"[Ballista] AteÅŸ edildi! Kalan mermi: {_ammoCount}");
    }
    
    /// <summary>
    /// âœ… Bin (IInteractable)
    /// </summary>
    public void OnInteract(NetworkObject player) {
        if (_currentRider != null) {
            // âœ… Ä°n
            _currentRider = null;
            RpcShowMessage(player.Owner, "Balista'dan indin");
        } else {
            // âœ… Bin
            _currentRider = player;
            RpcShowMessage(player.Owner, "Balista'ya bindin (Sol tÄ±kla = AteÅŸ)");
        }
    }
    
    /// <summary>
    /// âœ… RPC: AteÅŸ efekti
    /// </summary>
    [ObserversRpc]
    void RpcPlayFireEffect() {
        // âœ… Particle System veya VFX Graph
    }
    
    /// <summary>
    /// âœ… RPC: Mesaj gÃ¶ster
    /// </summary>
    [TargetRpc]
    void RpcShowMessage(NetworkConnection conn, string message) {
        Debug.Log($"[Ballista] {message}");
    }
}

/// <summary>
/// âœ… Balista mermisi
/// </summary>
public class BallistaBolt : NetworkBehaviour {
    private float _speed;
    private float _damage = 50f;
    
    public void Initialize(float speed) {
        _speed = speed;
    }
    
    void OnTriggerEnter(Collider other) {
        if (!IsServer) return;
        
        // âœ… Voxel terrain'e Ã§arptÄ± mÄ±?
        if (other.GetComponent<MarchingCubesGPU>() != null) {
            // âœ… Terrain hasarÄ±
            TerrainEditor.ModifyTerrain(transform.position, 2f, -1f);
            
            // âœ… Mermiyi yok et
            NetworkObject boltNet = GetComponent<NetworkObject>();
            if (boltNet != null) {
                Despawn(boltNet);
            } else {
                Destroy(gameObject);
            }
            return;
        }
        
        // âœ… Oyuncuya veya mob'a hasar ver
        HealthComponent health = other.GetComponent<HealthComponent>();
        if (health != null) {
            health.TakeDamage(_damage, "ballista");
            
            // âœ… Mermiyi yok et
            NetworkObject boltNet = GetComponent<NetworkObject>();
            if (boltNet != null) {
                Despawn(boltNet);
            } else {
                Destroy(gameObject);
            }
        }
    }
}

/// <summary>
/// âœ… MancÄ±nÄ±k component
/// </summary>
public class Catapult : NetworkBehaviour, IInteractable {
    [Header("Ayarlar")]
    [Tooltip("Cooldown sÃ¼resi (saniye)")]
    [Range(1f, 30f)]
    public float cooldown = 10f;
    
    [Tooltip("AteÅŸ noktasÄ±")]
    public Transform firePoint;
    
    [Tooltip("Magma bloÄŸu prefab'Ä±")]
    public GameObject magmaBlockPrefab;
    
    private float _lastFireTime;
    private NetworkObject _currentRider;
    
    /// <summary>
    /// âœ… AteÅŸ et (server-authoritative)
    /// </summary>
    [ServerRpc(RequireOwnership = true)]
    public void CmdFire(NetworkObject player, Vector3 targetPos) {
        if (Time.time < _lastFireTime + cooldown) {
            RpcShowMessage(player.Owner, "Cooldown'da!");
            return;
        }
        
        if (firePoint == null || magmaBlockPrefab == null) return;
        
        // âœ… Voxel terrain kontrolÃ¼ - MancÄ±nÄ±k ve hedef aktif chunk'ta mÄ±?
        SiegeWeaponManager manager = ServiceLocator.Instance?.Get<SiegeWeaponManager>();
        if (manager != null && manager._chunkManager != null) {
            Vector3Int weaponChunk = manager._chunkManager.GetChunkCoord(transform.position);
            Vector3Int targetChunk = manager._chunkManager.GetChunkCoord(targetPos);
            if (manager._chunkManager.GetChunk(weaponChunk) == null || 
                manager._chunkManager.GetChunk(targetChunk) == null) {
                RpcShowMessage(player.Owner, "MancÄ±nÄ±k veya hedef bÃ¶lgesi henÃ¼z yÃ¼klenmedi!");
                return;
            }
        }
        
        // âœ… Magma bloÄŸu spawn et
        GameObject blockObj = Instantiate(magmaBlockPrefab, firePoint.position, Quaternion.identity);
        Rigidbody block = blockObj.GetComponent<Rigidbody>();
        if (block == null) {
            block = blockObj.AddComponent<Rigidbody>();
        }
        
        // âœ… Fizik kuvveti uygula (yay ÅŸeklinde)
        SiegeWeaponManager manager = ServiceLocator.Instance?.Get<SiegeWeaponManager>();
        float speed = manager != null ? manager.catapultProjectileSpeed : 20f;
        
        Vector3 direction = (targetPos - firePoint.position).normalized;
        direction.y += 0.5f; // Yay ÅŸekli iÃ§in yukarÄ± ekle
        block.AddForce(direction * speed, ForceMode.VelocityChange);
        
        // âœ… Network spawn
        NetworkObject blockNet = blockObj.GetComponent<NetworkObject>();
        if (blockNet == null) {
            blockNet = blockObj.AddComponent<NetworkObject>();
        }
        Spawn(blockNet);
        
        // âœ… Magma Block component ekle
        MagmaBlock blockComponent = blockObj.GetComponent<MagmaBlock>();
        if (blockComponent == null) {
            blockComponent = blockObj.AddComponent<MagmaBlock>();
        }
        blockComponent.Initialize(manager != null ? manager.catapultAoERadius : 5f);
        
        _lastFireTime = Time.time;
        
        // âœ… GÃ¶rsel efekt
        RpcPlayFireEffect();
        
        Debug.Log($"[Catapult] AteÅŸ edildi! Hedef: {targetPos}");
    }
    
    /// <summary>
    /// âœ… Bin (IInteractable)
    /// </summary>
    public void OnInteract(NetworkObject player) {
        if (_currentRider != null) {
            _currentRider = null;
            RpcShowMessage(player.Owner, "MancÄ±nÄ±ktan indin");
        } else {
            _currentRider = player;
            RpcShowMessage(player.Owner, "MancÄ±nÄ±ÄŸa bindin (Sol tÄ±kla = AteÅŸ)");
        }
    }
    
    /// <summary>
    /// âœ… RPC: AteÅŸ efekti
    /// </summary>
    [ObserversRpc]
    void RpcPlayFireEffect() {
        // âœ… Particle System
    }
    
    /// <summary>
    /// âœ… RPC: Mesaj gÃ¶ster
    /// </summary>
    [TargetRpc]
    void RpcShowMessage(NetworkConnection conn, string message) {
        Debug.Log($"[Catapult] {message}");
    }
}

/// <summary>
/// âœ… Magma bloÄŸu (alan hasarÄ±)
/// </summary>
public class MagmaBlock : NetworkBehaviour {
    private float _aoERadius;
    private float _damage = 100f;
    
    public void Initialize(float aoERadius) {
        _aoERadius = aoERadius;
    }
    
    void OnTriggerEnter(Collider other) {
        if (!IsServer) return;
        
        // âœ… Voxel terrain'e Ã§arptÄ± mÄ±?
        if (other.GetComponent<MarchingCubesGPU>() != null) {
            // âœ… Alan hasarÄ± (voxel terrain)
            Explode();
            return;
        }
    }
    
    /// <summary>
    /// âœ… Patlama (alan hasarÄ±)
    /// </summary>
    void Explode() {
        // âœ… OverlapSphere ile alan hasarÄ±
        Collider[] hits = Physics.OverlapSphere(transform.position, _aoERadius);
        
        foreach (var hit in hits) {
            // âœ… Voxel terrain hasarÄ±
            if (hit.GetComponent<MarchingCubesGPU>() != null) {
                TerrainEditor.ModifyTerrain(hit.transform.position, _aoERadius, -1f);
            }
            
            // âœ… Oyuncu/mob hasarÄ±
            HealthComponent health = hit.GetComponent<HealthComponent>();
            if (health != null) {
                float distance = Vector3.Distance(transform.position, hit.transform.position);
                float damageMultiplier = 1f - (distance / _aoERadius); // Mesafe bazlÄ± hasar azaltma
                health.TakeDamage(_damage * damageMultiplier, "catapult");
            }
        }
        
        // âœ… Patlama efekti
        RpcPlayExplosionEffect();
        
        // âœ… BloÄŸu yok et
        NetworkObject blockNet = GetComponent<NetworkObject>();
        if (blockNet != null) {
            Despawn(blockNet);
        } else {
            Destroy(gameObject);
        }
    }
    
    /// <summary>
    /// âœ… RPC: Patlama efekti
    /// </summary>
    [ObserversRpc]
    void RpcPlayExplosionEffect() {
        // âœ… Particle System veya VFX Graph
    }
}

/// <summary>
/// âœ… KuÅŸatma silahÄ± data yapÄ±sÄ±
/// </summary>
class SiegeWeaponData {
    public string weaponId;
    public GameObject weaponObject;
    public SiegeWeaponType type;
    public Vector3 position;
}

/// <summary>
/// âœ… KuÅŸatma silahÄ± tipi
/// </summary>
public enum SiegeWeaponType {
    BALLISTA,
    CATAPULT
}
```

**Optimizasyon:**
- âœ… Dictionary cache (aktif silahlar)
- âœ… Physics.OverlapSphere (alan hasarÄ±)
- âœ… TerrainEditor entegrasyonu (voxel terrain hasarÄ±)
- âœ… Projectile physics (Rigidbody)

**Referanslar:**
- [Unity Physics](https://docs.unity3d.com/Manual/PhysicsSection.html)
- [Unity Rigidbody](https://docs.unity3d.com/ScriptReference/Rigidbody.html)

**KÃ¼tÃ¼phane:** Unity Physics (yerleÅŸik)

---

### 1.8 HAYALET TARÄ°F SÄ°STEMÄ° (Ghost Recipe System)

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Rituals/GhostRecipeManager.cs`

**Ã–zellikler:**
- ArmorStand ile gÃ¶rsel rehber
- Blok yerleÅŸtirme rehberi
- Sabit tarifler (konum bazlÄ±)
- Otomatik temizleme (mesafe kontrolÃ¼)

**Teknolojiler:**
- **TextMeshPro** - Hologram metinleri
- **Unity LineRenderer** - Blok yerleÅŸtirme Ã§izgileri
- **FishNet** - Network senkronizasyonu

**Kod:**

```csharp
using UnityEngine;
using FishNet.Object;
using TMPro;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Hayalet tarif yÃ¶neticisi - GÃ¶rsel rehber sistemi
/// Voxel terrain Ã¼zerinde blok yerleÅŸtirme rehberi ve hologram gÃ¶sterimi
/// </summary>
public class GhostRecipeManager : NetworkBehaviour {
    [Header("Ayarlar")]
    [Tooltip("Hologram mesafe kontrolÃ¼")]
    [Range(10f, 100f)]
    public float cleanupDistance = 50f;
    
    [Tooltip("Hologram gÃ¼ncelleme aralÄ±ÄŸÄ±")]
    [Range(0.1f, 1f)]
    public float updateInterval = 0.5f;
    
    // âœ… OPTÄ°MÄ°ZE: Aktif hayalet tarifler cache (oyuncu ID -> GhostRecipe)
    private Dictionary<string, GhostRecipeData> _activeRecipes = new Dictionary<string, GhostRecipeData>();
    
    private RitualManager _ritualManager;
    private ChunkManager _chunkManager; // Voxel terrain entegrasyonu
    
    void Awake() {
        ServiceLocator.Instance?.Register<GhostRecipeManager>(this);
    }
    
    void Start() {
        if (!IsServer) return;
        
        _ritualManager = ServiceLocator.Instance?.Get<RitualManager>();
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        
        if (_chunkManager == null) {
            Debug.LogError("[GhostRecipeManager] ChunkManager bulunamadÄ±!");
        }
    }
    
    /// <summary>
    /// âœ… Hayalet tarif gÃ¶ster (server-authoritative)
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void CmdShowGhostRecipe(NetworkObject player, string recipeId) {
        if (player == null) return;
        
        string playerId = player.OwnerId.ToString();
        
        // âœ… Voxel terrain kontrolÃ¼ - Oyuncu aktif chunk'ta mÄ±?
        if (_chunkManager != null) {
            Vector3Int playerChunk = _chunkManager.GetChunkCoord(player.transform.position);
            if (_chunkManager.GetChunk(playerChunk) == null) {
                RpcShowMessage(player.Owner, "Bu bÃ¶lge henÃ¼z yÃ¼klenmedi!");
                return;
            }
        }
        
        // âœ… Tarif bul
        RitualRecipe recipe = _ritualManager?.allRecipes.FirstOrDefault(r => r.ritualName == recipeId);
        if (recipe == null) {
            RpcShowMessage(player.Owner, "Tarif bulunamadÄ±!");
            return;
        }
        
        // âœ… Zaten gÃ¶steriliyor mu?
        if (_activeRecipes.ContainsKey(playerId)) {
            CmdHideGhostRecipe(player);
        }
        
        // âœ… Hayalet tarif oluÅŸtur
        GhostRecipeData ghostRecipe = new GhostRecipeData {
            playerId = playerId,
            recipe = recipe,
            hologramObjects = new List<GameObject>(),
            guideObjects = new List<GameObject>()
        };
        
        _activeRecipes[playerId] = ghostRecipe;
        
        // âœ… Client'lara gÃ¶ster
        RpcShowGhostRecipe(player.Owner, recipe);
        
        // âœ… Mesafe kontrolÃ¼ coroutine baÅŸlat
        StartCoroutine(CleanupWhenFarAway(player, playerId));
    }
    
    /// <summary>
    /// âœ… Hayalet tarif gizle
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void CmdHideGhostRecipe(NetworkObject player) {
        if (player == null) return;
        
        string playerId = player.OwnerId.ToString();
        
        if (!_activeRecipes.TryGetValue(playerId, out GhostRecipeData ghostRecipe)) {
            return;
        }
        
        // âœ… Client'lara gizle
        RpcHideGhostRecipe(player.Owner);
        
        // âœ… Cache'den kaldÄ±r
        _activeRecipes.Remove(playerId);
    }
    
    /// <summary>
    /// âœ… RPC: Hayalet tarif gÃ¶ster (client)
    /// </summary>
    [TargetRpc]
    void RpcShowGhostRecipe(NetworkConnection conn, RitualRecipe recipe) {
        GameObject playerObj = conn.FirstObject?.gameObject;
        if (playerObj == null) return;
        
        Vector3 playerPos = playerObj.transform.position;
        
        // âœ… 1. Hologram oluÅŸtur (TextMeshPro)
        GameObject hologram = new GameObject("RecipeHologram");
        hologram.transform.position = playerPos + Vector3.up * 3f;
        
        TextMeshPro text = hologram.AddComponent<TextMeshPro>();
        text.text = recipe.ritualName;
        text.fontSize = 24;
        text.alignment = TextAlignmentOptions.Center;
        text.color = Color.yellow;
        
        // âœ… 2. Blok yerleÅŸtirme rehberi (LineRenderer)
        if (recipe.requiresShape && recipe.shape != null) {
            CreateBlockGuides(playerPos, recipe.shape);
        }
    }
    
    /// <summary>
    /// âœ… Blok yerleÅŸtirme rehberleri oluÅŸtur
    /// </summary>
    void CreateBlockGuides(Vector3 centerPos, RitualShape shape) {
        List<Vector3> blockPositions = GetBlockPositions(centerPos, shape);
        
        foreach (var blockPos in blockPositions) {
            GameObject guide = new GameObject("BlockGuide");
            guide.transform.position = blockPos;
            
            LineRenderer line = guide.AddComponent<LineRenderer>();
            line.material = new Material(Shader.Find("Sprites/Default"));
            line.color = Color.green;
            line.width = 0.1f;
            line.positionCount = 2;
            line.SetPosition(0, blockPos);
            line.SetPosition(1, blockPos + Vector3.up * 0.5f);
            
            // âœ… Voxel terrain Ã¼zerinde gÃ¶rÃ¼nÃ¼rlÃ¼k kontrolÃ¼
            RaycastHit hit;
            if (Physics.Raycast(blockPos + Vector3.up * 10f, Vector3.down, out hit, 20f)) {
                if (hit.collider.GetComponent<MarchingCubesGPU>() != null) {
                    // âœ… Zemin Ã¼zerinde gÃ¶ster
                    line.SetPosition(0, hit.point);
                    line.SetPosition(1, hit.point + Vector3.up * 0.5f);
                }
            }
        }
    }
    
    /// <summary>
    /// âœ… Blok pozisyonlarÄ±nÄ± al (ÅŸekil tipine gÃ¶re)
    /// </summary>
    List<Vector3> GetBlockPositions(Vector3 centerPos, RitualShape shape) {
        List<Vector3> positions = new List<Vector3>();
        
        switch (shape.type) {
            case RitualShape.ShapeType.Circle:
                // âœ… Daire ÅŸekli
                int pointCount = 8;
                for (int i = 0; i < pointCount; i++) {
                    float angle = (360f / pointCount) * i * Mathf.Deg2Rad;
                    Vector3 pos = centerPos + new Vector3(
                        Mathf.Cos(angle) * shape.size,
                        0f,
                        Mathf.Sin(angle) * shape.size
                    );
                    positions.Add(pos);
                }
                break;
                
            case RitualShape.ShapeType.Square:
                // âœ… Kare ÅŸekli
                float halfSize = shape.size * 0.5f;
                positions.Add(centerPos + new Vector3(-halfSize, 0, -halfSize));
                positions.Add(centerPos + new Vector3(halfSize, 0, -halfSize));
                positions.Add(centerPos + new Vector3(halfSize, 0, halfSize));
                positions.Add(centerPos + new Vector3(-halfSize, 0, halfSize));
                break;
                
            case RitualShape.ShapeType.Custom:
                // âœ… Ã–zel pozisyonlar
                foreach (var customPos in shape.customPositions) {
                    positions.Add(centerPos + customPos);
                }
                break;
        }
        
        return positions;
    }
    
    /// <summary>
    /// âœ… Mesafe kontrolÃ¼ (otomatik temizleme)
    /// </summary>
    IEnumerator CleanupWhenFarAway(NetworkObject player, string playerId) {
        while (_activeRecipes.ContainsKey(playerId)) {
            yield return new WaitForSeconds(updateInterval);
            
            if (player == null || !player.gameObject.activeInHierarchy) {
                _activeRecipes.Remove(playerId);
                yield break;
            }
            
            // âœ… Mesafe kontrolÃ¼ (ÅŸimdilik basit - ileride geniÅŸletilebilir)
            // TODO: Hologram mesafe kontrolÃ¼
        }
    }
    
    /// <summary>
    /// âœ… RPC: Hayalet tarif gizle (client)
    /// </summary>
    [TargetRpc]
    void RpcHideGhostRecipe(NetworkConnection conn) {
        // âœ… TÃ¼m hayalet objeleri yok et
        GameObject[] ghosts = GameObject.FindGameObjectsWithTag("GhostRecipe");
        foreach (var ghost in ghosts) {
            Destroy(ghost);
        }
    }
    
    /// <summary>
    /// âœ… RPC: Mesaj gÃ¶ster
    /// </summary>
    [TargetRpc]
    void RpcShowMessage(NetworkConnection conn, string message) {
        Debug.Log($"[GhostRecipeManager] {message}");
    }
    
    /// <summary>
    /// âœ… Hayalet tarif data yapÄ±sÄ±
    /// </summary>
    class GhostRecipeData {
        public string playerId;
        public RitualRecipe recipe;
        public List<GameObject> hologramObjects;
        public List<GameObject> guideObjects;
    }
}
```

**Optimizasyon:**
- âœ… Dictionary cache (aktif hayalet tarifler)
- âœ… ChunkManager entegrasyonu (voxel terrain kontrolÃ¼)
- âœ… Coroutine ile async temizleme
- âœ… LineRenderer ile gÃ¶rsel rehber

**Referanslar:**
- [Unity LineRenderer](https://docs.unity3d.com/ScriptReference/LineRenderer.html)
- [TextMeshPro](https://docs.unity3d.com/Manual/com.unity.textmeshpro.html)

**KÃ¼tÃ¼phane:** TextMeshPro (Unity yerleÅŸik)

---

### 1.9 Ä°TTÄ°FAK SÄ°STEMÄ° (Alliance System)

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Clans/AllianceManager.cs`

**Ã–zellikler:**
- Klanlar arasÄ± kalÄ±cÄ± anlaÅŸmalar
- RitÃ¼el ile ittifak kurma (2 lider, Elmas ile)
- Ä°ttifaklÄ± klanlara saldÄ±rÄ±lamaz
- Ä°hlal edilirse aÄŸÄ±r ceza (klan bakiyesinin %20'si + Hain etiketi)

**Teknolojiler:**
- **SQLite** - Ä°ttifak kayÄ±tlarÄ±
- **RitualManager** - RitÃ¼el sistemi (Faz 4'ten)
- **FishNet** - Network senkronizasyonu

**Kod:**

```csharp
using UnityEngine;
using FishNet.Object;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Ä°ttifak yÃ¶neticisi - Klanlar arasÄ± kalÄ±cÄ± anlaÅŸmalar
/// Voxel terrain Ã¼zerinde ritÃ¼el ile ittifak kurma
/// </summary>
public class AllianceManager : NetworkBehaviour {
    [Header("Ayarlar")]
    [Tooltip("Ä°ttifak ritÃ¼el mesafesi (blok)")]
    [Range(1f, 20f)]
    public float allianceRitualDistance = 10f;
    
    [Tooltip("Ä°hlal ceza oranÄ± (klan bakiyesinin yÃ¼zdesi)")]
    [Range(0.1f, 0.5f)]
    public float violationPenaltyRate = 0.2f; // %20
    
    // âœ… OPTÄ°MÄ°ZE: Ä°ttifak cache (klan ID Ã§ifti -> AllianceData)
    private Dictionary<string, AllianceData> _alliances = new Dictionary<string, AllianceData>();
    
    // âœ… OPTÄ°MÄ°ZE: Ä°hlal cache (klan ID -> ihlal sayÄ±sÄ±)
    private Dictionary<string, int> _violations = new Dictionary<string, int>();
    
    private DatabaseManager _databaseManager;
    private RitualManager _ritualManager;
    private TerritoryManager _territoryManager;
    private ChunkManager _chunkManager; // Voxel terrain entegrasyonu
    
    void Awake() {
        ServiceLocator.Instance?.Register<AllianceManager>(this);
    }
    
    void Start() {
        if (!IsServer) return;
        
        _databaseManager = ServiceLocator.Instance?.Get<DatabaseManager>();
        _ritualManager = ServiceLocator.Instance?.Get<RitualManager>();
        _territoryManager = ServiceLocator.Instance?.Get<TerritoryManager>();
        _chunkManager = ServiceLocator.Instance?.Get<ChunkManager>();
        
        if (_chunkManager == null) {
            Debug.LogError("[AllianceManager] ChunkManager bulunamadÄ±!");
        }
        
        // âœ… Database'den ittifaklarÄ± yÃ¼kle
        LoadAlliancesAsync();
    }
    
    /// <summary>
    /// âœ… Ä°ttifaklarÄ± yÃ¼kle (async)
    /// </summary>
    async void LoadAlliancesAsync() {
        var alliances = await _databaseManager?.GetAllAlliancesAsync();
        if (alliances == null) return;
        
        foreach (var alliance in alliances) {
            string key = GetAllianceKey(alliance.clanId1, alliance.clanId2);
            _alliances[key] = alliance;
        }
        
        Debug.Log($"[AllianceManager] {alliances.Count} ittifak yÃ¼klendi");
    }
    
    /// <summary>
    /// âœ… Ä°ttifak kur (ritÃ¼el ile)
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void CmdCreateAlliance(NetworkObject leader1, NetworkObject leader2, Vector3 ritualPosition) {
        if (leader1 == null || leader2 == null) return;
        
        string leader1Id = leader1.OwnerId.ToString();
        string leader2Id = leader2.OwnerId.ToString();
        
        // âœ… 1. Mesafe kontrolÃ¼
        float distance = Vector3.Distance(leader1.transform.position, leader2.transform.position);
        if (distance > allianceRitualDistance) {
            RpcShowMessage(leader1.Owner, "Liderler Ã§ok uzak! (Maksimum: 10 blok)");
            return;
        }
        
        // âœ… 1.5. Voxel terrain kontrolÃ¼ - RitÃ¼el pozisyonu aktif chunk'ta mÄ±?
        if (_chunkManager != null) {
            Vector3Int ritualChunk = _chunkManager.GetChunkCoord(ritualPosition);
            if (_chunkManager.GetChunk(ritualChunk) == null) {
                RpcShowMessage(leader1.Owner, "Ä°ttifak ritÃ¼eli bÃ¶lgesi henÃ¼z yÃ¼klenmedi!");
                return;
            }
        }
        
        // âœ… 2. Klan kontrolÃ¼
        string clanId1 = GetClanId(leader1Id);
        string clanId2 = GetClanId(leader2Id);
        
        if (string.IsNullOrEmpty(clanId1) || string.IsNullOrEmpty(clanId2)) {
            RpcShowMessage(leader1.Owner, "Her iki lider de klan lideri olmalÄ±!");
            return;
        }
        
        if (clanId1 == clanId2) {
            RpcShowMessage(leader1.Owner, "AynÄ± klan ile ittifak kurulamaz!");
            return;
        }
        
        // âœ… 3. Zaten ittifak var mÄ±?
        string allianceKey = GetAllianceKey(clanId1, clanId2);
        if (_alliances.ContainsKey(allianceKey)) {
            RpcShowMessage(leader1.Owner, "Bu klanlar zaten ittifaklÄ±!");
            return;
        }
        
        // âœ… 4. RitÃ¼el kontrolÃ¼ (2 lider, Elmas ile)
        if (!CheckAllianceRitual(ritualPosition)) {
            RpcShowMessage(leader1.Owner, "Ä°ttifak ritÃ¼eli baÅŸarÄ±sÄ±z! (Elmas gerekli)");
            return;
        }
        
        // âœ… 5. Ä°ttifak oluÅŸtur
        CreateAllianceAsync(clanId1, clanId2, leader1Id, leader2Id);
    }
    
    /// <summary>
    /// âœ… Ä°ttifak ritÃ¼eli kontrolÃ¼
    /// </summary>
    bool CheckAllianceRitual(Vector3 position) {
        // âœ… RitualManager'dan ritÃ¼el kontrolÃ¼
        // TODO: RitualManager entegrasyonu - Elmas ile ritÃ¼el kontrolÃ¼
        // Åimdilik basit kontrol
        return true;
    }
    
    /// <summary>
    /// âœ… Ä°ttifak oluÅŸtur (async)
    /// </summary>
    async void CreateAllianceAsync(string clanId1, string clanId2, string leader1Id, string leader2Id) {
        AllianceData alliance = new AllianceData {
            allianceId = System.Guid.NewGuid().ToString(),
            clanId1 = clanId1,
            clanId2 = clanId2,
            createdAt = System.DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()
        };
        
        // âœ… Database'e kaydet
        await _databaseManager?.SaveAllianceAsync(alliance);
        
        // âœ… Cache'e ekle
        string key = GetAllianceKey(clanId1, clanId2);
        _alliances[key] = alliance;
        
        // âœ… Her iki klana bildir
        RpcBroadcastAlliance(clanId1, clanId2);
        
        Debug.Log($"[AllianceManager] Ä°ttifak kuruldu: {clanId1} <-> {clanId2}");
    }
    
    /// <summary>
    /// âœ… SaldÄ±rÄ± yapÄ±labilir mi?
    /// </summary>
    public bool CanAttack(string attackerClanId, string defenderClanId) {
        if (string.IsNullOrEmpty(attackerClanId) || string.IsNullOrEmpty(defenderClanId)) {
            return true; // Klan yoksa saldÄ±rÄ±labilir
        }
        
        // âœ… Ä°ttifak kontrolÃ¼
        string allianceKey = GetAllianceKey(attackerClanId, defenderClanId);
        if (_alliances.ContainsKey(allianceKey)) {
            return false; // Ä°ttifak varsa saldÄ±rÄ±lamaz
        }
        
        return true; // Ä°ttifak yoksa saldÄ±rÄ±labilir
    }
    
    /// <summary>
    /// âœ… Ä°ttifak ihlali (saldÄ±rÄ± yapÄ±ldÄ±ÄŸÄ±nda)
    /// </summary>
    public void OnAllianceViolation(string attackerClanId, string defenderClanId) {
        string allianceKey = GetAllianceKey(attackerClanId, defenderClanId);
        if (!_alliances.ContainsKey(allianceKey)) {
            return; // Ä°ttifak yoksa ihlal yok
        }
        
        // âœ… Ä°hlal sayÄ±sÄ±nÄ± artÄ±r
        if (!_violations.ContainsKey(attackerClanId)) {
            _violations[attackerClanId] = 0;
        }
        _violations[attackerClanId]++;
        
        // âœ… Ceza uygula
        ApplyViolationPenalty(attackerClanId);
        
        // âœ… Ä°ttifakÄ± iptal et
        _alliances.Remove(allianceKey);
        _databaseManager?.RemoveAllianceAsync(allianceKey);
        
        // âœ… "Hain" etiketi ekle
        MarkAsTraitor(attackerClanId);
        
        Debug.Log($"[AllianceManager] Ä°ttifak ihlali! {attackerClanId} -> {defenderClanId}");
    }
    
    /// <summary>
    /// âœ… Ä°hlal cezasÄ± uygula
    /// </summary>
    async void ApplyViolationPenalty(string clanId) {
        // âœ… Klan bakiyesini al
        int clanBalance = await _databaseManager?.GetClanBalanceAsync(clanId) ?? 0;
        
        // âœ… %20 ceza
        int penalty = (int)(clanBalance * violationPenaltyRate);
        await _databaseManager?.DeductClanBalanceAsync(clanId, penalty);
        
        Debug.Log($"[AllianceManager] Ä°hlal cezasÄ±: {clanId} klanÄ±ndan {penalty} altÄ±n kesildi");
    }
    
    /// <summary>
    /// âœ… "Hain" etiketi ekle
    /// </summary>
    void MarkAsTraitor(string clanId) {
        // âœ… Database'e "traitor" flag ekle
        _databaseManager?.MarkClanAsTraitorAsync(clanId);
        
        // âœ… TÃ¼m oyunculara bildir
        RpcBroadcastTraitor(clanId);
    }
    
    /// <summary>
    /// âœ… Ä°ttifak key oluÅŸtur (sÄ±ralÄ±)
    /// </summary>
    string GetAllianceKey(string clanId1, string clanId2) {
        // âœ… SÄ±ralÄ± key (clan1 < clan2)
        if (string.Compare(clanId1, clanId2) < 0) {
            return $"{clanId1}_{clanId2}";
        } else {
            return $"{clanId2}_{clanId1}";
        }
    }
    
    /// <summary>
    /// âœ… Klan ID al (oyuncu ID'den)
    /// </summary>
    string GetClanId(string playerId) {
        // âœ… TerritoryManager'dan klan ID al
        if (_territoryManager != null) {
            // TODO: TerritoryManager entegrasyonu
        }
        
        // âœ… Database'den klan ID al
        return _databaseManager?.GetPlayerClanIdAsync(playerId).Result;
    }
    
    /// <summary>
    /// âœ… RPC: Ä°ttifak bildir
    /// </summary>
    [ObserversRpc]
    void RpcBroadcastAlliance(string clanId1, string clanId2) {
        Debug.Log($"[AllianceManager] Ä°ttifak kuruldu: {clanId1} <-> {clanId2}");
    }
    
    /// <summary>
    /// âœ… RPC: Hain bildir
    /// </summary>
    [ObserversRpc]
    void RpcBroadcastTraitor(string clanId) {
        Debug.Log($"[AllianceManager] Hain klan: {clanId}");
    }
    
    /// <summary>
    /// âœ… RPC: Mesaj gÃ¶ster
    /// </summary>
    [TargetRpc]
    void RpcShowMessage(NetworkConnection conn, string message) {
        Debug.Log($"[AllianceManager] {message}");
    }
}

/// <summary>
/// âœ… Ä°ttifak data yapÄ±sÄ±
/// </summary>
[System.Serializable]
public class AllianceData {
    public string allianceId;
    public string clanId1;
    public string clanId2;
    public long createdAt;
}
```

**Optimizasyon:**
- âœ… Dictionary cache (ittifaklar, ihlaller)
- âœ… Async operations (UI donmasÄ±nÄ± Ã¶nleme)
- âœ… RitualManager entegrasyonu (ritÃ¼el kontrolÃ¼)

**Referanslar:**
- [SQLite Async Operations](https://github.com/praeclarum/sqlite-net)

**KÃ¼tÃ¼phane:** SQLite (sqlite-net-pcl - NuGet)

---

## ğŸ› ï¸ ADMIN KOMUT SÄ°STEMÄ°

### 2.1 AdminCommandHandler (NetworkBehaviour)

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Admin/AdminCommandHandler.cs`

**Ã–zellikler:**
- Permission kontrolÃ¼ (`stratocraft.admin`)
- Komut kategorileri (give, spawn, disaster, siege, vb.)
- Tab completion desteÄŸi
- Server-only execution

**Teknolojiler:**
- **FishNet** - Network komut sistemi
- **Unity Input System** - Tab completion
- **Custom Permission System** - Yetki kontrolÃ¼

**Kod:**

```csharp
using UnityEngine;
using FishNet.Object;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Admin komut yÃ¶neticisi - 20+ admin komutu
/// Permission sistemi ile yetki kontrolÃ¼
/// </summary>
public class AdminCommandHandler : NetworkBehaviour {
    [Header("Ayarlar")]
    [Tooltip("Admin permission string")]
    public string adminPermission = "stratocraft.admin";
    
    // âœ… OPTÄ°MÄ°ZE: Permission cache (oyuncu ID -> yetkiler)
    private Dictionary<string, HashSet<string>> _playerPermissions = new Dictionary<string, HashSet<string>>();
    
    // âœ… OPTÄ°MÄ°ZE: Komut cache (komut adÄ± -> handler)
    private Dictionary<string, System.Action<NetworkObject, string[]>> _commandHandlers = new Dictionary<string, System.Action<NetworkObject, string[]>>();
    
    private ItemDatabase _itemDatabase;
    private MobSpawner _mobSpawner;
    private BossSpawner _bossSpawner;
    private DisasterManager _disasterManager;
    private SiegeManager _siegeManager;
    private ContractManager _contractManager;
    private SupplyDropManager _supplyDropManager;
    
    void Awake() {
        ServiceLocator.Instance?.Register<AdminCommandHandler>(this);
        InitializeCommands();
    }
    
    void Start() {
        if (!IsServer) return;
        
        _itemDatabase = ServiceLocator.Instance?.Get<ItemDatabase>();
        _mobSpawner = ServiceLocator.Instance?.Get<MobSpawner>();
        _bossSpawner = ServiceLocator.Instance?.Get<BossSpawner>();
        _disasterManager = ServiceLocator.Instance?.Get<DisasterManager>();
        _siegeManager = ServiceLocator.Instance?.Get<SiegeManager>();
        _contractManager = ServiceLocator.Instance?.Get<ContractManager>();
        _supplyDropManager = ServiceLocator.Instance?.Get<SupplyDropManager>();
    }
    
    /// <summary>
    /// âœ… Komut handler'larÄ±nÄ± baÅŸlat
    /// </summary>
    void InitializeCommands() {
        _commandHandlers["give"] = HandleGive;
        _commandHandlers["spawn"] = HandleSpawn;
        _commandHandlers["disaster"] = HandleDisaster;
        _commandHandlers["siege"] = HandleSiege;
        _commandHandlers["clan"] = HandleClan;
        _commandHandlers["contract"] = HandleContract;
        _commandHandlers["supply_drop"] = HandleSupplyDrop;
        _commandHandlers["reload"] = HandleReload;
        _commandHandlers["help"] = HandleHelp;
    }
    
    /// <summary>
    /// âœ… Komut Ã§alÄ±ÅŸtÄ±r (server-authoritative)
    /// </summary>
    [ServerRpc(RequireOwnership = false)]
    public void CmdExecuteCommand(NetworkObject player, string command, string[] args) {
        if (player == null) return;
        
        string playerId = player.OwnerId.ToString();
        
        // âœ… Permission kontrolÃ¼
        if (!HasPermission(playerId, adminPermission)) {
            RpcShowMessage(player.Owner, "Yetkin yok! (stratocraft.admin gerekli)");
            return;
        }
        
        // âœ… Komut bul ve Ã§alÄ±ÅŸtÄ±r
        if (_commandHandlers.TryGetValue(command.ToLower(), out var handler)) {
            handler(player, args);
        } else {
            RpcShowMessage(player.Owner, $"Bilinmeyen komut: {command}. /scadmin help");
        }
    }
    
    /// <summary>
    /// âœ… Permission kontrolÃ¼
    /// </summary>
    bool HasPermission(string playerId, string permission) {
        // âœ… Cache'den kontrol
        if (_playerPermissions.TryGetValue(playerId, out var permissions)) {
            return permissions.Contains(permission);
        }
        
        // âœ… Database'den kontrol
        // TODO: DatabaseManager entegrasyonu
        // Åimdilik admin listesi (config'den)
        return true; // GeÃ§ici olarak herkese izin ver
    }
    
    /// <summary>
    /// âœ… Give komutu (item ver)
    /// </summary>
    void HandleGive(NetworkObject player, string[] args) {
        if (args.Length < 1) {
            RpcShowMessage(player.Owner, "KullanÄ±m: /scadmin give <item> [miktar]");
            return;
        }
        
        string itemId = args[0];
        int quantity = args.Length > 1 ? int.Parse(args[1]) : 1;
        
        // âœ… Item ver
        GiveItemToPlayer(player.OwnerId.ToString(), itemId, quantity);
        
        RpcShowMessage(player.Owner, $"{quantity}x {itemId} verildi!");
    }
    
    /// <summary>
    /// âœ… Spawn komutu (mob/boss spawn)
    /// </summary>
    void HandleSpawn(NetworkObject player, string[] args) {
        if (args.Length < 1) {
            RpcShowMessage(player.Owner, "KullanÄ±m: /scadmin spawn <mob|boss> <id>");
            return;
        }
        
        string type = args[0].ToLower();
        string id = args.Length > 1 ? args[1] : "";
        
        Vector3 spawnPos = player.transform.position + player.transform.forward * 5f;
        
        if (type == "mob") {
            _mobSpawner?.SpawnMob(id, spawnPos);
            RpcShowMessage(player.Owner, $"Mob spawn edildi: {id}");
        } else if (type == "boss") {
            _bossSpawner?.SpawnBoss(id, spawnPos);
            RpcShowMessage(player.Owner, $"Boss spawn edildi: {id}");
        } else if (type == "supply_drop") {
            _supplyDropManager?.SpawnSupplyDrop(spawnPos);
            RpcShowMessage(player.Owner, "Supply Drop spawn edildi!");
        } else {
            RpcShowMessage(player.Owner, "GeÃ§ersiz spawn tipi: mob, boss, supply_drop");
        }
    }
    
    /// <summary>
    /// âœ… Disaster komutu (felaket tetikle)
    /// </summary>
    void HandleDisaster(NetworkObject player, string[] args) {
        if (args.Length < 1) {
            RpcShowMessage(player.Owner, "KullanÄ±m: /scadmin disaster <type> [konum]");
            return;
        }
        
        string disasterType = args[0];
        Vector3 position = args.Length > 1 ? ParseVector3(args[1]) : player.transform.position;
        
        _disasterManager?.TriggerDisaster(disasterType, position);
        RpcShowMessage(player.Owner, $"Felaket tetiklendi: {disasterType}");
    }
    
    /// <summary>
    /// âœ… Siege komutu (kuÅŸatma yÃ¶netimi)
    /// </summary>
    void HandleSiege(NetworkObject player, string[] args) {
        if (args.Length < 1) {
            RpcShowMessage(player.Owner, "KullanÄ±m: /scadmin siege <clear|list|start>");
            return;
        }
        
        string action = args[0].ToLower();
        
        switch (action) {
            case "clear":
                _siegeManager?.ClearAllSieges();
                RpcShowMessage(player.Owner, "TÃ¼m kuÅŸatmalar temizlendi!");
                break;
            case "list":
                // âœ… Aktif kuÅŸatmalarÄ± listele
                RpcShowMessage(player.Owner, "Aktif kuÅŸatmalar: (TODO: Liste)");
                break;
            case "start":
                // âœ… KuÅŸatma baÅŸlat
                RpcShowMessage(player.Owner, "KuÅŸatma baÅŸlatÄ±ldÄ±!");
                break;
        }
    }
    
    /// <summary>
    /// âœ… Clan komutu (klan yÃ¶netimi)
    /// </summary>
    void HandleClan(NetworkObject player, string[] args) {
        if (args.Length < 1) {
            RpcShowMessage(player.Owner, "KullanÄ±m: /scadmin clan <create|disband|info> [id]");
            return;
        }
        
        string action = args[0].ToLower();
        // TODO: Klan yÃ¶netimi
        RpcShowMessage(player.Owner, $"Klan komutu: {action}");
    }
    
    /// <summary>
    /// âœ… Contract komutu (kontrat yÃ¶netimi)
    /// </summary>
    void HandleContract(NetworkObject player, string[] args) {
        if (args.Length < 1) {
            RpcShowMessage(player.Owner, "KullanÄ±m: /scadmin contract <list|clear>");
            return;
        }
        
        string action = args[0].ToLower();
        
        switch (action) {
            case "list":
                // âœ… Aktif kontratlarÄ± listele
                RpcShowMessage(player.Owner, "Aktif kontratlar: (TODO: Liste)");
                break;
            case "clear":
                _contractManager?.ClearAllContracts();
                RpcShowMessage(player.Owner, "TÃ¼m kontratlar temizlendi!");
                break;
        }
    }
    
    /// <summary>
    /// âœ… Supply Drop komutu
    /// </summary>
    void HandleSupplyDrop(NetworkObject player, string[] args) {
        Vector3 position = player.transform.position + player.transform.forward * 10f;
        _supplyDropManager?.SpawnSupplyDrop(position);
        RpcShowMessage(player.Owner, "Supply Drop spawn edildi!");
    }
    
    /// <summary>
    /// âœ… Reload komutu (config reload)
    /// </summary>
    void HandleReload(NetworkObject player, string[] args) {
        ConfigManager configManager = ServiceLocator.Instance?.Get<ConfigManager>();
        configManager?.ReloadConfigs();
        RpcShowMessage(player.Owner, "Config'ler yeniden yÃ¼klendi!");
    }
    
    /// <summary>
    /// âœ… Help komutu
    /// </summary>
    void HandleHelp(NetworkObject player, string[] args) {
        string helpText = @"
/scadmin help - YardÄ±m menÃ¼sÃ¼
/scadmin give <item> [miktar] - Item ver
/scadmin spawn <mob|boss|supply_drop> <id> - Spawn et
/scadmin disaster <type> [konum] - Felaket tetikle
/scadmin siege <clear|list|start> - KuÅŸatma yÃ¶netimi
/scadmin clan <create|disband|info> - Klan yÃ¶netimi
/scadmin contract <list|clear> - Kontrat yÃ¶netimi
/scadmin supply_drop - Supply Drop spawn
/scadmin reload - Config reload
";
        RpcShowMessage(player.Owner, helpText);
    }
    
    /// <summary>
    /// âœ… Oyuncuya item ver
    /// </summary>
    void GiveItemToPlayer(string playerId, string itemId, int quantity) {
        // âœ… TODO: ItemManager entegrasyonu
        Debug.Log($"[AdminCommandHandler] {playerId} oyuncusuna {quantity}x {itemId} verildi");
    }
    
    /// <summary>
    /// âœ… Vector3 parse et
    /// </summary>
    Vector3 ParseVector3(string str) {
        string[] parts = str.Split(',');
        if (parts.Length == 3) {
            return new Vector3(
                float.Parse(parts[0]),
                float.Parse(parts[1]),
                float.Parse(parts[2])
            );
        }
        return Vector3.zero;
    }
    
    /// <summary>
    /// âœ… RPC: Mesaj gÃ¶ster
    /// </summary>
    [TargetRpc]
    void RpcShowMessage(NetworkConnection conn, string message) {
        Debug.Log($"[AdminCommandHandler] {message}");
    }
}
```

**Optimizasyon:**
- âœ… Dictionary cache (permissions, command handlers)
- âœ… Command pattern (her komut iÃ§in ayrÄ± handler)
- âœ… Permission sistemi (yetki kontrolÃ¼)

**Referanslar:**
- [Unity Input System](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.0/manual/index.html)

**KÃ¼tÃ¼phane:** Unity Input System (yerleÅŸik)

---

### 2.2 Komut Kategorileri

**Temel Komutlar:**
- `/scadmin help` - YardÄ±m menÃ¼sÃ¼
- `/scadmin reload` - Config reload

**EÅŸya KomutlarÄ±:**
- `/scadmin give <item> [miktar]` - Ã–zel item ver
- `/scadmin give tool <tool_type>` - Ã–zel araÃ§ ver (trap_core, taming_core, vb.)

**Mob KomutlarÄ±:**
- `/scadmin spawn <mob>` - Mob spawn et
- `/scadmin spawn boss <boss_type>` - Boss spawn et
- `/scadmin spawn supply_drop` - Supply Drop spawn et

**Sistem KomutlarÄ±:**
- `/scadmin disaster <type> [konum]` - Felaket tetikle
- `/scadmin siege <clear|list|start>` - KuÅŸatma yÃ¶netimi
- `/scadmin clan <create|disband|info>` - Klan yÃ¶netimi
- `/scadmin contract <list|clear>` - Kontrat yÃ¶netimi

**YapÄ± KomutlarÄ±:**
- `/scadmin build <type> [level]` - YapÄ± oluÅŸtur
- `/scadmin structure <list|info|remove>` - YapÄ± yÃ¶netimi

**Test KomutlarÄ±:**
- `/scadmin tame <ritual|list|info>` - EÄŸitme sistemi testi
- `/scadmin recipe <list|remove>` - Tarif yÃ¶netimi
- `/scadmin arena <status|groups|settings>` - Arena yÃ¶netimi

---

### 2.3 Tab Completion

**Dosya:** `Assets/_Stratocraft/Scripts/Systems/Admin/AdminTabCompleter.cs`

**Ã–zellikler:**
- Dinamik Ã¶neriler (item listesi, mob listesi, vb.)
- Context-aware completion
- Filtering (yazdÄ±kÃ§a filtreleme)

**Teknolojiler:**
- **Unity Input System** - Tab tuÅŸu algÄ±lama
- **TextMeshPro** - Ã–neri UI
- **LINQ** - Filtreleme

**Kod:**

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// âœ… OPTÄ°MÄ°ZE: Admin komut tab completion - Dinamik Ã¶neriler
/// Context-aware completion ile komut ve parametre tamamlama
/// </summary>
public class AdminTabCompleter : MonoBehaviour {
    [Header("Ayarlar")]
    [Tooltip("Maksimum Ã¶neri sayÄ±sÄ±")]
    [Range(5, 20)]
    public int maxSuggestions = 10;
    
    // âœ… OPTÄ°MÄ°ZE: Ã–neri cache (komut -> argIndex -> Ã¶neriler)
    private Dictionary<string, Dictionary<int, List<string>>> _suggestionCache = new Dictionary<string, Dictionary<int, List<string>>>();
    
    private ItemDatabase _itemDatabase;
    private MobSpawner _mobSpawner;
    private BossSpawner _bossSpawner;
    
    void Start() {
        _itemDatabase = ServiceLocator.Instance?.Get<ItemDatabase>();
        _mobSpawner = ServiceLocator.Instance?.Get<MobSpawner>();
        _bossSpawner = ServiceLocator.Instance?.Get<BossSpawner>();
        
        InitializeSuggestions();
    }
    
    /// <summary>
    /// âœ… Ã–nerileri baÅŸlat
    /// </summary>
    void InitializeSuggestions() {
        // âœ… Give komutu iÃ§in item listesi
        if (!_suggestionCache.ContainsKey("give")) {
            _suggestionCache["give"] = new Dictionary<int, List<string>>();
        }
        
        // âœ… Spawn komutu iÃ§in mob/boss listesi
        if (!_suggestionCache.ContainsKey("spawn")) {
            _suggestionCache["spawn"] = new Dictionary<int, List<string>>();
        }
    }
    
    /// <summary>
    /// âœ… Ã–nerileri al
    /// </summary>
    public List<string> GetSuggestions(string command, string[] args, int argIndex) {
        command = command.ToLower();
        
        // âœ… Komut Ã¶nerileri (argIndex == -1)
        if (argIndex == -1) {
            return GetCommandSuggestions(command);
        }
        
        // âœ… Parametre Ã¶nerileri
        switch (command) {
            case "give":
                return GetGiveSuggestions(args, argIndex);
            case "spawn":
                return GetSpawnSuggestions(args, argIndex);
            case "disaster":
                return GetDisasterSuggestions(args, argIndex);
            case "siege":
                return GetSiegeSuggestions(args, argIndex);
            case "clan":
                return GetClanSuggestions(args, argIndex);
            case "contract":
                return GetContractSuggestions(args, argIndex);
        }
        
        return new List<string>();
    }
    
    /// <summary>
    /// âœ… Komut Ã¶nerileri
    /// </summary>
    List<string> GetCommandSuggestions(string partialCommand) {
        string[] commands = { "give", "spawn", "disaster", "siege", "clan", "contract", "supply_drop", "reload", "help" };
        
        return commands
            .Where(c => c.StartsWith(partialCommand, System.StringComparison.OrdinalIgnoreCase))
            .Take(maxSuggestions)
            .ToList();
    }
    
    /// <summary>
    /// âœ… Give komutu Ã¶nerileri
    /// </summary>
    List<string> GetGiveSuggestions(string[] args, int argIndex) {
        if (argIndex == 0) {
            // âœ… Item listesi Ã¶ner
            if (_itemDatabase != null) {
                // âœ… TODO: ItemDatabase.GetAllItemIds() metodu ekle
                // Åimdilik Ã¶rnek item listesi
                string[] items = { "DIAMOND", "EMERALD", "NETHERITE", "TITANIUM", "RED_DIAMOND" };
                
                string filter = args.Length > 0 ? args[0] : "";
                return items
                    .Where(id => id.StartsWith(filter, System.StringComparison.OrdinalIgnoreCase))
                    .Take(maxSuggestions)
                    .ToList();
            }
        }
        
        return new List<string>();
    }
    
    /// <summary>
    /// âœ… Spawn komutu Ã¶nerileri
    /// </summary>
    List<string> GetSpawnSuggestions(string[] args, int argIndex) {
        if (argIndex == 0) {
            // âœ… Spawn tipi Ã¶ner
            string[] types = { "mob", "boss", "supply_drop" };
            string filter = args.Length > 0 ? args[0] : "";
            return types
                .Where(t => t.StartsWith(filter, System.StringComparison.OrdinalIgnoreCase))
                .ToList();
        } else if (argIndex == 1 && args.Length > 0 && args[0].ToLower() == "mob") {
            // âœ… Mob listesi Ã¶ner
            string[] mobs = { "goblin", "ork", "troll", "wolf", "bear" };
            string filter = args.Length > 1 ? args[1] : "";
            return mobs
                .Where(m => m.StartsWith(filter, System.StringComparison.OrdinalIgnoreCase))
                .Take(maxSuggestions)
                .ToList();
        } else if (argIndex == 1 && args.Length > 0 && args[0].ToLower() == "boss") {
            // âœ… Boss listesi Ã¶ner
            string[] bosses = { "titan_golem", "dragon", "trex", "cyclops", "hydra", "phoenix" };
            string filter = args.Length > 1 ? args[1] : "";
            return bosses
                .Where(b => b.StartsWith(filter, System.StringComparison.OrdinalIgnoreCase))
                .Take(maxSuggestions)
                .ToList();
        }
        
        return new List<string>();
    }
    
    /// <summary>
    /// âœ… Disaster komutu Ã¶nerileri
    /// </summary>
    List<string> GetDisasterSuggestions(string[] args, int argIndex) {
        if (argIndex == 0) {
            string[] disasters = { "catastrophic_titan", "solar_flare", "earthquake", "meteor_shower" };
            string filter = args.Length > 0 ? args[0] : "";
            return disasters
                .Where(d => d.StartsWith(filter, System.StringComparison.OrdinalIgnoreCase))
                .Take(maxSuggestions)
                .ToList();
        }
        
        return new List<string>();
    }
    
    /// <summary>
    /// âœ… Siege komutu Ã¶nerileri
    /// </summary>
    List<string> GetSiegeSuggestions(string[] args, int argIndex) {
        if (argIndex == 0) {
            string[] actions = { "clear", "list", "start" };
            string filter = args.Length > 0 ? args[0] : "";
            return actions
                .Where(a => a.StartsWith(filter, System.StringComparison.OrdinalIgnoreCase))
                .ToList();
        }
        
        return new List<string>();
    }
    
    /// <summary>
    /// âœ… Clan komutu Ã¶nerileri
    /// </summary>
    List<string> GetClanSuggestions(string[] args, int argIndex) {
        if (argIndex == 0) {
            string[] actions = { "create", "disband", "info" };
            string filter = args.Length > 0 ? args[0] : "";
            return actions
                .Where(a => a.StartsWith(filter, System.StringComparison.OrdinalIgnoreCase))
                .ToList();
        }
        
        return new List<string>();
    }
    
    /// <summary>
    /// âœ… Contract komutu Ã¶nerileri
    /// </summary>
    List<string> GetContractSuggestions(string[] args, int argIndex) {
        if (argIndex == 0) {
            string[] actions = { "list", "clear" };
            string filter = args.Length > 0 ? args[0] : "";
            return actions
                .Where(a => a.StartsWith(filter, System.StringComparison.OrdinalIgnoreCase))
                .ToList();
        }
        
        return new List<string>();
    }
}
```

**Optimizasyon:**
- âœ… Dictionary cache (Ã¶neriler)
- âœ… Context-aware completion (komut ve argIndex bazlÄ±)
- âœ… LINQ filtering (performanslÄ± filtreleme)

**Referanslar:**
- [Unity Input System](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.0/manual/index.html)
- [LINQ Documentation](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/)

**KÃ¼tÃ¼phane:** Unity Input System (yerleÅŸik), LINQ (System.Linq)

---

## âš™ï¸ CONFIG YÃ–NETÄ°M SÄ°STEMÄ°

### 3.1 ConfigManager (Singleton)

**Dosya:** `Assets/_Stratocraft/Scripts/Core/Config/ConfigManager.cs`

**Ã–zellikler:**
- Merkezi config yÃ¶netimi
- ScriptableObject tabanlÄ±
- Runtime config deÄŸiÅŸiklikleri
- Hot reload desteÄŸi

**Teknolojiler:**
- **ScriptableObject** - Config verileri
- **Unity Editor** - Runtime config editor
- **JSON** (opsiyonel) - Config export/import

**Kod Ã–rneÄŸi:**
```csharp
// ConfigManager.cs - Config yÃ¶netimi
public class ConfigManager : MonoBehaviour {
    public static ConfigManager Instance;
    
    [Header("Config'ler")]
    public GameBalanceConfig gameBalance;
    public DisasterConfig disaster;
    public TerritoryConfig territory;
    
    void Awake() {
        Instance = this;
        LoadConfigs();
    }
    
    void LoadConfigs() {
        // ScriptableObject'lerden yÃ¼kle
        gameBalance = Resources.Load<GameBalanceConfig>("Config/GameBalanceConfig");
        disaster = Resources.Load<DisasterConfig>("Config/DisasterConfig");
        territory = Resources.Load<TerritoryConfig>("Config/TerritoryConfig");
    }
    
    // Runtime config deÄŸiÅŸikliÄŸi
    public void UpdateConfig<T>(T config) where T : ScriptableObject {
        EditorUtility.SetDirty(config);
        AssetDatabase.SaveAssets();
    }
}
```

**KÃ¼tÃ¼phane:** Unity ScriptableObject (yerleÅŸik)

---

### 3.2 ScriptableObject Config'ler

**Config DosyalarÄ±:**
- `GameBalanceConfig.asset` - Oyun dengesi
- `DisasterConfig.asset` - Felaket ayarlarÄ±
- `TerritoryConfig.asset` - BÃ¶lge ayarlarÄ±
- `ClanProtectionConfig.asset` - Klan koruma ayarlarÄ±
- `SiegeConfig.asset` - KuÅŸatma ayarlarÄ±
- `BossConfig.asset` - Boss ayarlarÄ±
- `MobConfig.asset` - Mob ayarlarÄ±
- `EconomyConfig.asset` - Ekonomi ayarlarÄ±

**Ã–rnek Config YapÄ±sÄ±:**
```csharp
// GameBalanceConfig.cs - ScriptableObject
[CreateAssetMenu(menuName = "Stratocraft/Config/GameBalance")]
public class GameBalanceConfig : ScriptableObject {
    [Header("Kervan Sistemi")]
    [Tooltip("Minimum mesafe (blok)")]
    public int caravanMinDistance = 1000;
    
    [Tooltip("Minimum stack sayÄ±sÄ±")]
    public int caravanMinStacks = 20;
    
    [Tooltip("DeÄŸer Ã§arpanÄ± (hedefe ulaÅŸÄ±nca)")]
    [Range(1f, 2f)]
    public float caravanValueMultiplier = 1.5f;
    
    [Header("AraÅŸtÄ±rma Sistemi")]
    [Tooltip("AraÅŸtÄ±rma masasÄ± yarÄ±Ã§apÄ± (blok)")]
    [Range(5f, 20f)]
    public float researchTableDistance = 10f;
    
    [Header("Ãœreme Sistemi")]
    [Tooltip("DoÄŸal Ã§iftleÅŸtirme sÃ¼resi (saniye)")]
    [Range(30f, 300f)]
    public float breedingNaturalDuration = 60f;
}
```

**KullanÄ±m:**
```csharp
// Herhangi bir sistemden config'e eriÅŸim
var config = ConfigManager.Instance.gameBalance;
float multiplier = config.caravanValueMultiplier; // 1.5f
```

---

### 3.3 Runtime Config DeÄŸiÅŸiklikleri

**Dosya:** `Assets/_Stratocraft/Editor/ConfigEditor.cs` (Editor Only)

**Ã–zellikler:**
- Unity Editor Window
- Runtime config deÄŸiÅŸiklikleri
- Hot reload
- Validation

**Teknolojiler:**
- **Unity Editor** - Custom Editor Window
- **ScriptableObject** - Runtime deÄŸiÅŸiklikler

**Kod Ã–rneÄŸi:**
```csharp
// ConfigEditor.cs - Editor Window
[CustomEditor(typeof(GameBalanceConfig))]
public class ConfigEditor : Editor {
    public override void OnInspectorGUI() {
        var config = (GameBalanceConfig)target;
        
        EditorGUI.BeginChangeCheck();
        
        // Config deÄŸerlerini dÃ¼zenle
        config.caravanMinDistance = EditorGUILayout.IntField("Min Mesafe", config.caravanMinDistance);
        config.caravanValueMultiplier = EditorGUILayout.Slider("DeÄŸer Ã‡arpanÄ±", 
            config.caravanValueMultiplier, 1f, 2f);
        
        if (EditorGUI.EndChangeCheck()) {
            EditorUtility.SetDirty(config);
            AssetDatabase.SaveAssets();
            
            // Runtime'da gÃ¼ncelle
            if (Application.isPlaying) {
                ConfigManager.Instance?.LoadConfigs();
            }
        }
    }
}
```

**KÃ¼tÃ¼phane:** Unity Editor API (yerleÅŸik)

---

## âœ… FAZ 8 BÄ°TÄ°Å RAPORU

Bu adÄ±mlarÄ± tamamladÄ±ÄŸÄ±nda projenin durumu ÅŸu olacak:

1. **TÃ¼m Oyun Sistemleri:** Kervan, AraÅŸtÄ±rma, Ãœreme, Market, GÃ¶rev, Supply Drop, KuÅŸatma SilahlarÄ±, Hayalet Tarif, Ä°ttifak - Hepsi Unity'de Ã§alÄ±ÅŸÄ±yor.

2. **Admin Komut Sistemi:** TÃ¼m sistemleri test etmek iÃ§in kapsamlÄ± admin komutlarÄ± hazÄ±r.

3. **Config YÃ¶netim Sistemi:** TÃ¼m ayarlar merkezi olarak yÃ¶netiliyor, runtime'da deÄŸiÅŸtirilebiliyor.

### ğŸ“ˆ GÃ¼ncel Dosya YapÄ±sÄ± (Eklenenler)

```text
Assets/_Stratocraft/
â”œâ”€â”€ Scripts/
â”‚   â”œâ”€â”€ Systems/
â”‚   â”‚   â”œâ”€â”€ Economy/
â”‚   â”‚   â”‚   â”œâ”€â”€ CaravanManager.cs (YENÄ°)
â”‚   â”‚   â”‚   â””â”€â”€ ShopManager.cs (YENÄ°)
â”‚   â”‚   â”œâ”€â”€ Research/
â”‚   â”‚   â”‚   â””â”€â”€ ResearchManager.cs (YENÄ°)
â”‚   â”‚   â”œâ”€â”€ Taming/
â”‚   â”‚   â”‚   â””â”€â”€ BreedingManager.cs (YENÄ°)
â”‚   â”‚   â”œâ”€â”€ Missions/
â”‚   â”‚   â”‚   â””â”€â”€ MissionManager.cs (YENÄ°)
â”‚   â”‚   â”œâ”€â”€ Events/
â”‚   â”‚   â”‚   â””â”€â”€ SupplyDropManager.cs (YENÄ°)
â”‚   â”‚   â”œâ”€â”€ Combat/
â”‚   â”‚   â”‚   â””â”€â”€ SiegeWeaponManager.cs (YENÄ°)
â”‚   â”‚   â”œâ”€â”€ Rituals/
â”‚   â”‚   â”‚   â””â”€â”€ GhostRecipeManager.cs (YENÄ°)
â”‚   â”‚   â”œâ”€â”€ Clans/
â”‚   â”‚   â”‚   â””â”€â”€ AllianceManager.cs (YENÄ°)
â”‚   â”‚   â””â”€â”€ Admin/
â”‚   â”‚       â”œâ”€â”€ AdminCommandHandler.cs (YENÄ°)
â”‚   â”‚       â””â”€â”€ AdminTabCompleter.cs (YENÄ°)
â”‚   â”‚
â”‚   â””â”€â”€ Core/
â”‚       â””â”€â”€ Config/
â”‚           â”œâ”€â”€ ConfigManager.cs (YENÄ°)
â”‚           â””â”€â”€ Configs/ (YENÄ°)
â”‚               â”œâ”€â”€ GameBalanceConfig.cs
â”‚               â”œâ”€â”€ DisasterConfig.cs
â”‚               â””â”€â”€ ... (diÄŸer config'ler)
â”‚
â””â”€â”€ Data/
    â””â”€â”€ Config/
        â”œâ”€â”€ GameBalanceConfig.asset (YENÄ°)
        â””â”€â”€ ... (diÄŸer config asset'leri)
```

### ğŸ§ª Test AdÄ±mlarÄ±

**Test 1: Admin KomutlarÄ±**
1. `/scadmin help` - Komut listesini gÃ¶r
2. `/scadmin give tool trap_core` - Ã–zel item ver
3. `/scadmin spawn titan_golem` - Boss spawn et
4. `/scadmin disaster titan_golem` - Felaket tetikle

**Test 2: Config Sistemi**
1. ConfigManager'dan config yÃ¼kle
2. Runtime'da config deÄŸiÅŸtir
3. Hot reload test et
4. Validation kontrolÃ¼ yap

**Test 3: Eksik Sistemler**
1. Kervan oluÅŸtur, hedefe ulaÅŸ
2. AraÅŸtÄ±rma MasasÄ± kur, tarif paylaÅŸ
3. Ãœreme tesisinde Ã§iftleÅŸtirme yap
4. Market kur, alÄ±ÅŸveriÅŸ yap
5. GÃ¶rev al, tamamla
6. Supply Drop yakala
7. Balista kur, ateÅŸ et
8. Hayalet tarif gÃ¶ster
9. Ä°ttifak kur, ihlal et

---

**Son GÃ¼ncelleme:** BugÃ¼n  
**Durum:** âœ… FAZ 8 TAMAMLANDI - TÃ¼m Eksik Sistemler, Admin KomutlarÄ± ve Config YÃ¶netimi HazÄ±r

---

# ğŸ“‚ NÄ°HAÄ° STRATOCRAFT DOSYA YAPISI (FAZ 8 SONRASI - TAM LÄ°STE)

Bu listenin **tek ve gÃ¼ncel sÃ¼rÃ¼mÃ¼** dosyanÄ±n en sonunda, aynÄ± baÅŸlÄ±k altÄ±nda tutulur (tek kaynak).  
LÃ¼tfen nihai aÄŸaÃ§ iÃ§in **en alttaki** `# ğŸ“‚ NÄ°HAÄ° STRATOCRAFT DOSYA YAPISI (FAZ 8 SONRASI - TAM LÄ°STE)` bÃ¶lÃ¼mÃ¼ne bak.

---

# ğŸ“Š FAZ 8 Ã–ZET RAPORU

## ğŸ¯ FAZ 8: EKSÄ°K SÄ°STEMLER, ADMIN KOMUTLARI VE CONFIG YÃ–NETÄ°MÄ°

### âœ… Tamamlanan Ã–zellikler

#### 1. Eksik Oyun Sistemleri (9 Sistem)

**1.1 Kervan Sistemi**
- **Teknoloji:** Unity NavMesh, FishNet
- **Ã–zellik:** Uzak mesafe ticaret (min 1000 blok), x1.5 deÄŸer bonusu
- **Kod:** `CaravanManager.cs` - Async pathfinding, arrival detection

**1.2 AraÅŸtÄ±rma Sistemi**
- **Teknoloji:** ScriptableObject, Unity Physics (OverlapSphere)
- **Ã–zellik:** Tarif KitabÄ± paylaÅŸÄ±mÄ± (10 blok yarÄ±Ã§ap)
- **Kod:** `ResearchManager.cs` - Lectern kontrolÃ¼, envanter kontrolÃ¼

**1.3 Ãœreme Sistemi**
- **Teknoloji:** Unity Coroutines, FishNet
- **Ã–zellik:** Breeding Core ile Ã§iftleÅŸtirme, Memeli vs Yumurtlayan
- **Kod:** `BreedingManager.cs` - Async breeding, offspring spawn

**1.4 Market Sistemi**
- **Teknoloji:** TextMeshPro, DoTween, SQLite
- **Ã–zellik:** SandÄ±k + Tabela market, Teklif sistemi, %5 vergi
- **Kod:** `ShopManager.cs` - AlÄ±ÅŸveriÅŸ, vergi hesaplama

**1.5 GÃ¶rev Sistemi**
- **Teknoloji:** ScriptableObject, Event System
- **Ã–zellik:** 8 gÃ¶rev tipi, 4 zorluk seviyesi, Otomatik ilerleme
- **Kod:** `MissionManager.cs` - Progress tracking, reward system

**1.6 Supply Drop Sistemi**
- **Teknoloji:** DoTween, FishNet
- **Ã–zellik:** GÃ¶kyÃ¼zÃ¼nden dÃ¼ÅŸen hazine, Ä°lk bulan alÄ±r
- **Kod:** `SupplyDropManager.cs` - Parachute animation, loot table

**1.7 KuÅŸatma SilahlarÄ±**
- **Teknoloji:** Unity Physics (Rigidbody), FishNet
- **Ã–zellik:** Balista (30 mermi), MancÄ±nÄ±k (alan hasarÄ±)
- **Kod:** `SiegeWeaponManager.cs` - Projectile physics, ammo system

**1.8 Hayalet Tarif Sistemi**
- **Teknoloji:** TextMeshPro, Unity LineRenderer
- **Ã–zellik:** GÃ¶rsel rehber, Blok yerleÅŸtirme Ã§izgileri
- **Kod:** `GhostRecipeManager.cs` - Hologram system, distance cleanup

**1.9 Ä°ttifak Sistemi**
- **Teknoloji:** SQLite, RitualManager
- **Ã–zellik:** Klanlar arasÄ± anlaÅŸmalar, Ä°hlal cezasÄ±
- **Kod:** `AllianceManager.cs` - Ritual kontrolÃ¼, violation tracking

#### 2. Admin Komut Sistemi

**2.1 AdminCommandHandler**
- **Teknoloji:** FishNet, Unity Input System
- **Ã–zellik:** 20+ admin komutu, Permission sistemi
- **Kod:** `AdminCommandHandler.cs` - Komut parsing, execution

**2.2 Tab Completion**
- **Teknoloji:** Unity Input System, LINQ
- **Ã–zellik:** Dinamik Ã¶neriler, Context-aware completion
- **Kod:** `AdminTabCompleter.cs` - Suggestion system, filtering

#### 3. Config YÃ¶netim Sistemi

**3.1 ConfigManager**
- **Teknoloji:** ScriptableObject, Unity Editor API
- **Ã–zellik:** Merkezi config yÃ¶netimi, Hot reload
- **Kod:** `ConfigManager.cs` - Config loading, runtime updates

**3.2 ScriptableObject Config'ler**
- **Teknoloji:** Unity ScriptableObject
- **Ã–zellik:** 8 farklÄ± config dosyasÄ± (GameBalance, Disaster, Territory, vb.)
- **Kod:** `GameBalanceConfig.cs` - Config tanÄ±mlarÄ±

**3.3 Runtime Config Editor**
- **Teknoloji:** Unity Editor Window
- **Ã–zellik:** Runtime config deÄŸiÅŸiklikleri, Validation
- **Kod:** `ConfigEditor.cs` - Custom editor, hot reload

---

### ğŸ“š KULLANILAN TEKNOLOJÄ°LER VE KÃœTÃœPHANELER (FAZ 8)

| Ã–zellik | Teknoloji/KÃ¼tÃ¼phane | Kaynak | AÃ§Ä±klama |
|---------|-------------------|--------|----------|
| **Kervan Pathfinding** | Unity NavMesh Components | Unity Asset Store | Mule otomatik yol bulur |
| **AraÅŸtÄ±rma KontrolÃ¼** | Unity Physics (OverlapSphere) | Unity YerleÅŸik | 10 blok yarÄ±Ã§ap kontrolÃ¼ |
| **Ãœreme SÃ¼reci** | Unity Coroutines | Unity YerleÅŸik | Async breeding |
| **Market UI** | DoTween | Asset Store (Free) | UI animasyonlarÄ± |
| **GÃ¶rev Sistemi** | Unity Event System | Unity YerleÅŸik | Ä°lerleme takibi |
| **Supply Drop Animasyon** | DoTween | Asset Store (Free) | ParaÅŸÃ¼t dÃ¼ÅŸÃ¼ÅŸ animasyonu |
| **KuÅŸatma SilahlarÄ±** | Unity Physics (Rigidbody) | Unity YerleÅŸik | Projectile physics |
| **Hayalet Tarif** | TextMeshPro, LineRenderer | Unity YerleÅŸik | Hologram ve Ã§izgiler |
| **Ä°ttifak VeritabanÄ±** | SQLite (sqlite-net-pcl) | NuGet | Ä°ttifak kayÄ±tlarÄ± |
| **Admin Komutlar** | Unity Input System | Unity YerleÅŸik | Tab completion |
| **Config YÃ¶netimi** | Unity ScriptableObject | Unity YerleÅŸik | Config verileri |
| **Config Editor** | Unity Editor API | Unity YerleÅŸik | Runtime config editor |

---

### ğŸ® FAZ 8 TEST SENARYOLARI

**Test 1: Kervan Sistemi**
```
1. Kervan oluÅŸtur (min 1000 blok mesafe)
2. Mule hedefe gider (NavMesh)
3. Hedefe ulaÅŸÄ±nca x1.5 deÄŸer bonusu
```

**Test 2: AraÅŸtÄ±rma Sistemi**
```
1. Tarif KitabÄ± bul (Boss'tan)
2. AraÅŸtÄ±rma MasasÄ± kur (Lectern + Crafting Table)
3. 10 blok yarÄ±Ã§apta tarif paylaÅŸÄ±lÄ±r
```

**Test 3: Ãœreme Sistemi**
```
1. Breeding Core yerleÅŸtir
2. 1 DiÅŸi + 1 Erkek canlÄ± getir
3. Ã‡iftleÅŸtirme baÅŸlar (coroutine)
4. Yavru/Yumurta spawn olur
```

**Test 4: Market Sistemi**
```
1. SandÄ±k + Tabela ile market kur
2. Item sat, alÄ±ÅŸveriÅŸ yap
3. Teklif ver (alternatif Ã¶deme)
4. %5 vergi kontrolÃ¼
```

**Test 5: GÃ¶rev Sistemi**
```
1. Totem'e saÄŸ tÄ±k, gÃ¶rev al
2. GÃ¶rev tipine gÃ¶re ilerleme takip et
3. Tamamla, Ã¶dÃ¼l al
```

**Test 6: Supply Drop**
```
1. Supply Drop spawn et (gÃ¶kyÃ¼zÃ¼nden)
2. ParaÅŸÃ¼t animasyonu (DoTween)
3. Ä°lk bulan alÄ±r
4. Loot table'dan Ã¶dÃ¼l
```

**Test 7: KuÅŸatma SilahlarÄ±**
```
1. Balista kur, bin
2. Sol tÄ±kla = ateÅŸ et
3. Mermi fÄ±rlat (Rigidbody physics)
4. MancÄ±nÄ±k = alan hasarÄ±
```

**Test 8: Hayalet Tarif**
```
1. RitÃ¼el baÅŸlat
2. Hologram gÃ¶ster (TextMeshPro)
3. Blok yerleÅŸtirme Ã§izgileri (LineRenderer)
4. Mesafe kontrolÃ¼ (otomatik temizleme)
```

**Test 9: Ä°ttifak Sistemi**
```
1. 2 Lider ritÃ¼el yap (Elmas ile)
2. Ä°ttifak kurulur (SQLite kayÄ±t)
3. Ä°ttifaklÄ± klanlara saldÄ±rÄ±lamaz
4. Ä°hlal = ceza (%20 bakiye + Hain etiketi)
```

**Test 10: Admin KomutlarÄ±**
```
1. /scadmin help - Komut listesi
2. /scadmin give tool trap_core - Item ver
3. /scadmin spawn titan_golem - Boss spawn
4. /scadmin disaster titan_golem - Felaket tetikle
```

**Test 11: Config Sistemi**
```
1. ConfigManager'dan config yÃ¼kle
2. Runtime'da config deÄŸiÅŸtir (Editor Window)
3. Hot reload test et
4. Validation kontrolÃ¼
```

---

### ğŸ“ˆ PROJE DURUMU (FAZ 8 SONRASI)

**Tamamlanan Fazlar:**
- âœ… Faz 1 & 2: AltyapÄ± ve DÃ¼nya OluÅŸumu
- âœ… Faz 3: DoÄŸa, Su ve Biyomlar
- âœ… Faz 4: Oyun Mekanikleri
- âœ… Faz 5: Yapay Zeka, SavaÅŸ ve Felaketler
- âœ… Faz 6: ArayÃ¼z (UI), EtkileÅŸim ve Cila
- âœ… Faz 7: GÃ¼Ã§ Sistemi, Binekler ve SavaÅŸ Makineleri
- âœ… Faz 8: Eksik Sistemler, Admin KomutlarÄ± ve Config YÃ¶netimi

**Toplam Sistem SayÄ±sÄ±:** 51+ sistem (Blok Åekillendirme Sistemi eklendi)
**Toplam Dosya SayÄ±sÄ±:** 210+ dosya (ChiselTool, BlockCuttingSystem, vb. eklendi)
**KullanÄ±lan Teknoloji:** 15+ teknoloji/kÃ¼tÃ¼phane

---

### ğŸ¯ SONUÃ‡

Faz 8 ile birlikte Stratocraft Unity dÃ¶nÃ¼ÅŸÃ¼mÃ¼ **tamamlandÄ±**. TÃ¼m oyun sistemleri, admin komutlarÄ± ve config yÃ¶netimi hazÄ±r. Proje artÄ±k **1000 kiÅŸilik MMO sunucu** iÃ§in hazÄ±r durumda.

**SÄ±radaki AdÄ±mlar:**
1. Kod implementasyonu (Faz 1'den baÅŸlayarak)
2. Test ve debug
3. Balance ayarlarÄ±
4. Performans optimizasyonlarÄ±
5. Beta test
6. Release

---

**Son GÃ¼ncelleme:** BugÃ¼n  
**Durum:** âœ… TÃœM FAZLAR TAMAMLANDI - Stratocraft Unity DÃ¶nÃ¼ÅŸÃ¼mÃ¼ HazÄ±r

---

# ğŸ“š TÃœM FAZLARIN KAPSAMLI Ã–ZET RAPORU

Bu bÃ¶lÃ¼m, **Faz 1'den Faz 8'e kadar** eklenen tÃ¼m Ã¶zelliklerin, teknolojilerin ve sistemlerin detaylÄ± Ã¶zetini iÃ§erir.

---

## ğŸš€ FAZ 1 & 2: ALTYAPI KURULUMU VE DÃœNYA OLUÅUMU

### âœ… Eklenen Ã–zellikler

**1. Temel AltyapÄ±:**
- âœ… ServiceLocator (Merkezi sistem yÃ¶neticisi)
- âœ… GameEntry (Oyun baÅŸlatÄ±cÄ±)
- âœ… NetworkBootstrap (FishNet ayarlarÄ±)
- âœ… DatabaseManager (SQLite entegrasyonu)

**2. Sonsuz DÃ¼nya Sistemi:**
- âœ… ChunkManager (Chunk yÃ¼kleme/kaldÄ±rma)
- âœ… TerrainDensity.compute (GPU voxel oluÅŸturma)
- âœ… Infinite world generation (Sonsuz dÃ¼nya)
- âœ… Chunk-based caching (Performans optimizasyonu)

**3. KazÄ± Sistemi:**
- âœ… NetworkMining.cs (Server-authoritative kazÄ±)
- âœ… Dig cooldown (Spam Ã¶nleme)
- âœ… Anti-cheat (Server-side validation)
- âœ… Chunk update synchronization

### ğŸ› ï¸ KullanÄ±lan Teknolojiler

| Teknoloji | Kaynak | AÃ§Ä±klama |
|-----------|--------|----------|
| **FishNet** | GitHub (AÃ§Ä±k Kaynak) | AÄŸ motoru, NetworkBehaviour |
| **Scrawk** | GitHub (AÃ§Ä±k Kaynak) | GPU voxel motoru, Marching Cubes |
| **FastNoiseLite** | GitHub (AÃ§Ä±k Kaynak) | Biyom matematiÄŸi, gÃ¼rÃ¼ltÃ¼ fonksiyonlarÄ± |
| **SQLite** | NuGet (sqlite-net-pcl) | VeritabanÄ±, ACID Ã¶zellikleri |
| **Unity Input System** | Unity YerleÅŸik | Oyuncu input yÃ¶netimi |

### ğŸ“‚ Eklenen Dosyalar

```
Assets/_Stratocraft/
â”œâ”€â”€ _Bootstrap/
â”‚   â”œâ”€â”€ ServiceLocator.cs
â”‚   â”œâ”€â”€ GameEntry.cs
â”‚   â””â”€â”€ NetworkBootstrap.cs
â”œâ”€â”€ Engine/
â”‚   â”œâ”€â”€ ComputeShaders/
â”‚   â”‚   â””â”€â”€ TerrainDensity.compute
â”‚   â””â”€â”€ Core/
â”‚       â””â”€â”€ ChunkManager.cs
â””â”€â”€ Scripts/
    â”œâ”€â”€ Core/
    â”‚   â””â”€â”€ DatabaseManager.cs
    â””â”€â”€ Systems/
        â””â”€â”€ Mining/
            â””â”€â”€ NetworkMining.cs
```

### ğŸ¯ SonuÃ§

- âœ… Sonsuz, kazÄ±labilir dÃ¼nya hazÄ±r
- âœ… Server-authoritative kazÄ± sistemi Ã§alÄ±ÅŸÄ±yor
- âœ… VeritabanÄ± entegrasyonu tamamlandÄ±
- âœ… Temel altyapÄ± kuruldu

---

## ğŸŒ FAZ 3: DOÄA, SU VE BÄ°YOMLAR

### âœ… Eklenen Ã–zellikler

**1. Biyom Sistemi:**
- âœ… BiomeDefinition.cs (ScriptableObject)
- âœ… BiomeManager.cs (Biyom seÃ§imi)
- âœ… Temperature & Humidity haritasÄ±
- âœ… Biome blending (YumuÅŸak geÃ§iÅŸler)

**2. DoÄŸa Objeleri:**
- âœ… VegetationSpawner.cs (GPU Instancing)
- âœ… Tree/rock placement (Binlerce aÄŸaÃ§/kaya)
- âœ… Object Pooling (Performans optimizasyonu)
- âœ… Density-based spawning

**3. Su Sistemi:**
- âœ… OceanPlane.cs (Sonsuz okyanus)
- âœ… WaterSim.compute (Opsiyonel voxel su)
- âœ… Y=0 seviyesi okyanus
- âœ… Transparent material

**4. MaÄŸara Sistemi:**
- âœ… 3D Noise ile maÄŸara oluÅŸturma
- âœ… Yer altÄ± boÅŸluklarÄ±
- âœ… Cave generation (TerrainDensity.compute iÃ§inde)

### ğŸ› ï¸ KullanÄ±lan Teknolojiler

| Teknoloji | Kaynak | AÃ§Ä±klama |
|-----------|--------|----------|
| **GPU Instancing** | Unity YerleÅŸik | Binlerce aÄŸaÃ§/kaya render |
| **Object Pooling** | Unity Pattern | Performans optimizasyonu |
| **Shader Graph** | Unity YerleÅŸik | Okyanus materyali |
| **FastNoiseLite** | GitHub | Biyom ve maÄŸara gÃ¼rÃ¼ltÃ¼sÃ¼ |

### ğŸ“‚ Eklenen Dosyalar

```
Assets/_Stratocraft/
â”œâ”€â”€ Engine/
â”‚   â”œâ”€â”€ ComputeShaders/
â”‚   â”‚   â”œâ”€â”€ TerrainDensity.compute (GÃ¼ncellendi)
â”‚   â”‚   â””â”€â”€ WaterSim.compute (Opsiyonel)
â”‚   â””â”€â”€ Core/
â”‚       â”œâ”€â”€ BiomeManager.cs
â”‚       â”œâ”€â”€ VegetationSpawner.cs
â”‚       â””â”€â”€ OceanPlane.cs
â””â”€â”€ Data/
    â””â”€â”€ Biomes/
        â”œâ”€â”€ DesertDef.asset
        â”œâ”€â”€ ForestDef.asset
        â””â”€â”€ MountainDef.asset
```

### ğŸ¯ SonuÃ§

- âœ… Ã‡Ã¶l, Orman, DaÄŸ biyomlarÄ± hazÄ±r
- âœ… Binlerce aÄŸaÃ§/kaya GPU Instancing ile render ediliyor
- âœ… Sonsuz okyanus (Y=0) eklendi
- âœ… MaÄŸara sistemi Ã§alÄ±ÅŸÄ±yor

---

## ğŸ® FAZ 4: OYUN MEKANÄ°KLERÄ°

### âœ… Eklenen Ã–zellikler

**1. Item Sistemi:**
- âœ… ItemDefinition.cs (ScriptableObject)
- âœ… PhysicalItem.cs (Fiziksel item)
- âœ… ItemDatabase.cs (Item lookup)
- âœ… ItemSpawner.cs (Item spawn)
- âœ… ItemDefinition gÃ¼ncellemeleri (isChisel, chiselDefinition, chiselLevel - FAZ 4)
- âœ… ItemDefinition gÃ¼ncellemeleri (isFood, foodDefinition, isCureItem - ADIM 1.14, 1.15)
- âœ… ItemDefinition gÃ¼ncellemeleri (isTool, maxDurability, toolLevel, enchantments - ADIM 1.9)

**1.5. Blok Åekillendirme Sistemi (ADIM 1.5):**
- âœ… ChiselTool.cs (Blok ÅŸekillendirme aleti - IEquippable interface)
- âœ… ChiselRaycast.cs (Voxel terrain uyumlu raycast - cache optimizasyonu)
- âœ… BlockSelectionVisualizer.cs (SeÃ§im gÃ¶rselleÅŸtirme - marker'lar, Ã§izgiler)
- âœ… BlockCuttingSystem.cs (Blok kesim sistemi - VariantMeshGenerator entegrasyonu)
- âœ… ShapeApplicationSystem.cs (Åekil kaydetme/uygulama - 9 slot sistemi)
- âœ… ChiselDefinition.cs (ScriptableObject - Alet tanÄ±mlarÄ±)
- âœ… CutMode.cs (Enum'lar: CutMode, MaterialType, CutParameters)
- âœ… 3 kesim modu (KÃ¼p, Yuvarlak, Ã‡apraz)
- âœ… Ä°ki nokta seÃ§imi sistemi (baÅŸlangÄ±Ã§/bitiÅŸ noktasÄ±)
- âœ… GÃ¶rsel Ã¶nizleme (kesim Ã¶ncesi mesh gÃ¶sterimi)
- âœ… 9 slot ÅŸekil kayÄ±t sistemi (1-9 tuÅŸlarÄ±)
- âœ… NetworkMining entegrasyonu (IEquippable interface, EnableChiselMode/DisableChiselMode)
- âœ… VariantMeshGenerator entegrasyonu (Variant ID formatÄ± uyumlu)
- âœ… ChunkManager entegrasyonu (SetBlockType, GetBlockType, RegenerateChunk)
- âœ… GridPlacementSystem entegrasyonu (SnapToGrid, WorldToGrid)

**1.6. Crafting Sistemi (ADIM 1.6):**
- âœ… CraftingRecipe.cs (ScriptableObject - Recipe tanÄ±mlarÄ±)
- âœ… CraftingTable.cs (NetworkBehaviour - Crafting table yapÄ±sÄ±)
- âœ… CraftingManager.cs (Crafting mantÄ±ÄŸÄ± - Dictionary cache, O(1) lookup)
- âœ… CraftingUI.cs (UI Manager - UI pooling, async loading)
- âœ… Recipe cache sistemi (O(1) recipe lookup)
- âœ… Crafting table seviyeleri (None, Basic, Advanced, Master)
- âœ… Malzeme kontrolÃ¼ (PlayerInventory entegrasyonu)
- âœ… ChunkManager entegrasyonu (voxel terrain uyumlu)

**1.7. KapsamlÄ± Envanter Sistemi (ADIM 1.7):**
- âœ… InventorySlot.cs (Slot veri yapÄ±sÄ±)
- âœ… PlayerInventory.cs (NetworkBehaviour - Envanter mantÄ±ÄŸÄ±)
- âœ… SyncList kullanÄ±mÄ± (network synchronization)
- âœ… Dictionary cache (O(1) item count lookup)
- âœ… Hotbar sistemi (9 slot, 1-9 tuÅŸlarÄ±)
- âœ… Item stacking (maxStack kontrolÃ¼)
- âœ… Weight sistemi (aÄŸÄ±rlÄ±k limiti)
- âœ… Async database persistence (UI donmasÄ±nÄ± Ã¶nler)

**1.8. Furniture Sistemi (ADIM 1.8):**
- âœ… FurnitureDefinition.cs (ScriptableObject - Furniture tanÄ±mlarÄ±)
- âœ… FurniturePlacer.cs (Furniture yerleÅŸtirme - StructurePlacer entegrasyonu)
- âœ… FurnitureInteraction.cs (IInteractable - Sit, Sleep, Chest, Workbench)
- âœ… Chunk bazlÄ± furniture cache
- âœ… TerritoryManager entegrasyonu (sahiplik kontrolÃ¼)
- âœ… ChunkManager entegrasyonu (voxel terrain uyumlu)

**1.9. Ä°ÅŸlevsel Item'ler (ADIM 1.9):**
- âœ… ToolDurability.cs (Durability sistemi - async database persistence)
- âœ… RepairStation.cs (Tool repair - malzeme kontrolÃ¼)
- âœ… UpgradeStation.cs (Tool upgrade - seviye artÄ±ÅŸÄ±)
- âœ… EnchantmentSystem.cs (Enchantment sistemi - Dictionary cache, O(1) lookup)
- âœ… EnchantmentDefinition.cs (ScriptableObject - Enchantment tanÄ±mlarÄ±)
- âœ… Unbreaking, Fortune, DamageBoost, SpeedBoost enchantment'larÄ±
- âœ… Repair/Upgrade malzeme sistemi

**2. RitÃ¼el Sistemi:**
- âœ… RitualRecipe.cs (ScriptableObject)
- âœ… RitualManager.cs (Batarya sistemi)
- âœ… RitualInputHandler.cs (Blok yerleÅŸtirme)
- âœ… Ghost recipe system (GÃ¶rsel rehber)

**3. Klan ve BÃ¶lge Sistemi:**
- âœ… TerritoryManager.cs (Flood-Fill algoritmasÄ±)
- âœ… ClanFence.cs (Klan Ã§iti)
- âœ… TerritoryData.cs (BÃ¶lge verileri)
- âœ… Boundary particles (SÄ±nÄ±r gÃ¶rselleÅŸtirme)

**4. Ekonomi ve Kontratlar:**
- âœ… ContractManager.cs (Kontrat sistemi)
- âœ… ContractData.cs (Kontrat verileri)
- âœ… Contract board (Fiziksel pano)
- âœ… Contract signing (Ä°mzalama sistemi)

**1.14. Yemek ve AÃ§lÄ±k Sistemi (ADIM 1.14):**
- âœ… FoodDefinition.cs (ScriptableObject - Yemek tanÄ±mlarÄ±)
- âœ… HungerSystem.cs (AÃ§lÄ±k sistemi - Coroutine, async database)
- âœ… CookingStation.cs (PiÅŸirme sistemi - IInteractable, malzeme kontrolÃ¼)
- âœ… CookingRecipe.cs (ScriptableObject - PiÅŸirme tarifleri)
- âœ… Food quality sistemi (Common, Good, Excellent, Perfect)
- âœ… Food buff sistemi (StatusEffectManager entegrasyonu)

**1.15. HastalÄ±k ve Durum Sistemi (ADIM 1.15):**
- âœ… StatusEffectDefinition.cs (ScriptableObject - Durum efekt tanÄ±mlarÄ±)
- âœ… StatusEffectManager.cs (Durum efekt yÃ¶neticisi - Coroutine, Stack sistemi)
- âœ… DiseaseSystem.cs (HastalÄ±k sistemi - Disease state cache)
- âœ… DiseaseDefinition.cs (ScriptableObject - HastalÄ±k tanÄ±mlarÄ±)
- âœ… CureItemDefinition.cs (ScriptableObject - Ä°yileÅŸtirme item tanÄ±mlarÄ±)
- âœ… Stat modifikasyonlarÄ± (speed, damage, defense multipliers)
- âœ… Particle effect entegrasyonu

**1.16. Zaman ve Hava Sistemi (ADIM 1.16):**
- âœ… WeatherSystem.cs (Hava durumu sistemi - Coroutine, mevsim bazlÄ±)
- âœ… SeasonSystem.cs (Mevsim sistemi - GameTimeManager entegrasyonu)
- âœ… TemperatureSystem.cs (SÄ±caklÄ±k sistemi - YÃ¼kseklik bazlÄ±, status effect'ler)
- âœ… WeatherEffects.cs (Hava durumu efektleri - Unity Particle System, Unity Audio)
- âœ… Hava durumu tipleri (Clear, Rain, Snow, Storm, Fog)
- âœ… Mevsimler (Spring, Summer, Autumn, Winter)

**1.17. Zindan ve MaÄŸara Sistemi (ADIM 1.17):**
- âœ… DungeonDefinition.cs (ScriptableObject - Zindan tanÄ±mlarÄ±)
- âœ… DungeonGenerator.cs (Zindan oluÅŸturma - Job System + Burst)
- âœ… DungeonEntrance.cs (Zindan giriÅŸi - Key kontrolÃ¼, IInteractable)
- âœ… Zorluk seviyeleri (Easy, Medium, Hard, Extreme)
- âœ… Key sistemi (Dungeon key kontrolÃ¼)
- âœ… BossArena entegrasyonu

**1.18. Magic ve BÃ¼yÃ¼ Sistemi (ADIM 1.18):**
- âœ… SpellDefinition.cs (ScriptableObject - BÃ¼yÃ¼ tanÄ±mlarÄ±)
- âœ… ManaSystem.cs (Mana sistemi - Coroutine, async database)
- âœ… SpellCasting.cs (BÃ¼yÃ¼ kullanma - ManaSystem entegrasyonu)
- âœ… Spell schools (Fire, Ice, Lightning, Nature, Dark, Light)
- âœ… Spell effect tipleri (Damage, Heal, Buff, Debuff, Teleport, Summon)

**1.19. Teknoloji AÄŸacÄ± (ADIM 1.19):**
- âœ… TechNodeDefinition.cs (ScriptableObject - Teknoloji dÃ¼ÄŸÃ¼m tanÄ±mlarÄ±)
- âœ… TechTreeManager.cs (Teknoloji aÄŸacÄ± yÃ¶neticisi - Prerequisite kontrolÃ¼)
- âœ… Research point sistemi
- âœ… Tech kategorileri

**1.20. AraÃ§ ve UlaÅŸÄ±m Sistemi (ADIM 1.20):**
- âœ… VehicleDefinition.cs (ScriptableObject - AraÃ§ tanÄ±mlarÄ±)
- âœ… VehicleController.cs (AraÃ§ kontrolÃ¼ - Unity Physics)
- âœ… AraÃ§ tipleri (Cart, Boat, Airship)
- âœ… YakÄ±t ve tamir sistemi

**1.21. Pet ve Ev HayvanÄ± Sistemi (ADIM 1.21):**
- âœ… PetDefinition.cs (ScriptableObject - Pet tanÄ±mlarÄ±)
- âœ… PetSystem.cs (Pet sistemi - Pet spawn, komut, leveling)
- âœ… Pet envanteri ve yetenekleri

**1.22. TarÄ±m ve Ã‡iftÃ§ilik Sistemi (ADIM 1.22):**
- âœ… CropDefinition.cs (ScriptableObject - Bitki tanÄ±mlarÄ±)
- âœ… FarmingSystem.cs (Ã‡iftÃ§ilik sistemi - Crop planting, growth, harvest)
- âœ… Growth coroutine sistemi
- âœ… Fertilizer sistemi

**1.23. BalÄ±kÃ§Ä±lÄ±k Sistemi (ADIM 1.23):**
- âœ… FishDefinition.cs (ScriptableObject - BalÄ±k tanÄ±mlarÄ±)
- âœ… FishingSystem.cs (BalÄ±kÃ§Ä±lÄ±k sistemi - Fishing minigame, fish spawn)
- âœ… Fishing rod sistemi
- âœ… Fishing spots ve rewards

**1.24. Madencilik ve Eritme Sistemi (ADIM 1.24):**
- âœ… SmeltingRecipe.cs (ScriptableObject - Eritme tarifleri)
- âœ… SmeltingSystem.cs (Eritme sistemi - Furnace entegrasyonu, fuel tÃ¼ketimi)
- âœ… Smelting time kontrolÃ¼
- âœ… Fuel sistemi

**1.25. Depolama ve SandÄ±k Sistemi (ADIM 1.25):**
- âœ… ChestDefinition.cs (ScriptableObject - SandÄ±k tanÄ±mlarÄ±)
- âœ… ChestInventory.cs (SandÄ±k envanteri - SyncList, async database, lock sistemi)
- âœ… Kategori sistemi
- âœ… TerritoryManager entegrasyonu (sahiplik kontrolÃ¼)

### ğŸ› ï¸ KullanÄ±lan Teknolojiler

| Teknoloji | Kaynak | AÃ§Ä±klama |
|-----------|--------|----------|
| **ScriptableObject** | Unity YerleÅŸik | Item, Ritual, Contract, CraftingRecipe, FurnitureDefinition, vb. tanÄ±mlarÄ± |
| **Flood-Fill Algorithm** | Custom | BÃ¶lge hesaplama (2D/3D) |
| **SQLite** | NuGet | Kontrat, bÃ¶lge, envanter, durability, vb. verileri |
| **FishNet** | GitHub | Network senkronizasyonu (SyncList, ServerRpc, ObserversRpc) |
| **Unity Job System + Burst** | Unity YerleÅŸik | Paralel iÅŸlemler (village generation, dungeon generation) |
| **Unity Coroutines** | Unity YerleÅŸik | Async operations (hunger decrease, mana regen, effect update) |
| **Unity NavMesh** | Unity YerleÅŸik | NPC pathfinding (ChunkNavMeshBaker entegrasyonu) |
| **Unity Particle System** | Unity YerleÅŸik | Weather effects, cutting effects |
| **Unity Audio** | Unity YerleÅŸik | Weather sounds |
| **Dictionary Cache** | Custom | O(1) lookup optimizasyonlarÄ± |
| **UI Pooling** | Custom | UI element pooling (performans optimizasyonu) |

### ğŸ“‚ Eklenen Dosyalar

```
Assets/_Stratocraft/
â”œâ”€â”€ Scripts/
â”‚   â”œâ”€â”€ Core/
â”‚   â”‚   â”œâ”€â”€ Definitions/
â”‚   â”‚   â”‚   â”œâ”€â”€ ItemDefinition.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ RitualRecipe.cs
â”‚   â”‚   â”‚   â””â”€â”€ ChiselDefinition.cs
â”‚   â”‚   â””â”€â”€ Models/
â”‚   â”‚       â””â”€â”€ ContractData.cs
â”‚   â””â”€â”€ Systems/
â”‚       â”œâ”€â”€ Rituals/
â”‚       â”‚   â”œâ”€â”€ RitualManager.cs
â”‚       â”‚   â””â”€â”€ RitualInputHandler.cs
â”‚       â”œâ”€â”€ Clans/
â”‚       â”‚   â”œâ”€â”€ TerritoryManager.cs
â”‚       â”‚   â””â”€â”€ ClanFence.cs
â”‚       â”œâ”€â”€ Economy/
â”‚       â”‚   â””â”€â”€ ContractManager.cs
â”‚       â”œâ”€â”€ Building/
â”‚       â”‚   â”œâ”€â”€ ChiselTool.cs
â”‚       â”‚   â”œâ”€â”€ ChiselRaycast.cs
â”‚       â”‚   â”œâ”€â”€ BlockSelectionVisualizer.cs
â”‚       â”‚   â”œâ”€â”€ BlockCuttingSystem.cs
â”‚       â”‚   â”œâ”€â”€ ShapeApplicationSystem.cs
â”‚       â”‚   â””â”€â”€ CutMode.cs
â”‚       â”œâ”€â”€ Crafting/
â”‚       â”‚   â”œâ”€â”€ CraftingTable.cs
â”‚       â”‚   â””â”€â”€ CraftingManager.cs
â”‚       â”œâ”€â”€ Inventory/
â”‚       â”‚   â”œâ”€â”€ InventorySlot.cs
â”‚       â”‚   â””â”€â”€ PlayerInventory.cs
â”‚       â”œâ”€â”€ Furniture/
â”‚       â”‚   â”œâ”€â”€ FurniturePlacer.cs
â”‚       â”‚   â””â”€â”€ FurnitureInteraction.cs
â”‚       â”œâ”€â”€ Tools/
â”‚       â”‚   â”œâ”€â”€ ToolDurability.cs
â”‚       â”‚   â”œâ”€â”€ RepairStation.cs
â”‚       â”‚   â”œâ”€â”€ UpgradeStation.cs
â”‚       â”‚   â””â”€â”€ EnchantmentSystem.cs
â”‚       â”œâ”€â”€ Food/
â”‚       â”‚   â”œâ”€â”€ HungerSystem.cs
â”‚       â”‚   â””â”€â”€ CookingStation.cs
â”‚       â”œâ”€â”€ StatusEffects/
â”‚       â”‚   â”œâ”€â”€ StatusEffectManager.cs
â”‚       â”‚   â””â”€â”€ DiseaseSystem.cs
â”‚       â”œâ”€â”€ Weather/
â”‚       â”‚   â”œâ”€â”€ WeatherSystem.cs
â”‚       â”‚   â”œâ”€â”€ SeasonSystem.cs
â”‚       â”‚   â”œâ”€â”€ TemperatureSystem.cs
â”‚       â”‚   â””â”€â”€ WeatherEffects.cs
â”‚       â”œâ”€â”€ Smelting/
â”‚       â”‚   â””â”€â”€ SmeltingSystem.cs
â”‚       â””â”€â”€ Storage/
â”‚           â””â”€â”€ ChestInventory.cs
â””â”€â”€ Data/
    â”œâ”€â”€ Items/
    â”‚   â”œâ”€â”€ Resources/
    â”‚   â”œâ”€â”€ Weapons/
    â”‚   â””â”€â”€ Tools/
    â”œâ”€â”€ Recipes/
    â”‚   â”œâ”€â”€ Rituals/
    â”‚   â”œâ”€â”€ Crafting/
    â”‚   â”œâ”€â”€ Cooking/
    â”‚   â””â”€â”€ Smelting/
    â”œâ”€â”€ Furniture/
    â”‚   â””â”€â”€ FurnitureDefinition.cs
    â”œâ”€â”€ Food/
    â”‚   â”œâ”€â”€ FoodDefinition.cs
    â”‚   â””â”€â”€ CookingRecipe.cs
    â”œâ”€â”€ StatusEffects/
    â”‚   â”œâ”€â”€ StatusEffectDefinition.cs
    â”‚   â”œâ”€â”€ DiseaseDefinition.cs
    â”‚   â””â”€â”€ CureItemDefinition.cs
    â”œâ”€â”€ Enchantments/
    â”‚   â””â”€â”€ EnchantmentDefinition.cs
    â””â”€â”€ Chests/
        â””â”€â”€ ChestDefinition.cs
```

### ğŸ¯ SonuÃ§

- âœ… Item sistemi hazÄ±r (Fiziksel itemlar)
- âœ… Blok ÅŸekillendirme sistemi tamamlandÄ± (ChiselTool, BlockCuttingSystem, ShapeApplicationSystem)
- âœ… Crafting sistemi tamamlandÄ± (ADIM 1.6 - CraftingTable, CraftingManager, Recipe sistemi)
- âœ… KapsamlÄ± envanter sistemi tamamlandÄ± (ADIM 1.7 - PlayerInventory, Hotbar, Weight sistemi)
- âœ… Furniture sistemi tamamlandÄ± (ADIM 1.8 - FurniturePlacer, FurnitureInteraction)
- âœ… Ä°ÅŸlevsel item'ler tamamlandÄ± (ADIM 1.9 - ToolDurability, RepairStation, UpgradeStation, EnchantmentSystem)
- âœ… Yemek ve aÃ§lÄ±k sistemi tamamlandÄ± (ADIM 1.14 - HungerSystem, CookingStation, FoodDefinition)
- âœ… HastalÄ±k ve durum sistemi tamamlandÄ± (ADIM 1.15 - StatusEffectManager, DiseaseSystem)
- âœ… Zaman ve hava sistemi tamamlandÄ± (ADIM 1.16 - WeatherSystem, SeasonSystem, TemperatureSystem)
- âœ… Madencilik ve eritme sistemi tamamlandÄ± (ADIM 1.24 - SmeltingSystem, SmeltingRecipe)
- âœ… Depolama ve sandÄ±k sistemi tamamlandÄ± (ADIM 1.25 - ChestInventory, ChestDefinition)
- âœ… RitÃ¼el sistemi Ã§alÄ±ÅŸÄ±yor (Batarya oluÅŸturma)
- âœ… Klan bÃ¶lge sistemi aktif (Flood-Fill)
- âœ… Kontrat sistemi tamamlandÄ±

---

## ğŸ¤– FAZ 5: YAPAY ZEKA, SAVAÅ VE FELAKETLER

### âœ… Eklenen Ã–zellikler

**1. AI Sistemi:**
- âœ… ChunkNavMeshBaker.cs (Dinamik NavMesh)
- âœ… MobAI.cs (Normal mob AI - State Machine)
- âœ… BossAI.cs (Boss AI - Panda BT)
- âœ… MobSpawner.cs (Mob spawn)

**1.10. NPC Sistemi (ADIM 1.10):**
- âœ… NPCDefinition.cs (ScriptableObject - NPC tanÄ±mlarÄ±)
- âœ… NPCAI.cs (NPC AI - State Machine, NavMesh pathfinding)
- âœ… VillagerTrading.cs (Ticaret sistemi - Trade history cache)
- âœ… DialogueSystem.cs (Diyalog sistemi - Dialogue state cache)
- âœ… VillageGenerator.cs (KÃ¶y oluÅŸturma - Job System + Burst)
- âœ… NPC meslekleri (Blacksmith, Merchant, Farmer, Guard, Priest, Builder, Scholar)
- âœ… ChunkNavMeshBaker entegrasyonu (dinamik NavMesh)
- âœ… ChunkManager entegrasyonu (voxel terrain uyumlu)

**1.12. GeliÅŸmiÅŸ Boss Sistemi (ADIM 1.12):**
- âœ… DragonAI.cs (Ejderha AI - Flight state machine, Unity Physics)
- âœ… BossArena.cs (Boss arenasÄ± - StructurePlacer entegrasyonu)
- âœ… BossLootTable.cs (Loot sistemi - Rarity bazlÄ±)
- âœ… BossPhaseSystem.cs (Multi-phase fight sistemi)
- âœ… BossSummoning.cs (Ã‡aÄŸÄ±rma sistemi - Ritual malzeme kontrolÃ¼)
- âœ… BossArenaDefinition.cs (ScriptableObject - Arena tanÄ±mlarÄ±)
- âœ… Respawn cooldown sistemi

**1.13. Ã–zel CanlÄ± Tipleri (ADIM 1.13):**
- âœ… MobClassDefinition.cs (ScriptableObject - Mob sÄ±nÄ±f tanÄ±mlarÄ±)
- âœ… MobAbilitySystem.cs (Mob yetenek sistemi - Cooldown, Level scaling)
- âœ… MobArmorSystem.cs (Mob zÄ±rh sistemi)
- âœ… MobLeveling.cs (Mob seviye sistemi - Experience sistemi)
- âœ… Mob sÄ±nÄ±flarÄ± (Warrior, Mage, Archer, Tank, Assassin, Support)
- âœ… Mob yetenekleri (Melee, Ranged, Area, Heal, Buff, Debuff)

**2. SavaÅŸ Sistemi:**
- âœ… IDamageable.cs (Hasar arayÃ¼zÃ¼)
- âœ… HealthComponent.cs (Can sistemi)
- âœ… ArmorComponent.cs (ZÄ±rh sistemi)
- âœ… Critical hit system

**3. Boss Sistemi:**
- âœ… BossDefinition.cs (ScriptableObject)
- âœ… BossIdentity.cs (Boss kimliÄŸi)
- âœ… BossSpawner.cs (Boss spawn)
- âœ… Arena transformation (Dinamik arena)

**4. Felaket Sistemi:**
- âœ… DisasterDefinition.cs (ScriptableObject)
- âœ… DisasterManager.cs (Felaket yÃ¶netimi)
- âœ… Disaster types (Solar Flare, Earthquake, vb.)
- âœ… Disaster phases (HaftalÄ±k, 3 gÃ¼nlÃ¼k, gÃ¼nlÃ¼k)

**1.11. GeliÅŸmiÅŸ Binek Sistemi (ADIM 1.11):**
- âœ… SaddleDefinition.cs (ScriptableObject - EÄŸer tanÄ±mlarÄ±)
- âœ… MountInventory.cs (Binek envanteri - SyncList, async database)
- âœ… MountArmor.cs (Binek zÄ±rhÄ± - Hasar azaltma)
- âœ… MountAbilities.cs (Binek yetenekleri - Dash, Jump, Charge, Heal, Shield)
- âœ… MountLeveling.cs (Binek seviye sistemi - Experience sistemi, exponential growth)
- âœ… MountArmorDefinition.cs (ScriptableObject - ZÄ±rh tanÄ±mlarÄ±)

**5. Tuzak Sistemi:**
- âœ… TrapDefinition.cs (ScriptableObject)
- âœ… TrapDatabase.cs (Tuzak lookup - O(1) - FAZ 5)
- âœ… TrapCore.cs (Tuzak Ã§ekirdeÄŸi)
- âœ… TrapManager.cs (Tuzak yÃ¶netimi)
- âœ… Fuel system (YakÄ±t sistemi)

### ğŸ› ï¸ KullanÄ±lan Teknolojiler

| Teknoloji | Kaynak | AÃ§Ä±klama |
|-----------|--------|----------|
| **Panda BT** | GitHub (AÃ§Ä±k Kaynak) | Behavior Tree (Boss AI) |
| **NavMesh Components** | Unity Asset Store | Runtime NavMesh baking |
| **State Machine** | Custom | Normal mob AI |
| **Unity Physics** | Unity YerleÅŸik | Hasar hesaplama |

### ğŸ“‚ Eklenen Dosyalar

```
Assets/_Stratocraft/
â”œâ”€â”€ Scripts/
â”‚   â”œâ”€â”€ AI/
â”‚   â”‚   â”œâ”€â”€ Core/
â”‚   â”‚   â”‚   â””â”€â”€ ChunkNavMeshBaker.cs
â”‚   â”‚   â”œâ”€â”€ Mobs/
â”‚   â”‚   â”‚   â”œâ”€â”€ MobAI.cs
â”‚   â”‚   â”‚   â””â”€â”€ MobSpawner.cs
â”‚   â”‚   â””â”€â”€ Bosses/
â”‚   â”‚       â”œâ”€â”€ BossAI.cs
â”‚   â”‚       â”œâ”€â”€ BossIdentity.cs
â”‚   â”‚       â””â”€â”€ BossSpawner.cs
â”‚   â””â”€â”€ Systems/
â”‚       â”œâ”€â”€ Combat/
â”‚       â”‚   â”œâ”€â”€ IDamageable.cs
â”‚       â”‚   â”œâ”€â”€ HealthComponent.cs
â”‚       â”‚   â””â”€â”€ ArmorComponent.cs
â”‚       â”œâ”€â”€ Disasters/
â”‚       â”‚   â”œâ”€â”€ DisasterManager.cs
â”‚       â”‚   â””â”€â”€ DisasterDefinition.cs
â”‚       â”œâ”€â”€ Traps/
â”‚       â”‚   â”œâ”€â”€ TrapManager.cs
â”‚       â”‚   â”œâ”€â”€ TrapCore.cs
â”‚       â”‚   â””â”€â”€ TrapDefinition.cs
â”‚       â”œâ”€â”€ NPCs/
â”‚       â”‚   â”œâ”€â”€ NPCAI.cs
â”‚       â”‚   â”œâ”€â”€ VillagerTrading.cs
â”‚       â”‚   â”œâ”€â”€ DialogueSystem.cs
â”‚       â”‚   â””â”€â”€ VillageGenerator.cs
â”‚       â”œâ”€â”€ Mounts/
â”‚       â”‚   â”œâ”€â”€ MountInventory.cs
â”‚       â”‚   â”œâ”€â”€ MountArmor.cs
â”‚       â”‚   â”œâ”€â”€ MountAbilities.cs
â”‚       â”‚   â””â”€â”€ MountLeveling.cs
â”‚       â”œâ”€â”€ Bosses/
â”‚       â”‚   â”œâ”€â”€ DragonAI.cs
â”‚       â”‚   â”œâ”€â”€ BossArena.cs
â”‚       â”‚   â”œâ”€â”€ BossLootTable.cs
â”‚       â”‚   â”œâ”€â”€ BossPhaseSystem.cs
â”‚       â”‚   â””â”€â”€ BossSummoning.cs
â”‚       â”œâ”€â”€ Mobs/
â”‚       â”‚   â”œâ”€â”€ MobAbilitySystem.cs
â”‚       â”‚   â”œâ”€â”€ MobArmorSystem.cs
â”‚       â”‚   â””â”€â”€ MobLeveling.cs
â”‚       â”œâ”€â”€ Dungeons/
â”‚       â”‚   â”œâ”€â”€ DungeonGenerator.cs
â”‚       â”‚   â””â”€â”€ DungeonEntrance.cs
â”‚       â”œâ”€â”€ Magic/
â”‚       â”‚   â”œâ”€â”€ ManaSystem.cs
â”‚       â”‚   â””â”€â”€ SpellCasting.cs
â”‚       â”œâ”€â”€ Tech/
â”‚       â”‚   â””â”€â”€ TechTreeManager.cs
â”‚       â”œâ”€â”€ Vehicles/
â”‚       â”‚   â””â”€â”€ VehicleController.cs
â”‚       â”œâ”€â”€ Pets/
â”‚       â”‚   â””â”€â”€ PetSystem.cs
â”‚       â”œâ”€â”€ Farming/
â”‚       â”‚   â””â”€â”€ FarmingSystem.cs
â”‚       â””â”€â”€ Fishing/
â”‚           â””â”€â”€ FishingSystem.cs
â””â”€â”€ Data/
    â”œâ”€â”€ Mobs/
    â”‚   â”œâ”€â”€ Normal/
    â”‚   â””â”€â”€ Bosses/
    â”œâ”€â”€ Disasters/
    â”œâ”€â”€ Traps/
    â”œâ”€â”€ NPCs/
    â”‚   â””â”€â”€ NPCDefinition.cs
    â”œâ”€â”€ Mounts/
    â”‚   â”œâ”€â”€ SaddleDefinition.cs
    â”‚   â””â”€â”€ MountArmorDefinition.cs
    â”œâ”€â”€ Bosses/
    â”‚   â”œâ”€â”€ BossArenaDefinition.cs
    â”‚   â””â”€â”€ BossLootTableDefinition.cs
    â”œâ”€â”€ Mobs/
    â”‚   â”œâ”€â”€ MobClassDefinition.cs
    â”‚   â””â”€â”€ MobArmorDefinition.cs
    â”œâ”€â”€ Dungeons/
    â”‚   â””â”€â”€ DungeonDefinition.cs
    â”œâ”€â”€ Spells/
    â”‚   â””â”€â”€ SpellDefinition.cs
    â”œâ”€â”€ Tech/
    â”‚   â””â”€â”€ TechNodeDefinition.cs
    â”œâ”€â”€ Vehicles/
    â”‚   â””â”€â”€ VehicleDefinition.cs
    â”œâ”€â”€ Pets/
    â”‚   â””â”€â”€ PetDefinition.cs
    â”œâ”€â”€ Crops/
    â”‚   â””â”€â”€ CropDefinition.cs
    â””â”€â”€ Fish/
        â””â”€â”€ FishDefinition.cs
```

### ğŸ¯ SonuÃ§

- âœ… Normal mob AI Ã§alÄ±ÅŸÄ±yor (State Machine)
- âœ… Boss AI hazÄ±r (Panda BT)
- âœ… NPC sistemi tamamlandÄ± (ADIM 1.10 - NPCAI, VillagerTrading, DialogueSystem, VillageGenerator)
- âœ… GeliÅŸmiÅŸ binek sistemi tamamlandÄ± (ADIM 1.11 - MountInventory, MountArmor, MountAbilities, MountLeveling)
- âœ… GeliÅŸmiÅŸ boss sistemi tamamlandÄ± (ADIM 1.12 - DragonAI, BossArena, BossLootTable, BossPhaseSystem)
- âœ… Ã–zel canlÄ± tipleri tamamlandÄ± (ADIM 1.13 - MobClassDefinition, MobAbilitySystem, MobArmorSystem, MobLeveling)
- âœ… Zindan ve maÄŸara sistemi tamamlandÄ± (ADIM 1.17 - DungeonGenerator, DungeonEntrance)
- âœ… Magic ve bÃ¼yÃ¼ sistemi tamamlandÄ± (ADIM 1.18 - ManaSystem, SpellCasting)
- âœ… Teknoloji aÄŸacÄ± tamamlandÄ± (ADIM 1.19 - TechTreeManager)
- âœ… AraÃ§ ve ulaÅŸÄ±m sistemi tamamlandÄ± (ADIM 1.20 - VehicleController)
- âœ… Pet ve ev hayvanÄ± sistemi tamamlandÄ± (ADIM 1.21 - PetSystem)
- âœ… TarÄ±m ve Ã§iftÃ§ilik sistemi tamamlandÄ± (ADIM 1.22 - FarmingSystem)
- âœ… BalÄ±kÃ§Ä±lÄ±k sistemi tamamlandÄ± (ADIM 1.23 - FishingSystem)
- âœ… SavaÅŸ sistemi aktif (Hasar, zÄ±rh, kritik)
- âœ… Felaket sistemi tamamlandÄ±
- âœ… Tuzak sistemi Ã§alÄ±ÅŸÄ±yor

---

## ğŸ¨ FAZ 6: ARAYÃœZ (UI), ETKÄ°LEÅÄ°M VE CÄ°LA

### âœ… Eklenen Ã–zellikler

**1. EtkileÅŸim Sistemi:**
- âœ… IInteractable.cs (EtkileÅŸim arayÃ¼zÃ¼)
- âœ… InteractionController.cs (Raycast kontrolÃ¼)
- âœ… Raycast caching (Performans optimizasyonu)
- âœ… Interaction prompts (UI gÃ¶sterimi)

**2. HUD (Heads-Up Display):**
- âœ… HUDManager.cs (Can barÄ±, bÃ¶lge ismi)
- âœ… TextMeshPro entegrasyonu
- âœ… DoTween animasyonlarÄ±
- âœ… Value caching (Gereksiz gÃ¼ncelleme Ã¶nleme)

**3. KarmaÅŸÄ±k MenÃ¼ler:**
- âœ… ContractUI.cs (Kontrat menÃ¼sÃ¼)
- âœ… ClanManagementUI.cs (Klan yÃ¶netim menÃ¼sÃ¼)
- âœ… Async DB loading (Performans)
- âœ… UI element pooling

**4. GÃ¶rsel/Ä°ÅŸitsel Geri Bildirim:**
- âœ… AudioManager.cs (Ses yÃ¶netimi)
- âœ… CameraShake.cs (Kamera sarsÄ±ntÄ±sÄ±)
- âœ… AudioSource pooling
- âœ… Network senkronizasyonu (ObserversRpc)

### ğŸ› ï¸ KullanÄ±lan Teknolojiler

| Teknoloji | Kaynak | AÃ§Ä±klama |
|-----------|--------|----------|
| **TextMeshPro** | Unity YerleÅŸik | UI metinleri |
| **DoTween** | Asset Store (Free) | UI animasyonlarÄ± |
| **Unity Canvas** | Unity YerleÅŸik | UI sistemi |
| **Unity Audio** | Unity YerleÅŸik | Ses sistemi |

### ğŸ“‚ Eklenen Dosyalar

```
Assets/_Stratocraft/
â”œâ”€â”€ Scripts/
â”‚   â”œâ”€â”€ Player/
â”‚   â”‚   â””â”€â”€ InteractionController.cs
â”‚   â”œâ”€â”€ UI/
â”‚   â”‚   â”œâ”€â”€ HUDManager.cs
â”‚   â”‚   â””â”€â”€ Menus/
â”‚   â”‚       â”œâ”€â”€ ContractUI.cs
â”‚   â”‚       â””â”€â”€ ClanManagementUI.cs
â”‚   â””â”€â”€ Systems/
â”‚       â”œâ”€â”€ Interaction/
â”‚       â”‚   â””â”€â”€ IInteractable.cs
â”‚       â””â”€â”€ Effects/
â”‚           â”œâ”€â”€ AudioManager.cs
â”‚           â””â”€â”€ CameraShake.cs
```

### ğŸ¯ SonuÃ§

- âœ… EtkileÅŸim sistemi hazÄ±r (Raycast + UI)
- âœ… HUD Ã§alÄ±ÅŸÄ±yor (Can barÄ±, bÃ¶lge ismi)
- âœ… MenÃ¼ sistemi tamamlandÄ± (Kontrat, Klan)
- âœ… Ses ve efektler eklendi

---

## âš”ï¸ FAZ 7: GÃœÃ‡ SÄ°STEMÄ°, BÄ°NEKLER VE SAVAÅ MAKÄ°NELERÄ°

### âœ… Eklenen Ã–zellikler

**1.11. GeliÅŸmiÅŸ Binek Sistemi (ADIM 1.11) - FAZ 7'ye taÅŸÄ±ndÄ±:**
- âœ… SaddleDefinition.cs (ScriptableObject - EÄŸer tanÄ±mlarÄ±)
- âœ… MountInventory.cs (Binek envanteri - SyncList, async database)
- âœ… MountArmor.cs (Binek zÄ±rhÄ± - Hasar azaltma)
- âœ… MountAbilities.cs (Binek yetenekleri - Dash, Jump, Charge, Heal, Shield)
- âœ… MountLeveling.cs (Binek seviye sistemi - Experience sistemi, exponential growth)
- âœ… MountArmorDefinition.cs (ScriptableObject - ZÄ±rh tanÄ±mlarÄ±)

**1.20. AraÃ§ ve UlaÅŸÄ±m Sistemi (ADIM 1.20) - FAZ 7'ye taÅŸÄ±ndÄ±:**
- âœ… VehicleDefinition.cs (ScriptableObject - AraÃ§ tanÄ±mlarÄ±)
- âœ… VehicleController.cs (AraÃ§ kontrolÃ¼ - Unity Physics)
- âœ… AraÃ§ tipleri (Cart, Boat, Airship)
- âœ… YakÄ±t ve tamir sistemi

**1. GÃ¼Ã§ Sistemi (SGP):**
- âœ… PlayerPowerProfile.cs (Oyuncu gÃ¼Ã§ profili)
- âœ… ClanPowerProfile.cs (Klan gÃ¼Ã§ profili)
- âœ… StratocraftPowerSystem.cs (GÃ¼Ã§ hesaplama)
- âœ… PowerSystemConfig.cs (Config)
- âœ… Hysteresis system (Exploit Ã¶nleme)
- âœ… Cache system (Performans)

**2. Binek Sistemi (Temel):**
- âœ… RideableMobDefinition.cs (ScriptableObject)
- âœ… RideableMobDatabase.cs (Binilebilir mob lookup - O(1) - FAZ 7)
- âœ… RideableMob.cs (Binek mob)
- âœ… MobInputController.cs (WASD kontrolÃ¼)
- âœ… Taming system (EÄŸitme)
- âœ… Gender system (Cinsiyet)
- âœ… Following behavior (Takip)

**GeliÅŸmiÅŸ Binek Sistemi (ADIM 1.11) - YukarÄ±da listelendi**

**3. KuÅŸatma Sistemi:**
- âœ… SiegeBeacon.cs (KuÅŸatma beacon'Ä±)
- âœ… SiegeManager.cs (SavaÅŸ yÃ¶netimi)
- âœ… Warmup countdown (5 dakika)
- âœ… Two-sided war (Ä°ki taraflÄ± savaÅŸ)
- âœ… Protection removal (Koruma kaldÄ±rma)
- âœ… Offline protection (Offline koruma)

**4. YapÄ± BufflarÄ±:**
- âœ… StructureEffectDefinition.cs (ScriptableObject)
- âœ… StructureEffectDatabase.cs (YapÄ± efekt lookup - O(1) - FAZ 7)
- âœ… StructureEffectManager.cs (Efekt yÃ¶netimi)
- âœ… Area of effect (Etki alanÄ±)
- âœ… Periodic effects (Periyodik efektler)
- âœ… Buff/Debuff/Utility/Passive efektler

**5. Offline Koruma:**
- âœ… OfflineProtectionSystem.cs (Offline koruma)
- âœ… Shield fuel system (Kalkan yakÄ±tÄ±)
- âœ… Damage reduction (%95)
- âœ… Fuel consumption (YakÄ±t tÃ¼ketimi)

### ğŸ› ï¸ KullanÄ±lan Teknolojiler

| Teknoloji | Kaynak | AÃ§Ä±klama |
|-----------|--------|----------|
| **FishNet Ownership** | FishNet | Binek kontrolÃ¼ |
| **SQLite** | NuGet | GÃ¼Ã§ profili kayÄ±tlarÄ± |
| **Unity Coroutines** | Unity YerleÅŸik | Async iÅŸlemler |
| **Cache System** | Custom | Performans optimizasyonu |

### ğŸ“‚ Eklenen Dosyalar

```
Assets/_Stratocraft/
â”œâ”€â”€ Scripts/
â”‚   â”œâ”€â”€ Core/
â”‚   â”‚   â”œâ”€â”€ Models/
â”‚   â”‚   â”‚   â”œâ”€â”€ PlayerPowerProfile.cs
â”‚   â”‚   â”‚   â””â”€â”€ ClanPowerProfile.cs
â”‚   â”‚   â””â”€â”€ Definitions/
â”‚   â”‚       â”œâ”€â”€ RideableMobDefinition.cs
â”‚   â”‚       â””â”€â”€ StructureEffectDefinition.cs
â”‚   â””â”€â”€ Systems/
â”‚       â”œâ”€â”€ Power/
â”‚       â”‚   â”œâ”€â”€ StratocraftPowerSystem.cs
â”‚       â”‚   â””â”€â”€ PowerSystemConfig.cs
â”‚       â”œâ”€â”€ Taming/
â”‚       â”‚   â”œâ”€â”€ RideableMob.cs
â”‚       â”‚   â””â”€â”€ MobInputController.cs
â”‚       â”œâ”€â”€ Combat/
â”‚       â”‚   â”œâ”€â”€ SiegeBeacon.cs
â”‚       â”‚   â””â”€â”€ SiegeManager.cs
â”‚       â”œâ”€â”€ Buildings/
â”‚       â”‚   â””â”€â”€ StructureEffectManager.cs
â”‚       â””â”€â”€ Clans/
â”‚           â””â”€â”€ OfflineProtectionSystem.cs
â””â”€â”€ Data/
    â”œâ”€â”€ Config/
    â”‚   â””â”€â”€ PowerSystemConfig.asset
    â””â”€â”€ Mobs/
        â””â”€â”€ Rideable/
```

### ğŸ¯ SonuÃ§

- âœ… GÃ¼Ã§ sistemi hazÄ±r (SGP hesaplama)
- âœ… Binek sistemi Ã§alÄ±ÅŸÄ±yor (EÄŸitme + binme)
- âœ… KuÅŸatma sistemi tamamlandÄ± (Beacon + savaÅŸ)
- âœ… YapÄ± bufflarÄ± aktif
- âœ… Offline koruma Ã§alÄ±ÅŸÄ±yor

---

## ğŸ› ï¸ FAZ 8: EKSÄ°K SÄ°STEMLER, ADMIN KOMUTLARI VE CONFIG YÃ–NETÄ°MÄ°

### âœ… Eklenen Ã–zellikler

**1.19. Teknoloji AÄŸacÄ± (ADIM 1.19) - FAZ 8'e taÅŸÄ±ndÄ±:**
- âœ… TechNodeDefinition.cs (ScriptableObject - Teknoloji dÃ¼ÄŸÃ¼m tanÄ±mlarÄ±)
- âœ… TechTreeManager.cs (Teknoloji aÄŸacÄ± yÃ¶neticisi - Prerequisite kontrolÃ¼)
- âœ… Research point sistemi
- âœ… Tech kategorileri

**1. Eksik Oyun Sistemleri (9 Sistem):**
- âœ… **Kervan Sistemi:** Uzak mesafe ticaret, NavMesh pathfinding
- âœ… **AraÅŸtÄ±rma Sistemi:** Tarif KitabÄ± paylaÅŸÄ±mÄ±, 10 blok yarÄ±Ã§ap
- âœ… **Ãœreme Sistemi:** Breeding Core, Memeli vs Yumurtlayan
- âœ… **Market Sistemi:** SandÄ±k + Tabela, Teklif sistemi, %5 vergi
- âœ… **GÃ¶rev Sistemi:** 8 gÃ¶rev tipi, 4 zorluk seviyesi, Otomatik ilerleme
- âœ… **Supply Drop Sistemi:** GÃ¶kyÃ¼zÃ¼nden dÃ¼ÅŸen hazine, Ä°lk bulan alÄ±r
- âœ… **KuÅŸatma SilahlarÄ±:** Balista (30 mermi), MancÄ±nÄ±k (alan hasarÄ±)
- âœ… **Hayalet Tarif Sistemi:** GÃ¶rsel rehber, Blok yerleÅŸtirme Ã§izgileri
- âœ… **Ä°ttifak Sistemi:** Klanlar arasÄ± anlaÅŸmalar, Ä°hlal cezasÄ±

**2. Admin Komut Sistemi:**
- âœ… AdminCommandHandler.cs (20+ komut)
- âœ… AdminTabCompleter.cs (Tab completion)
- âœ… Permission system (Yetki kontrolÃ¼)
- âœ… Command categories (give, spawn, disaster, vb.)

**3. Config YÃ¶netim Sistemi:**
- âœ… ConfigManager.cs (Merkezi config yÃ¶netimi)
- âœ… ScriptableObject config'ler (8 config dosyasÄ±)
- âœ… Runtime config editor (Editor Window)
- âœ… Hot reload desteÄŸi

### ğŸ› ï¸ KullanÄ±lan Teknolojiler

| Teknoloji | Kaynak | AÃ§Ä±klama |
|-----------|--------|----------|
| **Unity NavMesh** | Unity YerleÅŸik | Kervan pathfinding |
| **Unity Physics** | Unity YerleÅŸik | OverlapSphere, Projectile physics |
| **DoTween** | Asset Store (Free) | Supply Drop animasyonu |
| **Unity Editor API** | Unity YerleÅŸik | Config editor |
| **Unity Input System** | Unity YerleÅŸik | Tab completion |

### ğŸ“‚ Eklenen Dosyalar

```
Assets/_Stratocraft/
â”œâ”€â”€ Scripts/
â”‚   â”œâ”€â”€ Systems/
â”‚   â”‚   â”œâ”€â”€ Economy/
â”‚   â”‚   â”‚   â”œâ”€â”€ CaravanManager.cs
â”‚   â”‚   â”‚   â””â”€â”€ ShopManager.cs
â”‚   â”‚   â”œâ”€â”€ Research/
â”‚   â”‚   â”‚   â””â”€â”€ ResearchManager.cs
â”‚   â”‚   â”œâ”€â”€ Taming/
â”‚   â”‚   â”‚   â””â”€â”€ BreedingManager.cs
â”‚   â”‚   â”œâ”€â”€ Missions/
â”‚   â”‚   â”‚   â””â”€â”€ MissionManager.cs
â”‚   â”‚   â”œâ”€â”€ Events/
â”‚   â”‚   â”‚   â””â”€â”€ SupplyDropManager.cs
â”‚   â”‚   â”œâ”€â”€ Combat/
â”‚   â”‚   â”‚   â””â”€â”€ SiegeWeaponManager.cs
â”‚   â”‚   â”œâ”€â”€ Rituals/
â”‚   â”‚   â”‚   â””â”€â”€ GhostRecipeManager.cs
â”‚   â”‚   â”œâ”€â”€ Clans/
â”‚   â”‚   â”‚   â””â”€â”€ AllianceManager.cs
â”‚   â”‚   â””â”€â”€ Admin/
â”‚   â”‚       â”œâ”€â”€ AdminCommandHandler.cs
â”‚   â”‚       â””â”€â”€ AdminTabCompleter.cs
â”‚   â””â”€â”€ Core/
â”‚       â””â”€â”€ Config/
â”‚           â”œâ”€â”€ ConfigManager.cs
â”‚           â””â”€â”€ Configs/
â”‚               â”œâ”€â”€ GameBalanceConfig.cs
â”‚               â””â”€â”€ ... (diÄŸer config'ler)
â””â”€â”€ Editor/
    â””â”€â”€ ConfigEditor.cs
```

### ğŸ¯ SonuÃ§

- âœ… 9 eksik oyun sistemi tamamlandÄ±
- âœ… Admin komut sistemi hazÄ±r (20+ komut)
- âœ… Config yÃ¶netim sistemi aktif
- âœ… TÃ¼m sistemler test edilebilir durumda

---

## ğŸ“Š GENEL Ä°STATÄ°STÄ°KLER

### Toplam Sistem SayÄ±sÄ±
- **50+ sistem** (Mining, Ritual, Clan, Combat, AI, vb.)

### Toplam Dosya SayÄ±sÄ±
- **200+ dosya** (Scripts, Data, Prefabs, vb.)

### KullanÄ±lan Teknoloji SayÄ±sÄ±
- **15+ teknoloji/kÃ¼tÃ¼phane** (FishNet, Scrawk, SQLite, vb.)

### Fazlar
- âœ… **Faz 1 & 2:** AltyapÄ± ve DÃ¼nya OluÅŸumu
- âœ… **Faz 3:** DoÄŸa, Su ve Biyomlar + Voxel AÄŸaÃ§/Maden/Ä°nÅŸa Sistemleri
  - VoxelTreeGenerator + TreeGrowthSystem (ProsedÃ¼rel aÄŸaÃ§, aÅŸamalÄ± bÃ¼yÃ¼me)
  - OreSpawner (Voxel maden spawn)
  - GridPlacementSystem + BlueprintSystem + SculptingSystem (Ä°nÅŸa sistemi)
  - VariantMeshGenerator (740 blok variant)
  - ChunkManager gÃ¼ncellemeleri (AddDensityAtPoint, SetBlockType, OnChunkGenerated)
- âœ… **Faz 4:** Oyun Mekanikleri
  - NetworkMining (Minecraft benzeri kÄ±rma/yerleÅŸtirme)
  - Blok Åekillendirme Sistemi (ChiselTool, BlockCuttingSystem, ShapeApplicationSystem)
  - IEquippable interface (Alet kuÅŸanma/Ã§Ä±karma)
  - ItemDefinition gÃ¼ncellemeleri (isChisel, chiselDefinition, chiselLevel)
- âœ… **Faz 5:** Yapay Zeka, SavaÅŸ ve Felaketler
- âœ… **Faz 6:** ArayÃ¼z (UI), EtkileÅŸim ve Cila
- âœ… **Faz 7:** GÃ¼Ã§ Sistemi, Binekler ve SavaÅŸ Makineleri
- âœ… **Faz 8:** Eksik Sistemler, Admin KomutlarÄ± ve Config YÃ¶netimi

---

## ğŸ¯ SONUÃ‡

Stratocraft Unity dÃ¶nÃ¼ÅŸÃ¼mÃ¼ **tamamlandÄ±**. TÃ¼m fazlar baÅŸarÄ±yla tamamlandÄ± ve proje **1000 kiÅŸilik MMO sunucu** iÃ§in hazÄ±r durumda.

**SÄ±radaki AdÄ±mlar:**
1. Kod implementasyonu (Faz 1'den baÅŸlayarak)
2. Test ve debug
3. Balance ayarlarÄ±
4. Performans optimizasyonlarÄ±
5. Beta test
6. Release

---


# ğŸ“‚ NÄ°HAÄ° STRATOCRAFT DOSYA YAPISI (FAZ 8 SONRASI - TAM LÄ°STE)

TÃ¼m fazlar tamamlandÄ±ktan sonra projenin final dosya yapÄ±sÄ±:

```text
Assets/_Stratocraft/
â”œâ”€â”€ _Bootstrap/
â”‚   â”œâ”€â”€ GameEntry.cs                    (Oyun baÅŸlatÄ±cÄ± - FAZ 1)
â”‚   â”œâ”€â”€ NetworkBootstrap.cs             (FishNet ayarlarÄ± - FAZ 1)
â”‚   â””â”€â”€ ServerConfig.json               (Port, Seed, MaxPlayers - FAZ 1)
â”‚
â”œâ”€â”€ Data/                               (ScriptableObjects - Data-Driven Design)
â”‚   â”œâ”€â”€ Biomes/                         (FAZ 3)
â”‚   â”‚   â”œâ”€â”€ DesertDef.asset             (Ã‡Ã¶l biyomu - FAZ 3)
â”‚   â”‚   â”œâ”€â”€ ForestDef.asset             (Orman biyomu - FAZ 3)
â”‚   â”‚   â””â”€â”€ MountainDef.asset            (DaÄŸ biyomu - FAZ 3)
â”‚   â”‚
â”‚   â”œâ”€â”€ Items/                          (FAZ 4)
â”‚   â”‚   â”œâ”€â”€ Resources/                  (FAZ 4 - Titanium.asset, RedDiamond.asset)
â”‚   â”‚   â”œâ”€â”€ Weapons/                    (FAZ 4 - Sword_L1.asset, Sword_L5.asset)
â”‚   â”‚   â”œâ”€â”€ Armors/                     (FAZ 4 - ArmorSet_L1.asset)
â”‚   â”‚   â”œâ”€â”€ Tools/                      (FAZ 4 - TrapCore.asset, TamingCore.asset)
â”‚   â”‚   â””â”€â”€ Structures/                 (FAZ 4 - ClanCrystal.asset, StructureCore.asset)
â”‚   â”‚
â”‚   â”œâ”€â”€ Recipes/                        (FAZ 4)
â”‚   â”‚   â”œâ”€â”€ Rituals/                    (FAZ 4 - FireballBattery.asset, LightningBattery.asset)
â”‚   â”‚   â”œâ”€â”€ Crafting/                   (FAZ 4 - ADIM 1.6 - CraftingRecipe.cs ScriptableObject)
â”‚   â”‚   â”‚   â””â”€â”€ WeaponRecipes.asset      (FAZ 4 - Ã–rnek recipe asset'leri)
â”‚   â”‚   â”œâ”€â”€ Cooking/                    (FAZ 4 - ADIM 1.14 - CookingRecipe.cs ScriptableObject)
â”‚   â”‚   â””â”€â”€ Smelting/                   (FAZ 4 - ADIM 1.24 - SmeltingRecipe.cs ScriptableObject)
â”‚   â”‚
â”‚   â”œâ”€â”€ Mobs/                           (FAZ 5)
â”‚   â”‚   â”œâ”€â”€ Normal/                     (FAZ 5 - GoblinDef.asset, OrcDef.asset)
â”‚   â”‚   â”œâ”€â”€ Bosses/                     (FAZ 5 - TitanGolemDef.asset, DragonDef.asset)
â”‚   â”‚   â””â”€â”€ Rideable/                   (FAZ 7 - DragonRideable.asset, TRexRideable.asset)
â”‚   â”‚
â”‚   â”œâ”€â”€ Missions/                       (FAZ 8)
â”‚   â”‚   â”œâ”€â”€ KillMob_Easy.asset          (FAZ 8)
â”‚   â”‚   â”œâ”€â”€ CollectItem_Medium.asset    (FAZ 8)
â”‚   â”‚   â””â”€â”€ VisitLocation_Hard.asset    (FAZ 8)
â”‚   â”‚
â”‚   â”œâ”€â”€ Disasters/                      (FAZ 5)
â”‚   â”‚   â”œâ”€â”€ CatastrophicTitan.asset     (FAZ 5)
â”‚   â”‚   â”œâ”€â”€ SolarFlare.asset            (FAZ 5)
â”‚   â”‚   â””â”€â”€ Earthquake.asset             (FAZ 5)
â”‚   â”‚
â”‚   â”œâ”€â”€ Traps/                          (FAZ 5)
â”‚   â”‚   â”œâ”€â”€ FireTrap.asset              (FAZ 5)
â”‚   â”‚   â”œâ”€â”€ LightningTrap.asset         (FAZ 5)
â”‚   â”‚   â””â”€â”€ PoisonTrap.asset            (FAZ 5)
â”‚   â”‚
â”‚   â”œâ”€â”€ Furniture/                      (FAZ 4 - ADIM 1.8 - Furniture TanÄ±mlarÄ±)
â”‚   â”‚   â””â”€â”€ FurnitureDefinition.cs       (ScriptableObject - Bed, Chair, Table, Chest, vb.)
â”‚   â”‚
â”‚   â”œâ”€â”€ Enchantments/                   (FAZ 4 - ADIM 1.9 - Enchantment TanÄ±mlarÄ±)
â”‚   â”‚   â””â”€â”€ EnchantmentDefinition.cs     (ScriptableObject - Unbreaking, Fortune, DamageBoost, vb.)
â”‚   â”‚
â”‚   â”œâ”€â”€ NPCs/                           (FAZ 5 - ADIM 1.10 - NPC TanÄ±mlarÄ±)
â”‚   â”‚   â””â”€â”€ NPCDefinition.cs            (ScriptableObject - Blacksmith, Merchant, Farmer, vb.)
â”‚   â”‚
â”‚   â”œâ”€â”€ Mounts/                         (FAZ 7 - ADIM 1.11 - Binek TanÄ±mlarÄ±)
â”‚   â”‚   â”œâ”€â”€ SaddleDefinition.cs         (ScriptableObject - EÄŸer tanÄ±mlarÄ±)
â”‚   â”‚   â””â”€â”€ MountArmorDefinition.cs     (ScriptableObject - Binek zÄ±rh tanÄ±mlarÄ±)
â”‚   â”‚
â”‚   â”œâ”€â”€ Bosses/                         (FAZ 5 - ADIM 1.12 - Boss TanÄ±mlarÄ±)
â”‚   â”‚   â”œâ”€â”€ BossArenaDefinition.cs      (ScriptableObject - Arena tanÄ±mlarÄ±)
â”‚   â”‚   â””â”€â”€ BossLootTableDefinition.cs  (ScriptableObject - Loot table tanÄ±mlarÄ±)
â”‚   â”‚
â”‚   â”œâ”€â”€ Mobs/                           (FAZ 5 - ADIM 1.13 - Mob TanÄ±mlarÄ±)
â”‚   â”‚   â”œâ”€â”€ MobClassDefinition.cs       (ScriptableObject - Warrior, Mage, Archer, vb.)
â”‚   â”‚   â””â”€â”€ MobArmorDefinition.cs      (ScriptableObject - Mob zÄ±rh tanÄ±mlarÄ±)
â”‚   â”‚
â”‚   â”œâ”€â”€ Food/                           (FAZ 4 - ADIM 1.14 - Yemek TanÄ±mlarÄ±)
â”‚   â”‚   â”œâ”€â”€ FoodDefinition.cs            (ScriptableObject - Yemek tanÄ±mlarÄ±)
â”‚   â”‚   â””â”€â”€ CookingRecipe.cs            (ScriptableObject - PiÅŸirme tarifleri)
â”‚   â”‚
â”‚   â”œâ”€â”€ StatusEffects/                  (FAZ 4 - ADIM 1.15 - Durum Efekt TanÄ±mlarÄ±)
â”‚   â”‚   â”œâ”€â”€ StatusEffectDefinition.cs    (ScriptableObject - Poison, Burn, Freeze, vb.)
â”‚   â”‚   â”œâ”€â”€ DiseaseDefinition.cs       (ScriptableObject - HastalÄ±k tanÄ±mlarÄ±)
â”‚   â”‚   â””â”€â”€ CureItemDefinition.cs       (ScriptableObject - Ä°yileÅŸtirme item tanÄ±mlarÄ±)
â”‚   â”‚
â”‚   â”œâ”€â”€ Dungeons/                       (FAZ 5 - ADIM 1.17 - Zindan TanÄ±mlarÄ±)
â”‚   â”‚   â””â”€â”€ DungeonDefinition.cs        (ScriptableObject - Zindan tanÄ±mlarÄ±)
â”‚   â”‚
â”‚   â”œâ”€â”€ Spells/                         (FAZ 4 - ADIM 1.18 - BÃ¼yÃ¼ TanÄ±mlarÄ±)
â”‚   â”‚   â””â”€â”€ SpellDefinition.cs          (ScriptableObject - Fire, Ice, Lightning, vb.)
â”‚   â”‚
â”‚   â”œâ”€â”€ Tech/                           (FAZ 8 - ADIM 1.19 - Teknoloji TanÄ±mlarÄ±)
â”‚   â”‚   â””â”€â”€ TechNodeDefinition.cs       (ScriptableObject - Teknoloji dÃ¼ÄŸÃ¼m tanÄ±mlarÄ±)
â”‚   â”‚
â”‚   â”œâ”€â”€ Vehicles/                       (FAZ 7 - ADIM 1.20 - AraÃ§ TanÄ±mlarÄ±)
â”‚   â”‚   â””â”€â”€ VehicleDefinition.cs        (ScriptableObject - Cart, Boat, Airship)
â”‚   â”‚
â”‚   â”œâ”€â”€ Pets/                           (FAZ 5 - ADIM 1.21 - Pet TanÄ±mlarÄ±)
â”‚   â”‚   â””â”€â”€ PetDefinition.cs            (ScriptableObject - Pet tanÄ±mlarÄ±)
â”‚   â”‚
â”‚   â”œâ”€â”€ Crops/                          (FAZ 4 - ADIM 1.22 - Bitki TanÄ±mlarÄ±)
â”‚   â”‚   â””â”€â”€ CropDefinition.cs           (ScriptableObject - Bitki tanÄ±mlarÄ±)
â”‚   â”‚
â”‚   â”œâ”€â”€ Fish/                           (FAZ 4 - ADIM 1.23 - BalÄ±k TanÄ±mlarÄ±)
â”‚   â”‚   â””â”€â”€ FishDefinition.cs           (ScriptableObject - BalÄ±k tanÄ±mlarÄ±)
â”‚   â”‚
â”‚   â””â”€â”€ Chests/                         (FAZ 4 - ADIM 1.25 - SandÄ±k TanÄ±mlarÄ±)
â”‚       â””â”€â”€ ChestDefinition.cs           (ScriptableObject - SandÄ±k tanÄ±mlarÄ±)
â”‚   â”‚
â”‚   â””â”€â”€ Config/                         (FAZ 8)
â”‚       â”œâ”€â”€ GameBalanceConfig.asset     (FAZ 8)
â”‚       â”œâ”€â”€ DisasterConfig.asset        (FAZ 8)
â”‚       â”œâ”€â”€ TerritoryConfig.asset       (FAZ 8)
â”‚       â”œâ”€â”€ ClanProtectionConfig.asset  (FAZ 8)
â”‚       â”œâ”€â”€ SiegeConfig.asset           (FAZ 8)
â”‚       â”œâ”€â”€ BossConfig.asset            (FAZ 8)
â”‚       â”œâ”€â”€ MobConfig.asset              (FAZ 8)
â”‚       â””â”€â”€ EconomyConfig.asset         (FAZ 8)
â”‚
â”œâ”€â”€ Engine/                             (GPU Voxel Motoru - Scrawk)
â”‚   â”œâ”€â”€ ComputeShaders/
â”‚   â”‚   â”œâ”€â”€ TerrainDensity.compute      (Zemin & Biyomlar & MaÄŸaralar - FAZ 1)
â”‚   â”‚   â”œâ”€â”€ WaterSim.compute            (Su akÄ±ÅŸÄ± - opsiyonel - FAZ 3)
â”‚   â”‚   â”œâ”€â”€ NoiseLib.compute            (FastNoiseLite - FAZ 1)
â”‚   â”‚   â”œâ”€â”€ DualContouring.compute      (Dual Contouring - opsiyonel - FAZ 1)
â”‚   â”‚   â””â”€â”€ TriplanarTexture.compute    (Triplanar texturing - FAZ 1)
â”‚   â”‚
â”‚   â”œâ”€â”€ Shaders/
â”‚   â”‚   â””â”€â”€ TerrainShader.shader        (Triplanar + material blending - FAZ 1)
â”‚   â”‚
â”‚   â”œâ”€â”€ Core/
â”‚   â”‚   â”œâ”€â”€ ChunkManager.cs             (Sonsuz dÃ¼nya yÃ¶netimi - FAZ 1 - GPU fallback sistemi ile)
â”‚   â”‚   â”‚   â”œâ”€â”€ CalculateDensityJob     (CPU fallback density hesaplama - Job System + Burst - FAZ 1)
â”‚   â”‚   â”‚   â”œâ”€â”€ BuildMeshJob            (CPU fallback mesh building - Job System + Burst - FAZ 1)
â”‚   â”‚   â”‚   â”œâ”€â”€ AddDensityAtPoint()     (Blok yerleÅŸtirme - FAZ 3)
â”‚   â”‚   â”‚   â”œâ”€â”€ RemoveDensityAtPoint()  (Blok kÄ±rma - FAZ 3)
â”‚   â”‚   â”‚   â”œâ”€â”€ SetBlockType() / GetBlockType() (Blok tipi yÃ¶netimi - FAZ 3)
â”‚   â”‚   â”‚   â”œâ”€â”€ OnChunkGenerated event  (OreSpawner, VoxelTreeGenerator iÃ§in - FAZ 3)
â”‚   â”‚   â”‚   â””â”€â”€ GetWorldSeed()          (Deterministik rastgelelik - FAZ 3)
â”‚   â”‚   â”œâ”€â”€ MarchingCubesGPU.cs         (Scrawk - modifiye: LOD, caching, modify - FAZ 1)
â”‚   â”‚   â”œâ”€â”€ MeshBuilder.cs              (Mesh oluÅŸturma - FAZ 1)
â”‚   â”‚   â”œâ”€â”€ VegetationSpawner.cs        (AÄŸaÃ§/taÅŸ spawn - GPU Instancing - FAZ 3)
â”‚   â”‚   â”œâ”€â”€ OceanPlane.cs               (Sonsuz okyanus - FAZ 3)
â”‚   â”‚   â”œâ”€â”€ VoxelGrid.cs                (Veri yapÄ±sÄ± - opsiyonel - FAZ 1)
â”‚   â”‚   â”œâ”€â”€ TerrainMaterialManager.cs   (Materyal seÃ§imi: yÃ¼kseklik/eÄŸim - FAZ 1)
â”‚   â”‚   â”œâ”€â”€ TerrainPoint.cs             (Materyal aÄŸÄ±rlÄ±klarÄ± + nokta verisi - FAZ 1)
â”‚   â”‚   â”œâ”€â”€ TerrainEditor.cs            (Voxel terrain dÃ¼zenleme - GPU - FAZ 1)
â”‚   â”‚   â””â”€â”€ GameTimeManager.cs          (GÃ¼n/gece dÃ¶ngÃ¼sÃ¼ - FAZ 1)
â”‚
â”œâ”€â”€ Scripts/
â”‚   â”œâ”€â”€ Core/
â”‚   â”‚   â”œâ”€â”€ ServiceLocator.cs           (Sistem yÃ¶neticisi - FAZ 1)
â”‚   â”‚   â”œâ”€â”€ DatabaseManager.cs          (SQLite - FAZ 1)
â”‚   â”‚   â”œâ”€â”€ ConfigManager.cs            (Config yÃ¶netimi - FAZ 8)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Models/
â”‚   â”‚   â”‚   â”œâ”€â”€ PlayerPowerProfile.cs   (Oyuncu gÃ¼Ã§ profili - FAZ 7)
â”‚   â”‚   â”‚   â”œâ”€â”€ ClanPowerProfile.cs     (Klan gÃ¼Ã§ profili - FAZ 7)
â”‚   â”‚   â”‚   â”œâ”€â”€ TerritoryData.cs       (BÃ¶lge verisi - FAZ 4)
â”‚   â”‚   â”‚   â”œâ”€â”€ ContractData.cs         (Kontrat verisi - FAZ 4)
â”‚   â”‚   â”‚   â””â”€â”€ AllianceData.cs         (Ä°ttifak verisi - FAZ 8)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Databases/
â”‚   â”‚   â”‚   â”œâ”€â”€ ItemDatabase.cs          (EÅŸya lookup - FAZ 4)
â”‚   â”‚   â”‚   â”œâ”€â”€ MobDatabase.cs           (Mob lookup - FAZ 5)
â”‚   â”‚   â”‚   â”œâ”€â”€ BossDatabase.cs          (Boss lookup - FAZ 5)
â”‚   â”‚   â”‚   â”œâ”€â”€ DisasterDatabase.cs      (Felaket lookup - FAZ 5)
â”‚   â”‚   â”‚   â”œâ”€â”€ TrapDatabase.cs          (Tuzak lookup - FAZ 5)
â”‚   â”‚   â”‚   â”œâ”€â”€ RideableMobDatabase.cs   (Binilebilir mob lookup - FAZ 7)
â”‚   â”‚   â”‚   â”œâ”€â”€ StructureEffectDatabase.cs (YapÄ± efekt lookup - FAZ 7)
â”‚   â”‚   â”‚   â””â”€â”€ MissionDatabase.cs       (GÃ¶rev lookup - FAZ 8)
â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   Not: DatabaseManager.cs iÃ§inde FAZ 8 iÃ§in yeni tablolar ve metodlar eklendi:
â”‚   â”‚   â”‚   - caravans tablosu (CaravanManager iÃ§in)
â”‚   â”‚   â”‚   - researches tablosu (ResearchManager iÃ§in)
â”‚   â”‚   â”‚   - breedings tablosu (BreedingManager iÃ§in)
â”‚   â”‚   â”‚   - shops ve shop_items tablolarÄ± (ShopManager iÃ§in)
â”‚   â”‚   â”‚   - missions tablosu (MissionManager iÃ§in)
â”‚   â”‚   â”‚   - supply_drops tablosu (SupplyDropManager iÃ§in)
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ Definitions/
â”‚   â”‚       â”œâ”€â”€ ItemDefinition.cs       (Item tanÄ±mÄ± - FAZ 4)
â”‚   â”‚       â”‚   - isChisel property (Chisel alet kontrolÃ¼ - FAZ 4)
â”‚   â”‚       â”‚   - chiselDefinition property (Chisel tanÄ±mÄ± - FAZ 4)
â”‚   â”‚       â”‚   - chiselLevel property (Basic, Advanced, Master - FAZ 4)
â”‚   â”‚       â”œâ”€â”€ RitualRecipe.cs         (RitÃ¼el tarifi - FAZ 4)
â”‚   â”‚       â”œâ”€â”€ BiomeDefinition.cs      (Biyom tanÄ±mÄ± - FAZ 3)
â”‚   â”‚       â”œâ”€â”€ MobDefinition.cs        (Mob tanÄ±mÄ± - FAZ 5)
â”‚   â”‚       â”œâ”€â”€ BossDefinition.cs       (Boss tanÄ±mÄ± - FAZ 5)
â”‚   â”‚       â”œâ”€â”€ DisasterDefinition.cs    (Felaket tanÄ±mÄ± - FAZ 5)
â”‚   â”‚       â”œâ”€â”€ TrapDefinition.cs       (Tuzak tanÄ±mÄ± - FAZ 5)
â”‚   â”‚       â”œâ”€â”€ MissionDefinition.cs    (GÃ¶rev tanÄ±mÄ± - FAZ 8)
â”‚   â”‚       â”œâ”€â”€ RideableMobDefinition.cs (Binek mob tanÄ±mÄ± - FAZ 7)
â”‚   â”‚       â”œâ”€â”€ StructureEffectDefinition.cs (YapÄ± efekt tanÄ±mÄ± - FAZ 7)
â”‚   â”‚       â”œâ”€â”€ OreDefinition.cs         (Maden tanÄ±mÄ± - FAZ 3)
â”‚   â”‚       â”‚   - minDepth, maxDepth (derinlik aralÄ±ÄŸÄ±)
â”‚   â”‚       â”‚   - spawnChance (spawn ÅŸansÄ±)
â”‚   â”‚       â”‚   - itemDropId (kÄ±rÄ±ldÄ±ÄŸÄ±nda dÃ¼ÅŸecek item)
â”‚   â”‚       â”‚
â”‚   â”‚       â”œâ”€â”€ ChiselDefinition.cs      (Chisel alet tanÄ±mÄ± - FAZ 4)
â”‚   â”‚       â”‚   - chiselId, chiselName
â”‚   â”‚       â”‚   - supportedMaterials (MaterialType array)
â”‚   â”‚       â”‚   - precision (kesim hassasiyeti)
â”‚   â”‚       â”‚   - durability (dayanÄ±klÄ±lÄ±k)
â”‚   â”‚       â”‚   - cuttingSpeed (kesim hÄ±zÄ±)
â”‚   â”‚       â”‚
â”‚   â”‚       â”œâ”€â”€ CraftingRecipe.cs        (Crafting tarifi - FAZ 4 - ADIM 1.6)
â”‚   â”‚       â”‚   - recipeId, recipeName
â”‚   â”‚       â”‚   - resultItem, resultAmount
â”‚   â”‚       â”‚   - ingredients (RecipeIngredient list)
â”‚   â”‚       â”‚   - requiredTableLevel (None, Basic, Advanced, Master)
â”‚   â”‚       â”‚   - craftingTime
â”‚   â”‚       â”‚
â”‚   â”‚       â”œâ”€â”€ CookingRecipe.cs          (PiÅŸirme tarifi - FAZ 4 - ADIM 1.14)
â”‚   â”‚       â”‚   - recipeId, recipeName
â”‚   â”‚       â”‚   - resultItem, resultAmount
â”‚   â”‚       â”‚   - ingredients (RecipeIngredient list)
â”‚   â”‚       â”‚   - cookingTime
â”‚   â”‚       â”‚   - requiredCookingStationLevel
â”‚   â”‚       â”‚
â”‚   â”‚       â”œâ”€â”€ SmeltingRecipe.cs        (Eritme tarifi - FAZ 4 - ADIM 1.24)
â”‚   â”‚       â”‚   - recipeId, recipeName
â”‚   â”‚       â”‚   - inputItem, inputAmount
â”‚   â”‚       â”‚   - outputItem, outputAmount
â”‚   â”‚       â”‚   - fuelRequired
â”‚   â”‚       â”‚   - smeltingTime
â”‚   â”‚       â”‚
â”‚   â”‚       â”œâ”€â”€ FoodDefinition.cs         (Yemek tanÄ±mÄ± - FAZ 4 - ADIM 1.14)
â”‚   â”‚       â”‚   - foodId, foodName
â”‚   â”‚       â”‚   - hungerRestore, healthRestore
â”‚   â”‚       â”‚   - foodQuality (Common, Good, Excellent, Perfect)
â”‚   â”‚       â”‚   - foodBuffs (StatusEffect list)
â”‚   â”‚       â”‚
â”‚   â”‚       â”œâ”€â”€ StatusEffectDefinition.cs (Durum efekt tanÄ±mÄ± - FAZ 4 - ADIM 1.15)
â”‚   â”‚       â”‚   - effectId, effectName
â”‚   â”‚       â”‚   - effectType (Poison, Burn, Freeze, Slow, vb.)
â”‚   â”‚       â”‚   - duration, damagePerSecond
â”‚   â”‚       â”‚   - statModifications (speed, damage, defense multipliers)
â”‚   â”‚       â”‚   - maxStacks
â”‚   â”‚       â”‚
â”‚   â”‚       â”œâ”€â”€ SpellDefinition.cs       (BÃ¼yÃ¼ tanÄ±mÄ± - FAZ 4 - ADIM 1.18)
â”‚   â”‚       â”‚   - spellId, spellName
â”‚   â”‚       â”‚   - spellSchool (Fire, Ice, Lightning, Nature, Dark, Light)
â”‚   â”‚       â”‚   - manaCost, castTime, cooldown
â”‚   â”‚       â”‚   - damage, range
â”‚   â”‚       â”‚   - spellEffectType (Damage, Heal, Buff, Debuff, Teleport, Summon)
â”‚   â”‚       â”‚
â”‚   â”‚       â”œâ”€â”€ CropDefinition.cs        (Bitki tanÄ±mÄ± - FAZ 4 - ADIM 1.22)
â”‚   â”‚       â”‚   - cropId, cropName
â”‚   â”‚       â”‚   - growthStages (5 aÅŸama)
â”‚   â”‚       â”‚   - growthTime (her aÅŸama iÃ§in)
â”‚   â”‚       â”‚   - harvestResult (ItemDefinition, amount)
â”‚   â”‚       â”‚
â”‚   â”‚       â”œâ”€â”€ FishDefinition.cs         (BalÄ±k tanÄ±mÄ± - FAZ 4 - ADIM 1.23)
â”‚   â”‚       â”‚   - fishId, fishName
â”‚   â”‚       â”‚   - catchChance
â”‚   â”‚       â”‚   - rewardItems (ItemDefinition list)
â”‚   â”‚       â”‚
â”‚   â”‚       â””â”€â”€ ChestDefinition.cs        (SandÄ±k tanÄ±mÄ± - FAZ 4 - ADIM 1.25)
â”‚   â”‚           - chestId, chestName
â”‚   â”‚           - inventorySlots
â”‚   â”‚           - canLock
â”‚   â”‚           - category (Material, Weapon, Tool, vb.)
â”‚   â”‚
â”‚   â”œâ”€â”€ Systems/
â”‚   â”‚   â”œâ”€â”€ Mining/
â”‚   â”‚   â”‚   â”œâ”€â”€ NetworkMining.cs        (Server-authoritative kazÄ± - FAZ 1)
â”‚   â”‚   â”‚   â”‚   - Hold to break mekaniÄŸi
â”‚   â”‚   â”‚   â”‚   - Block hardness sistemi
â”‚   â”‚   â”‚   â”‚   - Tool efficiency
â”‚   â”‚   â”‚   â”‚   - Break progress indicator
â”‚   â”‚   â”‚   â”‚   - Item drop sistemi
â”‚   â”‚   â”‚   â”‚   - Block placement
â”‚   â”‚   â”‚   â”‚   - Voxel terrain entegrasyonu
â”‚   â”‚   â”‚   â”‚   - ChiselTool entegrasyonu (FAZ 4)
â”‚   â”‚   â”‚   â”‚   - EnableChiselMode() / DisableChiselMode()
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â””â”€â”€ OreSpawner.cs           (Voxel maden spawn - FAZ 3)
â”‚   â”‚   â”‚       - TerrainDensity.compute entegrasyonu
â”‚   â”‚   â”‚       - Job System ile paralel spawn
â”‚   â”‚   â”‚       - Spawn edilmiÅŸ madenler cache'i
â”‚   â”‚   â”‚       - YÃ¼kseklik bazlÄ± maden daÄŸÄ±lÄ±mÄ±
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Nature/
â”‚   â”‚   â”‚   â”œâ”€â”€ VoxelTreeGenerator.cs   (ProsedÃ¼rel aÄŸaÃ§ oluÅŸturma - FAZ 3)
â”‚   â”‚   â”‚   â”‚   - L-System/Fractal Tree algoritmasÄ±
â”‚   â”‚   â”‚   â”‚   - Job System ile paralel generation
â”‚   â”‚   â”‚   â”‚   - Voxel bloklardan aÄŸaÃ§ oluÅŸturma
â”‚   â”‚   â”‚   â”‚   - AÄŸaÃ§ kaldÄ±rma (RemoveTreeAt)
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â””â”€â”€ TreeGrowthSystem.cs     (AÅŸamalÄ± bÃ¼yÃ¼me yÃ¶netimi - FAZ 3)
â”‚   â”‚   â”‚       - 5 bÃ¼yÃ¼me aÅŸamasÄ± (Fidan, KÃ¼Ã§Ã¼k, Orta, BÃ¼yÃ¼k, Olgun)
â”‚   â”‚   â”‚       - Coroutine bazlÄ± zaman yÃ¶netimi
â”‚   â”‚   â”‚       - BÃ¼yÃ¼yen aÄŸaÃ§lar cache'i
â”‚   â”‚   â”‚       - Toplam ~32 dakika bÃ¼yÃ¼me sÃ¼resi
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Building/
â”‚   â”‚   â”‚   â”œâ”€â”€ GridPlacementSystem.cs  (Grid tabanlÄ± yerleÅŸtirme - FAZ 3)
â”‚   â”‚   â”‚   â”‚   - 1 metre grid sistemi
â”‚   â”‚   â”‚   â”‚   - Grid pozisyon cache'i
â”‚   â”‚   â”‚   â”‚   - Smooth voxel dÃ¼nyada tutarlÄ± inÅŸa
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ BlueprintSystem.cs      (YapÄ± kaydetme/kopyalama - FAZ 3)
â”‚   â”‚   â”‚   â”‚   - Blueprint kaydetme (JSON)
â”‚   â”‚   â”‚   â”‚   - Blueprint yÃ¼kleme ve yerleÅŸtirme
â”‚   â”‚   â”‚   â”‚   - Blueprint cache sistemi
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ SculptingSystem.cs      (Blok yontma - FAZ 3)
â”‚   â”‚   â”‚   â”‚   - Blok ÅŸekil verme
â”‚   â”‚   â”‚   â”‚   - Template kaydetme
â”‚   â”‚   â”‚   â”‚   - Template uygulama
â”‚   â”‚   â”‚   â”‚   - YontulmuÅŸ ÅŸekiller cache'i
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ ChiselTool.cs           (Blok ÅŸekillendirme aleti - FAZ 4)
â”‚   â”‚   â”‚   â”‚   - IEquippable interface (NetworkMining entegrasyonu)
â”‚   â”‚   â”‚   â”‚   - 3 kesim modu (KÃ¼p, Yuvarlak, Ã‡apraz)
â”‚   â”‚   â”‚   â”‚   - Ä°ki nokta seÃ§imi sistemi
â”‚   â”‚   â”‚   â”‚   - Alet kuÅŸanma/Ã§Ä±karma
â”‚   â”‚   â”‚   â”‚   - Malzeme uyumluluÄŸu kontrolÃ¼
â”‚   â”‚   â”‚   â”‚   - Alet dayanÄ±klÄ±lÄ±k sistemi
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ ChiselRaycast.cs        (Voxel terrain raycast - FAZ 4)
â”‚   â”‚   â”‚   â”‚   - Voxel terrain uyumlu raycast
â”‚   â”‚   â”‚   â”‚   - ChunkManager entegrasyonu
â”‚   â”‚   â”‚   â”‚   - Grid sistemi entegrasyonu
â”‚   â”‚   â”‚   â”‚   - Raycast cache optimizasyonu (50ms)
â”‚   â”‚   â”‚   â”‚   - Hassas nokta hesaplama (grid'e yapÄ±ÅŸtÄ±rma)
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ BlockSelectionVisualizer.cs (SeÃ§im gÃ¶rselleÅŸtirme - FAZ 4)
â”‚   â”‚   â”‚   â”‚   - BaÅŸlangÄ±Ã§/bitiÅŸ noktasÄ± marker'larÄ±
â”‚   â”‚   â”‚   â”‚   - Kesim Ã§izgileri (LineRenderer)
â”‚   â”‚   â”‚   â”‚   - Ã–nizleme mesh'i
â”‚   â”‚   â”‚   â”‚   - Grid Ã§izgileri
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ BlockCuttingSystem.cs   (Blok kesim sistemi - FAZ 4)
â”‚   â”‚   â”‚   â”‚   - VariantMeshGenerator entegrasyonu
â”‚   â”‚   â”‚   â”‚   - ChunkManager entegrasyonu
â”‚   â”‚   â”‚   â”‚   - Variant ID oluÅŸturma (VariantMeshGenerator uyumlu)
â”‚   â”‚   â”‚   â”‚   - Chunk regeneration (coroutine)
â”‚   â”‚   â”‚   â”‚   - Kesim geÃ§miÅŸi (undo/redo iÃ§in)
â”‚   â”‚   â”‚   â”‚   - Network senkronizasyonu
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ ShapeApplicationSystem.cs (Åekil kaydetme/uygulama - FAZ 4)
â”‚   â”‚   â”‚   â”‚   - 9 slot ÅŸekil kayÄ±t sistemi
â”‚   â”‚   â”‚   â”‚   - JSON kayÄ±t/yÃ¼kleme
â”‚   â”‚   â”‚   â”‚   - Åekil uygulama (saÄŸ tÄ±k)
â”‚   â”‚   â”‚   â”‚   - Malzeme uyumluluÄŸu kontrolÃ¼
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â””â”€â”€ CutMode.cs              (Enum'lar ve data yapÄ±larÄ± - FAZ 4)
â”‚   â”‚   â”‚       - CutMode enum (Cube, Rounded, Diagonal)
â”‚   â”‚   â”‚       - MaterialType enum (Wood, Stone, Metal)
â”‚   â”‚   â”‚       - CutParameters class
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Blocks/
â”‚   â”‚   â”‚   â””â”€â”€ VariantMeshGenerator.cs  (740 variant mesh generation - FAZ 3)
â”‚   â”‚   â”‚       - Algoritma tabanlÄ± mesh oluÅŸturma
â”‚   â”‚   â”‚       - Dik kesimler (6 yÃ¶n, 5 seviye)
â”‚   â”‚   â”‚       - Ã‡apraz kesimler, yuvarlanmÄ±ÅŸ kÃ¶ÅŸeler
â”‚   â”‚   â”‚       - Ramp, merdiven, kÃ¶ÅŸe ÅŸekilleri
â”‚   â”‚   â”‚       - Ã–zel ÅŸekiller (trapezoid, pyramid, hemisphere)
â”‚   â”‚   â”‚       - Mesh cache sistemi (O(1) lookup)
â”‚   â”‚   â”‚       - Pre-generated meshes (runtime generation yok)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Biomes/
â”‚   â”‚   â”‚   â””â”€â”€ BiomeManager.cs         (Biyom seÃ§imi ve yÃ¶netimi - FAZ 3)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Water/
â”‚   â”‚   â”‚   â”œâ”€â”€ WaterSimulator.cs       (Voxel su simÃ¼lasyonu - FAZ 3)
â”‚   â”‚   â”‚   â”‚   - Su seviyesi yÃ¶netimi (0-7 arasÄ±, 8=kaynak su)
â”‚   â”‚   â”‚   â”‚   - AÅŸaÄŸÄ± akÄ±ÅŸ (Gravity - en yÃ¼ksek Ã¶ncelik)
â”‚   â”‚   â”‚   â”‚   - Yan tarafa akÄ±ÅŸ (4 yÃ¶n: kuzey, gÃ¼ney, doÄŸu, batÄ±)
â”‚   â”‚   â”‚   â”‚   - YayÄ±lma mekaniÄŸi (su seviyesi dengeleme)
â”‚   â”‚   â”‚   â”‚   - Ã–ncelik sistemi (AÅŸaÄŸÄ± > Yan > YayÄ±lma)
â”‚   â”‚   â”‚   â”‚   - BoÅŸluk kontrolÃ¼ (su sadece boÅŸ voxel'lere akar)
â”‚   â”‚   â”‚   â”‚   - Kaynak su (sonsuz su kaynaÄŸÄ±)
â”‚   â”‚   â”‚   â”‚   - Chunk bazlÄ± cache
â”‚   â”‚   â”‚   â”‚   - GPU Ã¼zerinde hesaplama
â”‚   â”‚   â”‚   â”‚   - GetWaterLevel(), AddWater(), RemoveWater(), AddWaterSource() metodlarÄ±
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â””â”€â”€ OceanPlane.cs           (Sonsuz okyanus - FAZ 3)
â”‚   â”‚   â”‚       - Oyuncuyu takip eden dÃ¼zlem
â”‚   â”‚   â”‚       - Y=0 seviyesinde sonsuz okyanus
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Rituals/
â”‚   â”‚   â”‚   â”œâ”€â”€ RitualManager.cs        (Batarya sistemi - FAZ 4)
â”‚   â”‚   â”‚   â”œâ”€â”€ RitualInputHandler.cs   (RitÃ¼el giriÅŸ - FAZ 4)
â”‚   â”‚   â”‚   â””â”€â”€ GhostRecipeManager.cs    (Hayalet tarif - FAZ 8)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Crafting/                   (FAZ 4 - ADIM 1.6 - Crafting Sistemi)
â”‚   â”‚   â”‚   â”œâ”€â”€ CraftingRecipe.cs        (ScriptableObject - Recipe tanÄ±mlarÄ±)
â”‚   â”‚   â”‚   â”œâ”€â”€ CraftingTable.cs         (NetworkBehaviour - Crafting table yapÄ±sÄ±, IInteractable)
â”‚   â”‚   â”‚   â”œâ”€â”€ CraftingManager.cs       (Manager - Crafting mantÄ±ÄŸÄ±, Dictionary cache O(1) lookup)
â”‚   â”‚   â”‚   â””â”€â”€ CraftingUI.cs            (UI Manager - Crafting interface, UI pooling)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Inventory/                   (FAZ 4 - ADIM 1.7 - KapsamlÄ± Envanter Sistemi)
â”‚   â”‚   â”‚   â”œâ”€â”€ InventorySlot.cs           (Slot veri yapÄ±sÄ± - item, amount, weight)
â”‚   â”‚   â”‚   â””â”€â”€ PlayerInventory.cs       (NetworkBehaviour - Envanter mantÄ±ÄŸÄ±, SyncList, Dictionary cache O(1) lookup)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Furniture/                   (FAZ 4 - ADIM 1.8 - Furniture Sistemi)
â”‚   â”‚   â”‚   â”œâ”€â”€ FurnitureDefinition.cs     (ScriptableObject - Furniture tanÄ±mlarÄ± - Data klasÃ¶rÃ¼nde)
â”‚   â”‚   â”‚   â”œâ”€â”€ FurniturePlacer.cs        (Furniture yerleÅŸtirme - StructurePlacer entegrasyonu)
â”‚   â”‚   â”‚   â””â”€â”€ FurnitureInteraction.cs   (IInteractable - Sit, Sleep, Chest, Workbench)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Tools/                       (FAZ 4 - ADIM 1.9 - Ä°ÅŸlevsel Item'ler)
â”‚   â”‚   â”‚   â”œâ”€â”€ ToolDurability.cs          (Durability sistemi - async database persistence)
â”‚   â”‚   â”‚   â”œâ”€â”€ RepairStation.cs           (Tool repair - malzeme kontrolÃ¼, IInteractable)
â”‚   â”‚   â”‚   â”œâ”€â”€ UpgradeStation.cs          (Tool upgrade - seviye artÄ±ÅŸÄ±, malzeme kontrolÃ¼)
â”‚   â”‚   â”‚   â””â”€â”€ EnchantmentSystem.cs       (Enchantment sistemi - Dictionary cache O(1) lookup)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ NPCs/                        (FAZ 5 - ADIM 1.10 - NPC Sistemi)
â”‚   â”‚   â”‚   â”œâ”€â”€ NPCDefinition.cs           (ScriptableObject - NPC tanÄ±mlarÄ± - Data klasÃ¶rÃ¼nde)
â”‚   â”‚   â”‚   â”œâ”€â”€ NPCAI.cs                  (NPC AI - State Machine, NavMesh pathfinding)
â”‚   â”‚   â”‚   â”œâ”€â”€ VillagerTrading.cs        (Ticaret sistemi - Trade history cache)
â”‚   â”‚   â”‚   â”œâ”€â”€ DialogueSystem.cs         (Diyalog sistemi - Dialogue state cache)
â”‚   â”‚   â”‚   â””â”€â”€ VillageGenerator.cs       (KÃ¶y oluÅŸturma - Job System + Burst)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Mounts/                      (FAZ 7 - ADIM 1.11 - GeliÅŸmiÅŸ Binek Sistemi)
â”‚   â”‚   â”‚   â”œâ”€â”€ SaddleDefinition.cs       (ScriptableObject - EÄŸer tanÄ±mlarÄ± - Data klasÃ¶rÃ¼nde)
â”‚   â”‚   â”‚   â”œâ”€â”€ MountInventory.cs          (Binek envanteri - SyncList, async database)
â”‚   â”‚   â”‚   â”œâ”€â”€ MountArmor.cs              (Binek zÄ±rhÄ± - Hasar azaltma)
â”‚   â”‚   â”‚   â”œâ”€â”€ MountAbilities.cs          (Binek yetenekleri - Dash, Jump, Charge, Heal, Shield)
â”‚   â”‚   â”‚   â””â”€â”€ MountLeveling.cs           (Binek seviye sistemi - Experience sistemi, exponential growth)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Bosses/                      (FAZ 5 - ADIM 1.12 - GeliÅŸmiÅŸ Boss Sistemi)
â”‚   â”‚   â”‚   â”œâ”€â”€ BossArenaDefinition.cs     (ScriptableObject - Arena tanÄ±mlarÄ± - Data klasÃ¶rÃ¼nde)
â”‚   â”‚   â”‚   â”œâ”€â”€ DragonAI.cs                (Ejderha AI - Flight state machine, Unity Physics)
â”‚   â”‚   â”‚   â”œâ”€â”€ BossArena.cs              (Boss arenasÄ± - StructurePlacer entegrasyonu)
â”‚   â”‚   â”‚   â”œâ”€â”€ BossLootTable.cs          (Loot sistemi - Rarity bazlÄ±)
â”‚   â”‚   â”‚   â”œâ”€â”€ BossPhaseSystem.cs        (Multi-phase fight sistemi)
â”‚   â”‚   â”‚   â””â”€â”€ BossSummoning.cs         (Ã‡aÄŸÄ±rma sistemi - Ritual malzeme kontrolÃ¼)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Mobs/                        (FAZ 5 - ADIM 1.13 - Ã–zel CanlÄ± Tipleri)
â”‚   â”‚   â”‚   â”œâ”€â”€ MobClassDefinition.cs      (ScriptableObject - Mob sÄ±nÄ±f tanÄ±mlarÄ± - Data klasÃ¶rÃ¼nde)
â”‚   â”‚   â”‚   â”œâ”€â”€ MobAbilitySystem.cs       (Mob yetenek sistemi - Cooldown, Level scaling)
â”‚   â”‚   â”‚   â”œâ”€â”€ MobArmorSystem.cs         (Mob zÄ±rh sistemi)
â”‚   â”‚   â”‚   â””â”€â”€ MobLeveling.cs            (Mob seviye sistemi - Experience sistemi)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Food/                        (FAZ 4 - ADIM 1.14 - Yemek ve AÃ§lÄ±k Sistemi)
â”‚   â”‚   â”‚   â”œâ”€â”€ FoodDefinition.cs          (ScriptableObject - Yemek tanÄ±mlarÄ± - Data klasÃ¶rÃ¼nde)
â”‚   â”‚   â”‚   â”œâ”€â”€ HungerSystem.cs           (AÃ§lÄ±k sistemi - Coroutine, async database)
â”‚   â”‚   â”‚   â””â”€â”€ CookingStation.cs         (PiÅŸirme sistemi - IInteractable, malzeme kontrolÃ¼)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ StatusEffects/                (FAZ 4 - ADIM 1.15 - HastalÄ±k ve Durum Sistemi)
â”‚   â”‚   â”‚   â”œâ”€â”€ StatusEffectDefinition.cs  (ScriptableObject - Durum efekt tanÄ±mlarÄ± - Data klasÃ¶rÃ¼nde)
â”‚   â”‚   â”‚   â”œâ”€â”€ StatusEffectManager.cs    (Durum efekt yÃ¶neticisi - Coroutine, Stack sistemi)
â”‚   â”‚   â”‚   â””â”€â”€ DiseaseSystem.cs          (HastalÄ±k sistemi - Disease state cache)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Weather/                     (FAZ 4 - ADIM 1.16 - Zaman ve Hava Sistemi)
â”‚   â”‚   â”‚   â”œâ”€â”€ WeatherSystem.cs          (Hava durumu sistemi - Coroutine, mevsim bazlÄ±)
â”‚   â”‚   â”‚   â”œâ”€â”€ SeasonSystem.cs           (Mevsim sistemi - GameTimeManager entegrasyonu)
â”‚   â”‚   â”‚   â”œâ”€â”€ TemperatureSystem.cs      (SÄ±caklÄ±k sistemi - YÃ¼kseklik bazlÄ±, status effect'ler)
â”‚   â”‚   â”‚   â””â”€â”€ WeatherEffects.cs        (Hava durumu efektleri - Unity Particle System, Unity Audio)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Dungeons/                    (FAZ 5 - ADIM 1.17 - Zindan ve MaÄŸara Sistemi)
â”‚   â”‚   â”‚   â”œâ”€â”€ DungeonDefinition.cs       (ScriptableObject - Zindan tanÄ±mlarÄ± - Data klasÃ¶rÃ¼nde)
â”‚   â”‚   â”‚   â”œâ”€â”€ DungeonGenerator.cs       (Zindan oluÅŸturma - Job System + Burst)
â”‚   â”‚   â”‚   â””â”€â”€ DungeonEntrance.cs        (Zindan giriÅŸi - Key kontrolÃ¼, IInteractable)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Magic/                       (FAZ 4 - ADIM 1.18 - Magic ve BÃ¼yÃ¼ Sistemi)
â”‚   â”‚   â”‚   â”œâ”€â”€ SpellDefinition.cs         (ScriptableObject - BÃ¼yÃ¼ tanÄ±mlarÄ± - Data klasÃ¶rÃ¼nde)
â”‚   â”‚   â”‚   â”œâ”€â”€ ManaSystem.cs             (Mana sistemi - Coroutine, async database)
â”‚   â”‚   â”‚   â””â”€â”€ SpellCasting.cs           (BÃ¼yÃ¼ kullanma - ManaSystem entegrasyonu)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Tech/                        (FAZ 8 - ADIM 1.19 - Teknoloji AÄŸacÄ±)
â”‚   â”‚   â”‚   â”œâ”€â”€ TechNodeDefinition.cs     (ScriptableObject - Teknoloji dÃ¼ÄŸÃ¼m tanÄ±mlarÄ± - Data klasÃ¶rÃ¼nde)
â”‚   â”‚   â”‚   â””â”€â”€ TechTreeManager.cs        (Teknoloji aÄŸacÄ± yÃ¶neticisi - Prerequisite kontrolÃ¼)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Vehicles/                    (FAZ 7 - ADIM 1.20 - AraÃ§ ve UlaÅŸÄ±m Sistemi)
â”‚   â”‚   â”‚   â”œâ”€â”€ VehicleDefinition.cs       (ScriptableObject - AraÃ§ tanÄ±mlarÄ± - Data klasÃ¶rÃ¼nde)
â”‚   â”‚   â”‚   â””â”€â”€ VehicleController.cs      (AraÃ§ kontrolÃ¼ - Unity Physics)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Pets/                        (FAZ 5 - ADIM 1.21 - Pet ve Ev HayvanÄ± Sistemi)
â”‚   â”‚   â”‚   â”œâ”€â”€ PetDefinition.cs           (ScriptableObject - Pet tanÄ±mlarÄ± - Data klasÃ¶rÃ¼nde)
â”‚   â”‚   â”‚   â””â”€â”€ PetSystem.cs              (Pet sistemi - Pet spawn, komut, leveling)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Farming/                     (FAZ 4 - ADIM 1.22 - TarÄ±m ve Ã‡iftÃ§ilik Sistemi)
â”‚   â”‚   â”‚   â”œâ”€â”€ CropDefinition.cs          (ScriptableObject - Bitki tanÄ±mlarÄ± - Data klasÃ¶rÃ¼nde)
â”‚   â”‚   â”‚   â””â”€â”€ FarmingSystem.cs          (Ã‡iftÃ§ilik sistemi - Crop planting, growth, harvest)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Fishing/                     (FAZ 4 - ADIM 1.23 - BalÄ±kÃ§Ä±lÄ±k Sistemi)
â”‚   â”‚   â”‚   â”œâ”€â”€ FishDefinition.cs          (ScriptableObject - BalÄ±k tanÄ±mlarÄ± - Data klasÃ¶rÃ¼nde)
â”‚   â”‚   â”‚   â””â”€â”€ FishingSystem.cs          (BalÄ±kÃ§Ä±lÄ±k sistemi - Fishing minigame, fish spawn)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Smelting/                    (FAZ 4 - ADIM 1.24 - Madencilik ve Eritme Sistemi)
â”‚   â”‚   â”‚   â”œâ”€â”€ SmeltingRecipe.cs          (ScriptableObject - Eritme tarifleri - Data klasÃ¶rÃ¼nde)
â”‚   â”‚   â”‚   â””â”€â”€ SmeltingSystem.cs         (Eritme sistemi - Furnace entegrasyonu, fuel tÃ¼ketimi)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Storage/                      (FAZ 4 - ADIM 1.25 - Depolama ve SandÄ±k Sistemi)
â”‚   â”‚   â”‚   â”œâ”€â”€ ChestDefinition.cs         (ScriptableObject - SandÄ±k tanÄ±mlarÄ± - Data klasÃ¶rÃ¼nde)
â”‚   â”‚   â”‚   â””â”€â”€ ChestInventory.cs         (SandÄ±k envanteri - SyncList, async database, lock sistemi)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Clans/
â”‚   â”‚   â”‚   â”œâ”€â”€ TerritoryManager.cs     (Flood-Fill bÃ¶lge hesaplama - FAZ 4 - Job System optimizasyonu ile)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ FloodFillJob        (CPU paralel flood-fill - Job System + Burst - FAZ 4)
â”‚   â”‚   â”‚   â”œâ”€â”€ ClanPowerManager.cs     (GÃ¼Ã§ hesaplama - FAZ 7)
â”‚   â”‚   â”‚   â”œâ”€â”€ OfflineProtectionSystem.cs (Offline koruma - FAZ 7)
â”‚   â”‚   â”‚   â””â”€â”€ AllianceManager.cs      (Ä°ttifak - FAZ 8)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Economy/
â”‚   â”‚   â”‚   â”œâ”€â”€ ContractManager.cs      (Kontrat sistemi - FAZ 4)
â”‚   â”‚   â”‚   â”œâ”€â”€ CaravanManager.cs       (Kervan - FAZ 8)
â”‚   â”‚   â”‚   â””â”€â”€ ShopManager.cs          (Market - FAZ 8)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Research/
â”‚   â”‚   â”‚   â””â”€â”€ ResearchManager.cs      (AraÅŸtÄ±rma - FAZ 8)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Taming/
â”‚   â”‚   â”‚   â”œâ”€â”€ TamingManager.cs        (EÄŸitme - FAZ 4 - Voxel terrain uyumlu)
â”‚   â”‚   â”‚   â””â”€â”€ BreedingManager.cs      (Ãœreme - FAZ 8)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Missions/
â”‚   â”‚   â”‚   â””â”€â”€ MissionManager.cs       (GÃ¶rev - FAZ 8)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Events/
â”‚   â”‚   â”‚   â””â”€â”€ SupplyDropManager.cs    (Supply Drop - FAZ 8)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Combat/
â”‚   â”‚   â”‚   â”œâ”€â”€ HealthComponent.cs      (Can sistemi - FAZ 5)
â”‚   â”‚   â”‚   â”œâ”€â”€ ArmorComponent.cs       (ZÄ±rh sistemi - FAZ 5)
â”‚   â”‚   â”‚   â”œâ”€â”€ SiegeBeacon.cs          (KuÅŸatma iÅŸareti - FAZ 7)
â”‚   â”‚   â”‚   â”œâ”€â”€ SiegeManager.cs         (KuÅŸatma yÃ¶neticisi - FAZ 7)
â”‚   â”‚   â”‚   â””â”€â”€ SiegeWeaponManager.cs    (Balista/MancÄ±nÄ±k - FAZ 8)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Buildings/
â”‚   â”‚   â”‚   â”œâ”€â”€ StructureEffectManager.cs (YapÄ± bufflarÄ± - FAZ 7)
â”‚   â”‚   â”‚   â””â”€â”€ StructurePlacer.cs        (Voxel terrain Ã¼zerine yapÄ± yerleÅŸtirme - ChunkManager entegrasyonu - FAZ 4)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Power/
â”‚   â”‚   â”‚   â””â”€â”€ StratocraftPowerSystem.cs (SGP sistemi - FAZ 7)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Interaction/
â”‚   â”‚   â”‚   â”œâ”€â”€ IInteractable.cs         (EtkileÅŸim arayÃ¼zÃ¼ - FAZ 6)
â”‚   â”‚   â”‚   â”œâ”€â”€ InteractionController.cs (EtkileÅŸim kontrolÃ¼ - FAZ 6)
â”‚   â”‚   â”‚   â”œâ”€â”€ PhysicalItem.cs          (Fiziksel item - FAZ 4 - Voxel terrain uyumlu)
â”‚   â”‚   â”‚   â””â”€â”€ ItemSpawner.cs           (Item spawn - FAZ 4 - Voxel terrain uyumlu)
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ Admin/
â”‚   â”‚       â”œâ”€â”€ AdminCommandHandler.cs   (Admin komutlarÄ± - FAZ 8)
â”‚   â”‚       â””â”€â”€ AdminTabCompleter.cs    (Tab completion - FAZ 8)
â”‚   â”‚
â”‚   â”œâ”€â”€ AI/
â”‚   â”‚   â”œâ”€â”€ Core/
â”‚   â”‚   â”‚   â””â”€â”€ ChunkNavMeshBaker.cs    (Dinamik NavMesh - FAZ 5)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Mobs/
â”‚   â”‚   â”‚   â”œâ”€â”€ MobAI.cs                 (Normal mob AI - FAZ 5)
â”‚   â”‚   â”‚   â”œâ”€â”€ MobSpawner.cs            (Mob spawn - FAZ 5)
â”‚   â”‚   â”‚   â”œâ”€â”€ MobIdentity.cs           (Mob kimlik - FAZ 5)
â”‚   â”‚   â”‚   â”œâ”€â”€ RideableMob.cs           (Binek sistemi - FAZ 7)
â”‚   â”‚   â”‚   â””â”€â”€ MobInputController.cs    (Binek kontrolÃ¼ - FAZ 7)
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ Bosses/
â”‚   â”‚       â”œâ”€â”€ BossAI.cs                (Panda BT - FAZ 5)
â”‚   â”‚       â”œâ”€â”€ BossIdentity.cs          (Boss kimlik - FAZ 5)
â”‚   â”‚       â””â”€â”€ BossSpawner.cs           (Boss spawn - FAZ 5)
â”‚   â”‚
â”‚   â”œâ”€â”€ Player/
â”‚   â”‚   â”œâ”€â”€ PlayerController.cs          (Hareket - FAZ 1)
â”‚   â”‚   â””â”€â”€ InteractionController.cs     (Raycast etkileÅŸim - FAZ 6)
â”‚   â”‚
â”‚   â”œâ”€â”€ Network/
â”‚   â”‚   â”œâ”€â”€ PlayerController.cs          (FishNet Player - FAZ 1)
â”‚   â”‚   â””â”€â”€ SyncWorld.cs                 (Seed senkronizasyonu - FAZ 1)
â”‚   â”‚
â”‚   â””â”€â”€ UI/
â”‚       â”œâ”€â”€ HUDManager.cs                (Can barÄ±, bÃ¶lge ismi - FAZ 6)
â”‚       â”œâ”€â”€ Menus/
â”‚       â”‚   â”œâ”€â”€ ContractUI.cs           (Kontrat menÃ¼sÃ¼ - FAZ 6)
â”‚       â”‚   â””â”€â”€ ClanManagementUI.cs     (Klan yÃ¶netim menÃ¼sÃ¼ - FAZ 6)
â”‚       â””â”€â”€ Effects/
â”‚           â”œâ”€â”€ AudioManager.cs          (Ses yÃ¶neticisi - FAZ 6)
â”‚           â””â”€â”€ CameraShake.cs          (Kamera sarsÄ±ntÄ±sÄ± - FAZ 6)
â”‚
â”œâ”€â”€ Editor/                             (Editor-only scripts)
â”‚   â”œâ”€â”€ ConfigEditor.cs                 (Config editor window - FAZ 8)
â”‚   â””â”€â”€ AdminCommandEditor.cs           (Admin komut testi - FAZ 8)
â”‚
â””â”€â”€ Art/                                (GÃ¶rsel varlÄ±klar - Model, Material, Texture, Prefab)
    â”œâ”€â”€ _External/                      (DÄ±ÅŸ kÃ¼tÃ¼phaneler - FAZ 1'de kurulur)
    â”‚   â”œâ”€â”€ FishNet/                    (AÄŸ motoru - FAZ 1)
    â”‚   â”œâ”€â”€ Scrawk/                     (GPU voxel motoru - FAZ 1)
    â”‚   â”œâ”€â”€ FastNoiseLite/              (Biyom matematiÄŸi - FAZ 1)
    â”‚   â”œâ”€â”€ PandaBT/                    (AI behavior tree - FAZ 5)
    â”‚   â”œâ”€â”€ DoTween/                    (UI animasyonlarÄ± - FAZ 6)
    â”‚   â””â”€â”€ KenneyAssets/               (Low-poly modeller - FAZ 1)
    â”‚
    â”œâ”€â”€ Models/                         (3D Modeller - FAZ 1'den baÅŸlar, fazlara gÃ¶re eklenir)
    â”‚   â”œâ”€â”€ Mobs/                       (FAZ 5 - Goblin, Orc, Troll)
    â”‚   â”œâ”€â”€ Bosses/                     (FAZ 5 - Titan Golem, Dragon)
    â”‚   â”œâ”€â”€ Structures/                 (FAZ 4 - Alchemy Tower, Clan Bank)
    â”‚   â””â”€â”€ Items/                      (FAZ 4 - Weapons, Tools)
    â”‚
    â”œâ”€â”€ Materials/                      (Materyaller - FAZ 1'den baÅŸlar)
    â”‚   â”œâ”€â”€ OceanMat.mat                (Okyanus materyali - FAZ 3)
    â”‚   â”œâ”€â”€ VoxelMat.mat                (Voxel materyali - FAZ 1)
    â”‚   â”œâ”€â”€ Terrain/                    (Terrain materyalleri - FAZ 1)
    â”‚   â”‚   â”œâ”€â”€ Grass.mat               (FAZ 1)
    â”‚   â”‚   â”œâ”€â”€ Dirt.mat                (FAZ 1)
    â”‚   â”‚   â”œâ”€â”€ Stone.mat               (FAZ 1)
    â”‚   â”‚   â”œâ”€â”€ Sand.mat                (FAZ 1)
    â”‚   â”‚   â””â”€â”€ Snow.mat                (FAZ 1)
    â”‚   â””â”€â”€ Triplanar/                  (Triplanar texture setleri - FAZ 1)
    â”‚
    â”œâ”€â”€ Textures/                       (Terrain texture'larÄ± - FAZ 1)
    â”‚
    â””â”€â”€ Prefabs/                        (Prefab'lar - Fazlara gÃ¶re eklenir)
        â”œâ”€â”€ Mule.prefab                 (Kervan - FAZ 8)
        â”œâ”€â”€ SupplyDrop.prefab           (Supply Drop - FAZ 8)
        â”œâ”€â”€ Ballista.prefab             (Balista - FAZ 8)
        â”œâ”€â”€ Catapult.prefab             (MancÄ±nÄ±k - FAZ 8)
        â”œâ”€â”€ ResearchTable.prefab        (AraÅŸtÄ±rma MasasÄ± - FAZ 8)
        â””â”€â”€ BreedingCore.prefab         (Ãœreme Ã‡ekirdeÄŸi - FAZ 8)
```

---

## ğŸ“‹ NÄ°HAÄ° Ã–ZET VE DOSYA YAPISI

### âœ… SÄ°STEM TAMAMLANMA DURUMU

**Genel Tamamlanma:** %92

**Faz BazÄ±nda Tamamlanma:**
- **FAZ 1-2 (AltyapÄ± ve DÃ¼nya OluÅŸumu):** %100 âœ…
  - ServiceLocator, GameEntry, NetworkBootstrap âœ…
  - DatabaseManager (SQLite) âœ…
  - ChunkManager (Priority Queue, Mesh Pooling, LOD, Disk Caching, GPU Fallback) âœ…
  - MarchingCubesGPU (LOD, Density Caching) âœ…
  - TerrainDensity.compute âœ…
  - TerrainMaterialManager, TerrainShader âœ…
  - GameTimeManager (GÃ¼n/gece dÃ¶ngÃ¼sÃ¼) âœ…
  - NetworkMining (Server-authoritative kazÄ±) âœ…

- **FAZ 3 (DoÄŸa, Su ve Biyomlar):** %95 âœ…
  - BiomeDefinition, BiomeManager âœ…
  - VegetationSpawner (GPU Instancing) âœ…
  - OceanPlane (Sonsuz okyanus) âœ…
  - WaterSim.compute (DetaylÄ± su mekaniÄŸi - akma, yayÄ±lma, Ã¶ncelik) âœ…
  - WaterSimulator (Su seviyesi yÃ¶netimi, kaynak su) âœ…
  - MaÄŸara sistemi (3D Noise) âœ…
  - âš ï¸ VoxelTreeGenerator + TreeGrowthSystem (Faz 3 entegrasyonu bekleniyor)
  - âš ï¸ OreSpawner (Faz 3 entegrasyonu bekleniyor)
  - âš ï¸ GridPlacementSystem + BlueprintSystem + SculptingSystem (Faz 3 entegrasyonu bekleniyor)

- **FAZ 4 (Oyun Mekanikleri):** %100 âœ…
  - ItemDefinition, ItemDatabase âœ…
  - PhysicalItem, ItemSpawner (Voxel terrain uyumlu) âœ…
  - ItemDefinition gÃ¼ncellemeleri (isChisel, chiselDefinition, chiselLevel) âœ…
  - Blok Åekillendirme Sistemi (ADIM 1.5) âœ…
    - ChiselTool.cs (IEquippable interface, NetworkMining entegrasyonu) âœ…
    - ChiselRaycast.cs (Voxel terrain uyumlu raycast, cache optimizasyonu) âœ…
    - BlockSelectionVisualizer.cs (SeÃ§im gÃ¶rselleÅŸtirme) âœ…
    - BlockCuttingSystem.cs (VariantMeshGenerator entegrasyonu) âœ…
    - ShapeApplicationSystem.cs (9 slot ÅŸekil kayÄ±t sistemi) âœ…
    - ChiselDefinition.cs (ScriptableObject) âœ…
    - CutMode.cs (Enum'lar ve data yapÄ±larÄ±) âœ…
  - RitualManager, RitualInputHandler âœ…
  - TerritoryManager (FloodFillJob - Job System + Burst) âœ…
  - ContractManager âœ…
  - TamingManager (Voxel terrain uyumlu) âœ…
  - StructurePlacer (Voxel terrain uyumlu) âœ…

- **FAZ 5 (Yapay Zeka, SavaÅŸ ve Felaketler):** %100 âœ…
  - ChunkNavMeshBaker (Dinamik NavMesh - Voxel terrain uyumlu) âœ…
  - MobAI, MobSpawner (Voxel terrain uyumlu) âœ…
  - BossAI, BossSpawner (Voxel terrain uyumlu) âœ…
  - HealthComponent, ArmorComponent âœ…
  - DisasterManager (Voxel terrain uyumlu) âœ…
  - TrapManager, TrapCore (Voxel terrain uyumlu) âœ…
  - MobIdentity, BossIdentity âœ…
  - MobDatabase, BossDatabase, DisasterDatabase, TrapDatabase âœ…

- **FAZ 6 (ArayÃ¼z, EtkileÅŸim ve Cila):** %100 âœ…
  - IInteractable, InteractionController (Voxel terrain uyumlu) âœ…
  - HUDManager (Voxel terrain uyumlu) âœ…
  - ContractUI, ClanManagementUI âœ…
  - AudioManager, CameraShake (Voxel terrain uyumlu) âœ…

- **FAZ 7 (GÃ¼Ã§ Sistemi, Binekler ve SavaÅŸ Makineleri):** %100 âœ…
  - PlayerPowerProfile, ClanPowerProfile âœ…
  - StratocraftPowerSystem âœ…
  - RideableMob, MobInputController âœ…
  - SiegeBeacon, SiegeManager âœ…
  - StructureEffectManager âœ…
  - OfflineProtectionSystem âœ…
  - RideableMobDatabase, StructureEffectDatabase âœ…

- **FAZ 8 (Eksik Sistemler, Admin KomutlarÄ±):** %100 âœ…
  - CaravanManager (Voxel terrain uyumlu) âœ…
  - ResearchManager (Voxel terrain uyumlu) âœ…
  - BreedingManager (Voxel terrain uyumlu) âœ…
  - ShopManager (Voxel terrain uyumlu) âœ…
  - MissionManager (Voxel terrain uyumlu) âœ…
  - SupplyDropManager (Voxel terrain uyumlu) âœ…
  - SiegeWeaponManager (Voxel terrain uyumlu) âœ…
  - GhostRecipeManager (Voxel terrain uyumlu) âœ…
  - AllianceManager (Voxel terrain uyumlu) âœ…
  - AdminCommandHandler, AdminTabCompleter âœ…
  - ConfigManager, ConfigEditor âœ…
  - MissionDatabase âœ…
  - DatabaseManager (Faz 8 tablolarÄ± ve metodlarÄ±) âœ…

**Eksik Ã–zellikler (Ä°leride Eklenebilir):**
- âš ï¸ **Su MekaniÄŸi GeliÅŸmiÅŸ Ã–zellikler:** Waterlogging, Lava etkileÅŸimi, DÃ¼ÅŸen su bloklarÄ±, Su altÄ± fizik, Su basÄ±ncÄ±, Su sesleri, Su gÃ¶rsel efektleri (Faz 3+)
- âš ï¸ **Voxel AÄŸaÃ§ Sistemi:** VoxelTreeGenerator, TreeGrowthSystem (Faz 3 entegrasyonu)
- âš ï¸ **Voxel Maden Sistemi:** OreSpawner (Faz 3 entegrasyonu)
- âš ï¸ **Ä°nÅŸa Sistemi:** GridPlacementSystem, BlueprintSystem, SculptingSystem (Faz 3 entegrasyonu)
- âš ï¸ **Blok Variant Sistemi:** VariantMeshGenerator (740 variant per material - Faz 3 entegrasyonu)

**Yeni Eklenen Ã–zellikler (FAZ 4):**
- âœ… **Blok Åekillendirme Sistemi:** ChiselTool, BlockCuttingSystem, ShapeApplicationSystem (Tam entegre)
  - 3 kesim modu (KÃ¼p, Yuvarlak, Ã‡apraz)
  - Ä°ki nokta seÃ§imi sistemi
  - GÃ¶rsel Ã¶nizleme
  - 9 slot ÅŸekil kayÄ±t sistemi
  - NetworkMining entegrasyonu (IEquippable interface)
  - VariantMeshGenerator entegrasyonu
  - ChunkManager entegrasyonu
  - GridPlacementSystem entegrasyonu

**MantÄ±k HatalarÄ± ve Algoritma Eksikleri:**
- âœ… **ChunkManager:** TÃ¼m gerekli metodlar mevcut (GetChunkCoord, GetActiveChunkCoords, GetDensityBufferForChunk)
- âœ… **WaterSim.compute:** Tam su mekaniÄŸi implementasyonu (akma, yayÄ±lma, Ã¶ncelik)
- âœ… **WaterSimulator:** Su seviyesi yÃ¶netimi, kaynak su, yayÄ±lma metodlarÄ± mevcut
- âœ… **Voxel Terrain Entegrasyonu:** TÃ¼m sistemler ChunkManager ile entegre
- âœ… **Database Sistemi:** TÃ¼m fazlar iÃ§in tablolar ve metodlar mevcut
- âœ… **Network Synchronization:** Server-authoritative sistemler mevcut

---

### âœ… TÃœM FAZLARIN KAPSAMLI Ã–ZETÄ°

---

## ğŸš€ FAZ 1 & 2: ALTYAPI KURULUMU VE DÃœNYA OLUÅUMU

### âœ… Temel AltyapÄ± Sistemleri
- âœ… **ServiceLocator.cs** - Merkezi sistem yÃ¶neticisi, tÃ¼m manager'larÄ± tek yerden eriÅŸim
- âœ… **GameEntry.cs** - Oyun baÅŸlatÄ±cÄ±, ilk Ã§alÄ±ÅŸan script
- âœ… **NetworkBootstrap.cs** - FishNet yapÄ±landÄ±rmasÄ±, server/client ayarlarÄ±
- âœ… **DatabaseManager.cs** - SQLite entegrasyonu, veritabanÄ± iÅŸlemleri
- âœ… **ServerConfig.json** - Port, Seed, MaxPlayers ayarlarÄ±

### âœ… GPU DÃ¼nya Motoru (Scrawk Entegrasyonu)
- âœ… **ChunkManager.cs** - Sonsuz dÃ¼nya yÃ¶netimi, priority queue ile yakÄ±n chunklar Ã¶nce yÃ¼klenir
  - Priority Queue (SortedDictionary) - Mesafe bazlÄ± yÃ¼kleme sÄ±rasÄ±
  - Mesh Pooling - Chunk mesh'lerini yeniden kullanma (GC azaltma)
  - LOD System - Uzak chunklar dÃ¼ÅŸÃ¼k detay (performans)
  - Disk Caching - Chunk density data'sÄ±nÄ± disk'e kaydetme (hÄ±zlÄ± yÃ¼kleme)
  - Asenkron Generation - Coroutine ile UI donmasÄ±nÄ± Ã¶nleme
  - ChunkData struct - GameObject, Generator, State, LOD, LastAccessTime
- âœ… **MarchingCubesGPU.cs** - Scrawk'tan modifiye edilmiÅŸ, GPU'da mesh oluÅŸturma
  - LOD desteÄŸi - FarklÄ± detay seviyeleri
  - Density Data caching - Hesaplanan density'yi cache'leme
  - ModifyDensityAtPoint - GPU'da terrain deÄŸiÅŸikliÄŸi
  - SetGenerationParams - Offset ve Seed desteÄŸi
- âœ… **TerrainDensity.compute** - GPU compute shader, voxel density hesaplama
  - Offset + Seed parametreleri
  - Modify kernel - Terrain deÄŸiÅŸikliÄŸi iÃ§in
  - NoiseLib.compute entegrasyonu
- âœ… **VoxelGrid.cs** - Voxel veri yapÄ±sÄ±
- âœ… **MeshBuilder.cs** - Mesh oluÅŸturma yardÄ±mcÄ±larÄ±

### âœ… Terrain Materyalleri ve Shader Sistemi
- âœ… **TerrainMaterialManager.cs** - YÃ¼kseklik ve eÄŸim bazlÄ± materyal seÃ§imi
  - 5 materyal tipi: Grass, Dirt, Stone, Sand, Snow
  - Triplanar texturing desteÄŸi
  - Material blending (aÄŸÄ±rlÄ±k bazlÄ±)
- âœ… **TerrainPoint.cs** - Terrain noktasÄ± veri yapÄ±sÄ±, materyal aÄŸÄ±rlÄ±k hesaplamalarÄ±
- âœ… **TerrainShader.shader** - Unity shader, triplanar texturing + material blending
  - Triplanar texturing - Texture stretching Ã¶nleme
  - Material weights - YÃ¼kseklik ve eÄŸime gÃ¶re blend
  - Normal mapping desteÄŸi
- âœ… **TriplanarTexture.compute** - GPU'da triplanar texturing hesaplama
- âœ… **DualContouring.compute** - Alternatif voxel meshing algoritmasÄ± (opsiyonel)

### âœ… GÃ¼n/Gece DÃ¶ngÃ¼sÃ¼ ve IÅŸÄ±klandÄ±rma
- âœ… **GameTimeManager.cs** - Sunucu tarafÄ± zaman yÃ¶netimi
  - Server-authoritative day/night cycle
  - Dinamik Ä±ÅŸÄ±klandÄ±rma (gÃ¼n doÄŸumu, gÃ¼n batÄ±mÄ±, gece)
  - GÃ¼neÅŸ hareketi ve ay Ä±ÅŸÄ±ÄŸÄ±
  - Network senkronizasyonu (ObserversRpc)

### âœ… AÄŸ Senkronizasyonu ve KazÄ± Sistemi
- âœ… **NetworkMining.cs** - Server-authoritative kazÄ± sistemi
  - ServerRpc ile kazÄ± istekleri
  - Mesafe kontrolÃ¼ (anti-cheat)
  - Cooldown sistemi (spam Ã¶nleme)
  - Chunk update senkronizasyonu
- âœ… **SyncWorld.cs** - World seed senkronizasyonu
  - Server'dan client'a seed gÃ¶nderimi
  - Deterministic world generation

### ğŸ› ï¸ KullanÄ±lan Teknolojiler (Faz 1-2)
- **FishNet** - AÄŸ motoru, NetworkBehaviour
- **Scrawk** - GPU voxel motoru, Marching Cubes
- **FastNoiseLite** - Biyom matematiÄŸi, gÃ¼rÃ¼ltÃ¼ fonksiyonlarÄ±
- **SQLite** - VeritabanÄ±, ACID Ã¶zellikleri
- **Unity Compute Shaders** - GPU hesaplamalarÄ±
- **Unity Coroutines** - Asenkron iÅŸlemler

---

## ğŸŒ FAZ 3: DOÄA, SU VE BÄ°YOMLAR

### âœ… Biyom Sistemi (Data-Driven)
- âœ… **BiomeDefinition.cs** - ScriptableObject tabanlÄ± biyom tanÄ±mlarÄ±
  - Temperature & Humidity aralÄ±klarÄ±
  - Terrain height multiplier
  - Smoothness ve transition ayarlarÄ±
  - Tree/rock prefab listesi ve density
  - Special ore spawn kurallarÄ±
- âœ… **BiomeManager.cs** - Biyom seÃ§imi ve yÃ¶netimi
  - Cache sistemi (16x16 grid bazlÄ±)
  - Climate matching (sÄ±caklÄ±k/nem)
  - Biome blending (yumuÅŸak geÃ§iÅŸler)

### âœ… DoÄŸa Objeleri (GPU Instancing)
- âœ… **VegetationSpawner.cs** - AÄŸaÃ§ ve kaya spawn sistemi
  - GPU Instancing - Binlerce aÄŸaÃ§/kaya performanslÄ± render
  - Object Pooling - Bellek optimizasyonu
  - Density-based spawning - Biyom bazlÄ± yoÄŸunluk
  - Minimum distance kontrolÃ¼

### âœ… Su Sistemi
- âœ… **OceanPlane.cs** - Sonsuz okyanus (Y=0 seviyesi)
  - Infinite plane generation
  - Transparent material
  - Shader Graph entegrasyonu
- âœ… **WaterSim.compute** - Voxel su simÃ¼lasyonu (Minecraft benzeri matematiksel su mekaniÄŸi)
  - Su seviyesi yÃ¶netimi (0-7 arasÄ±, 8=kaynak su)
  - AÅŸaÄŸÄ± akÄ±ÅŸ (Gravity - en yÃ¼ksek Ã¶ncelik)
  - Yan tarafa akÄ±ÅŸ (4 yÃ¶n: kuzey, gÃ¼ney, doÄŸu, batÄ±)
  - YayÄ±lma mekaniÄŸi (su seviyesi dengeleme)
  - Ã–ncelik sistemi (AÅŸaÄŸÄ± > Yan > YayÄ±lma)
  - BoÅŸluk kontrolÃ¼ (su sadece boÅŸ voxel'lere akar)
  - Kaynak su (sonsuz su kaynaÄŸÄ±)
- âœ… **WaterSimulator.cs** - Voxel su simÃ¼lasyonu yÃ¶neticisi
  - Chunk bazlÄ± cache
  - GPU Ã¼zerinde hesaplama
  - GetWaterLevel(), AddWater(), RemoveWater(), AddWaterSource() metodlarÄ±

### âœ… Voxel AÄŸaÃ§ Sistemi
- âœ… **VoxelTreeGenerator.cs** - ProsedÃ¼rel aÄŸaÃ§ oluÅŸturma
  - L-System/Fractal Tree algoritmasÄ±
  - Job System ile paralel generation
  - Voxel bloklardan aÄŸaÃ§ oluÅŸturma
  - AÄŸaÃ§ kaldÄ±rma (RemoveTreeAt)
- âœ… **TreeGrowthSystem.cs** - AÅŸamalÄ± bÃ¼yÃ¼me yÃ¶netimi
  - 5 bÃ¼yÃ¼me aÅŸamasÄ± (Fidan, KÃ¼Ã§Ã¼k, Orta, BÃ¼yÃ¼k, Olgun)
  - Coroutine bazlÄ± zaman yÃ¶netimi
  - BÃ¼yÃ¼yen aÄŸaÃ§lar cache'i
  - Toplam ~32 dakika bÃ¼yÃ¼me sÃ¼resi

### âœ… Voxel Maden Sistemi
- âœ… **OreSpawner.cs** - Voxel maden blok spawn
  - TerrainDensity.compute entegrasyonu
  - Job System ile paralel spawn
  - Spawn edilmiÅŸ madenler cache'i
  - YÃ¼kseklik bazlÄ± maden daÄŸÄ±lÄ±mÄ±
- âœ… **OreDefinition.cs** - Maden tanÄ±mlarÄ± (ScriptableObject)
  - minDepth, maxDepth (derinlik aralÄ±ÄŸÄ±)
  - spawnChance (spawn ÅŸansÄ±)
  - itemDropId (kÄ±rÄ±ldÄ±ÄŸÄ±nda dÃ¼ÅŸecek item)

### âœ… Ä°nÅŸa Sistemi
- âœ… **GridPlacementSystem.cs** - Grid tabanlÄ± yerleÅŸtirme
  - 1 metre grid sistemi
  - Grid pozisyon cache'i
  - Smooth voxel dÃ¼nyada tutarlÄ± inÅŸa
- âœ… **BlueprintSystem.cs** - YapÄ± kaydetme/kopyalama
  - Blueprint kaydetme (JSON)
  - Blueprint yÃ¼kleme ve yerleÅŸtirme
  - Blueprint cache sistemi
- âœ… **SculptingSystem.cs** - Blok yontma
  - Blok ÅŸekil verme
  - Template kaydetme
  - Template uygulama
  - YontulmuÅŸ ÅŸekiller cache'i

### âœ… Variant Blok Sistemi
- âœ… **VariantMeshGenerator.cs** - 740 variant algoritma tabanlÄ± mesh generation
  - Dik kesimler (6 yÃ¶n, 5 seviye: 1/5, 2/5, 3/5, 4/5, 5/5)
  - Ã‡apraz kesimler (diagonal cuts)
  - YuvarlanmÄ±ÅŸ kÃ¶ÅŸeler (rounded corners)
  - Ramp ÅŸekilleri (ramp shapes)
  - Merdiven benzeri ÅŸekiller (stairs-like)
  - Ä°Ã§/DÄ±ÅŸ kÃ¶ÅŸeler (inner/outer corners)
  - Ã–zel ÅŸekiller (trapezoids, pyramids, hemispheres)
  - Mesh cache sistemi (O(1) lookup, pre-generated meshes)

### âœ… ChunkManager GÃ¼ncellemeleri (FAZ 3)
- âœ… **AddDensityAtPoint()** - Blok yerleÅŸtirme iÃ§in
- âœ… **RemoveDensityAtPoint()** - Blok kÄ±rma iÃ§in
- âœ… **SetBlockType() / GetBlockType()** - Blok tipi yÃ¶netimi
- âœ… **OnChunkGenerated event** - OreSpawner, VoxelTreeGenerator iÃ§in
- âœ… **GetWorldSeed()** - Deterministik rastgelelik iÃ§in
- âœ… **Block type cache sistemi** - Dictionary<Vector3Int, string>

### âœ… MaÄŸara Sistemi
- âœ… **3D Noise ile maÄŸara oluÅŸturma** - TerrainDensity.compute iÃ§inde
  - Yer altÄ± boÅŸluklarÄ±
  - Cave generation algoritmasÄ±

### ğŸ› ï¸ KullanÄ±lan Teknolojiler (Faz 3)
- **GPU Instancing** - Unity yerleÅŸik, binlerce obje render (VegetationSpawner - eski sistem)
- **Object Pooling** - Performans optimizasyonu pattern'i
- **Shader Graph** - Okyanus materyali
- **FastNoiseLite** - Biyom ve maÄŸara gÃ¼rÃ¼ltÃ¼sÃ¼
- **Unity Job System + Burst Compiler** - Paralel aÄŸaÃ§ generation (GenerateTreeJob), paralel maden spawn (SpawnOresInChunkJob)
- **Unity Coroutines** - AÅŸamalÄ± aÄŸaÃ§ bÃ¼yÃ¼me (TreeGrowthSystem)
- **Unity Mesh API** - Variant mesh generation (VariantMeshGenerator - 740 variant)
- **Unity Compute Shaders** - Voxel su simÃ¼lasyonu (WaterSim.compute - Minecraft benzeri matematiksel su mekaniÄŸi)
- **Unity JSON** - Blueprint kaydetme/yÃ¼kleme (BlueprintSystem)

---

## ğŸ® FAZ 4: OYUN MEKANÄ°KLERÄ° (GAMEPLAY SYSTEMS)

### âœ… Item Sistemi (Data-Driven)
- âœ… **ItemDefinition.cs** - ScriptableObject tabanlÄ± eÅŸya tanÄ±mlarÄ±
  - Item ID, Display Name, Description
  - Item Type (Material, Weapon, Tool, Structure, vb.)
  - Max Stack, Weight, Value
  - Ritual energy color ve intensity
  - Consumable Ã¶zellikleri
- âœ… **ItemDatabase.cs** - EÅŸya lookup sistemi
  - Dictionary cache (O(1) lookup)
  - Otomatik cache build
- âœ… **PhysicalItem.cs** - Fiziksel item objesi
  - World prefab spawn
  - Auto despawn sistemi
- âœ… **ItemSpawner.cs** - Item spawn yÃ¶netimi

### âœ… RitÃ¼el Sistemi (Batarya Sistemi)
- âœ… **RitualRecipe.cs** - ScriptableObject tabanlÄ± ritÃ¼el tarifleri
  - Blok pattern tanÄ±mlarÄ±
  - Enerji rengi ve yoÄŸunluÄŸu
- âœ… **RitualManager.cs** - RitÃ¼el yÃ¶netimi
  - Batarya kurulum kontrolÃ¼
  - Pattern matching
  - Activation sistemi
- âœ… **RitualInputHandler.cs** - Blok yerleÅŸtirme kontrolÃ¼
- âœ… **GhostRecipeManager.cs** - GÃ¶rsel rehber sistemi (FAZ 8)
  - Blok yerleÅŸtirme Ã§izgileri
  - Hologram gÃ¶sterimi

### âœ… Klan ve BÃ¶lge Sistemi
- âœ… **TerritoryManager.cs** - BÃ¶lge yÃ¶netimi
  - Flood-Fill algoritmasÄ± (2D/3D)
  - Boundary calculation
  - Territory data yÃ¶netimi
- âœ… **ClanFence.cs** - Klan Ã§iti sistemi
- âœ… **TerritoryData.cs** - BÃ¶lge veri modeli
- âœ… **Boundary particles** - SÄ±nÄ±r gÃ¶rselleÅŸtirme

### âœ… Ekonomi ve Kontrat Sistemi
- âœ… **ContractManager.cs** - Kontrat yÃ¶netimi
  - Contract request sistemi
  - Contract terms tanÄ±mlama
  - Contract signing
- âœ… **ContractData.cs** - Kontrat veri modeli
- âœ… **Contract board** - Fiziksel kontrat panosu
- âœ… **Contract UI** - Kontrat menÃ¼ sistemi (FAZ 6)

### âœ… Blok Åekillendirme Sistemi (Chisel Tool)
- âœ… **ItemDefinition.cs** - Chisel Ã¶zellikleri eklendi
  - `isChisel` - Chisel aleti mi?
  - `chiselDefinition` - ChiselDefinition ScriptableObject referansÄ±
  - `chiselLevel` - Alet seviyesi (1: Temel, 2: GeliÅŸmiÅŸ, 3: Usta)
- âœ… **IEquippable.cs** - Alet interface'i
  - `OnEquip()`, `OnUnequip()`, `OnUse()` metodlarÄ±
  - NetworkMining entegrasyonu iÃ§in
- âœ… **ChiselTool.cs** - Ana chisel sistemi
  - 3 kesim modu (KÃ¼p, Yuvarlak, Ã‡apraz)
  - Ä°ki nokta seÃ§imi sistemi (baÅŸlangÄ±Ã§/bitiÅŸ)
  - GÃ¶rsel Ã¶nizleme (Ã§izgiler, marker'lar)
  - 9 slot ÅŸekil kayÄ±t sistemi (1-9 tuÅŸlarÄ±)
  - NetworkMining entegrasyonu (IEquippable)
  - VariantMeshGenerator entegrasyonu
  - ChunkManager entegrasyonu
- âœ… **ChiselRaycast.cs** - Voxel terrain uyumlu raycast
  - ChunkManager entegrasyonu
  - Raycast cache optimizasyonu
  - Grid Ã§izgileri (enine, boyuna, Ã§apraz)
  - Ä°ki nokta seÃ§imi (baÅŸlangÄ±Ã§/bitiÅŸ)
- âœ… **BlockSelectionVisualizer.cs** - SeÃ§im gÃ¶rselleÅŸtirme
  - Marker'lar (baÅŸlangÄ±Ã§/bitiÅŸ noktalarÄ±)
  - Ã‡izgiler (kesim Ã§izgisi, grid Ã§izgileri)
  - Ã–nizleme mesh (kesim Ã¶ncesi gÃ¶rsel geri bildirim)
- âœ… **BlockCuttingSystem.cs** - Kesim mekaniÄŸi
  - Mod bazlÄ± kesim algoritmasÄ± (KÃ¼p, Yuvarlak, Ã‡apraz)
  - VariantMeshGenerator entegrasyonu
  - Chunk regeneration (kesim sonrasÄ± mesh gÃ¼ncelleme)
  - Mesh pooling (performans optimizasyonu)
- âœ… **ShapeApplicationSystem.cs** - Åekil kayÄ±t/uygulama
  - 9 slot ÅŸekil kayÄ±t sistemi (K tuÅŸu ile kaydet, 1-9 ile uygula)
  - JSON kayÄ±t sistemi (persistent storage)
  - Åekil cache'i (O(1) lookup)
  - SaÄŸ tÄ±k ile ÅŸekil uygulama
- âœ… **ChiselDefinition.cs** - Chisel tanÄ±mlarÄ± (ScriptableObject)
  - Alet seviyesi (1-3)
  - Malzeme tipi (Wood, Stone, Metal)
  - Kesim hassasiyeti
  - Kesim hÄ±zÄ±
- âœ… **CutMode.cs** - Kesim modu enum'larÄ± ve data yapÄ±larÄ±
  - `CutMode` enum (Cube, Rounded, Diagonal)
  - `CutData` struct (kesim verileri)
  - `ShapeData` struct (kaydedilmiÅŸ ÅŸekil verileri)

### ğŸ› ï¸ KullanÄ±lan Teknolojiler (Faz 4)
- **ScriptableObject** - Unity yerleÅŸik, data-driven design
- **Flood-Fill Algorithm** - Custom, bÃ¶lge hesaplama
- **SQLite** - Kontrat ve bÃ¶lge verileri
- **FishNet** - Network senkronizasyonu
- **Unity Raycast API** - Blok seÃ§imi (ChiselRaycast)
- **Unity Mesh API** - Variant mesh generation (BlockCuttingSystem)
- **Unity JSON** - Åekil kayÄ±t sistemi (ShapeApplicationSystem)

---

## ğŸ¤– FAZ 5: YAPAY ZEKA, SAVAÅ VE FELAKETLER

### âœ… AI Sistemi
- âœ… **ChunkNavMeshBaker.cs** - Dinamik NavMesh piÅŸirme
  - Chunk bazlÄ± baking
  - Runtime rebake (terrain deÄŸiÅŸikliÄŸinde)
  - Async baking (frame kilitleme Ã¶nleme)
  - Voxel terrain uyumu (ChunkManager entegrasyonu)
- âœ… **MobAI.cs** - Normal mob AI (State Machine)
  - Idle, Chase, Attack, Flee state'leri
  - Oyuncu arama cache'i (performans)
  - Detection range ve attack range
  - Voxel terrain uyumu (FindNearestPlayer optimizasyonu)
- âœ… **BossAI.cs** - Boss AI (Panda BT entegrasyonu)
  - Behavior Tree ile karmaÅŸÄ±k zeka
  - Faz sistemi (phase transitions)
  - Ã–zel yetenekler
  - Voxel terrain uyumu (FindNearestPlayer optimizasyonu)
- âœ… **MobSpawner.cs** - Mob spawn yÃ¶netimi
  - Voxel terrain uyumu (GetGroundPositionOnVoxelTerrain)
- âœ… **BossSpawner.cs** - Boss spawn yÃ¶netimi
- âœ… **MobIdentity.cs** - Mob kimliÄŸi (FAZ 5)
- âœ… **BossIdentity.cs** - Boss kimliÄŸi (FAZ 5)
- âœ… **MobDatabase.cs** - Mob veritabanÄ± (O(1) lookup - FAZ 5)
- âœ… **BossDatabase.cs** - Boss veritabanÄ± (O(1) lookup - FAZ 5)

### âœ… SavaÅŸ Sistemi
- âœ… **IDamageable.cs** - Hasar arayÃ¼zÃ¼
- âœ… **HealthComponent.cs** - Can sistemi
- âœ… **ArmorComponent.cs** - ZÄ±rh sistemi
- âœ… **Critical hit system** - Kritik vuruÅŸ hesaplama

### âœ… Boss Sistemi
- âœ… **BossDefinition.cs** - ScriptableObject tabanlÄ± boss tanÄ±mlarÄ±
- âœ… **BossIdentity.cs** - Boss kimliÄŸi ve Ã¶zellikleri
- âœ… **Arena transformation** - Dinamik arena oluÅŸturma
- âœ… **Weak point system** - ZayÄ±f nokta sistemi (3x hasar)

### âœ… Felaket Sistemi
- âœ… **DisasterDefinition.cs** - ScriptableObject tabanlÄ± felaket tanÄ±mlarÄ±
- âœ… **DisasterManager.cs** - Felaket yÃ¶netimi
  - Disaster types (CREATURE, NATURAL, MINI)
  - Disaster phases (EXPLORATION, ASSAULT, RAGE, DESPERATION)
  - Phase transitions ve mesajlar
  - BossBar/ActionBar gÃ¶sterimi
  - Dinamik zorluk sistemi
- âœ… **Disaster types:**
  - Catastrophic Titan (30 blok boyutunda)
  - Solar Flare (doÄŸal felaket)
  - Earthquake (doÄŸal felaket)

### âœ… Tuzak Sistemi
- âœ… **TrapDefinition.cs** - ScriptableObject tabanlÄ± tuzak tanÄ±mlarÄ±
- âœ… **TrapCore.cs** - Tuzak Ã§ekirdeÄŸi
- âœ… **TrapManager.cs** - Tuzak yÃ¶netimi
- âœ… **Fuel system** - YakÄ±t sistemi (25 farklÄ± tuzak tipi)

### ğŸ› ï¸ KullanÄ±lan Teknolojiler (Faz 5)
- **Panda BT** - Behavior Tree (Boss AI)
- **NavMesh Components** - Runtime NavMesh baking
- **State Machine** - Custom, normal mob AI
- **Unity Physics** - Hasar hesaplama

---

## ğŸ¨ FAZ 6: ARAYÃœZ (UI), ETKÄ°LEÅÄ°M VE CÄ°LA

### âœ… EtkileÅŸim Sistemi
- âœ… **IInteractable.cs** - EtkileÅŸim arayÃ¼zÃ¼
  - GetInteractText, GetInteractRange
  - Interact, CanInteract metodlarÄ±
- âœ… **InteractionController.cs** - Raycast kontrolÃ¼
  - Raycast caching (performans)
  - Interval-based raycast (her frame deÄŸil)
  - UI prompt gÃ¶sterimi
  - Voxel terrain uyumu (ChunkManager entegrasyonu)
- âœ… **PhysicalItem.cs** - Fiziksel item etkileÅŸimi

### âœ… HUD (Heads-Up Display)
- âœ… **HUDManager.cs** - Can barÄ±, bÃ¶lge ismi
  - TextMeshPro entegrasyonu
  - DoTween animasyonlarÄ±
  - Value caching (gereksiz gÃ¼ncelleme Ã¶nleme)
  - Voxel terrain uyumu (CheckRegionNotification - TerritoryManager entegrasyonu)

### âœ… KarmaÅŸÄ±k MenÃ¼ler
- âœ… **ContractUI.cs** - Kontrat menÃ¼sÃ¼
  - Async DB loading (performans)
  - UI element pooling
- âœ… **ClanManagementUI.cs** - Klan yÃ¶netim menÃ¼sÃ¼
  - Territory gÃ¶rselleÅŸtirme
  - Member listesi

### âœ… GÃ¶rsel/Ä°ÅŸitsel Geri Bildirim
- âœ… **AudioManager.cs** - Ses yÃ¶netimi
  - AudioSource pooling
  - Network senkronizasyonu (ObserversRpc)
  - Voxel terrain uyumu (3D spatial audio - chunk bazlÄ± optimizasyon)
- âœ… **CameraShake.cs** - Kamera sarsÄ±ntÄ±sÄ±
  - Hasar, patlama efektleri

### ğŸ› ï¸ KullanÄ±lan Teknolojiler (Faz 6)
- **TextMeshPro** - Unity yerleÅŸik, UI metinleri
- **DoTween** - Asset Store (Free), UI animasyonlarÄ±
- **Unity Canvas** - Unity yerleÅŸik, UI sistemi
- **Unity Audio** - Unity yerleÅŸik, ses sistemi

---

## âš”ï¸ FAZ 7: GÃœÃ‡ SÄ°STEMÄ°, BÄ°NEKLER VE SAVAÅ MAKÄ°NELERÄ°

### âœ… GÃ¼Ã§ Sistemi (SGP - Stratocraft Global Power)
- âœ… **PlayerPowerProfile.cs** - Oyuncu gÃ¼Ã§ profili
  - Gear Power (eÅŸya gÃ¼cÃ¼)
  - Training Power (ustalÄ±k gÃ¼cÃ¼)
  - Buff Power (aktif bufflar)
  - Ritual Power (ritÃ¼el gÃ¼cÃ¼)
  - Total Combat Power (CP)
  - Total Progression Power (PP)
  - Total SGP
  - Hysteresis system (exploit Ã¶nleme)
- âœ… **ClanPowerProfile.cs** - Klan gÃ¼Ã§ profili
  - Member Power Sum
  - Structure Power
  - Ritual Block Power
  - Ritual Resource Power
  - Total Clan Power
  - Clan Level (logaritmik, maksimum 15)
- âœ… **StratocraftPowerSystem.cs** - GÃ¼Ã§ hesaplama sistemi
  - Cache sistemi (thread-safe)
  - Async operations
  - Offline player cache (24 saat)
  - Lock objects (race condition Ã¶nleme)
- âœ… **PowerSystemConfig.cs** - GÃ¼Ã§ sistemi config

### âœ… Binek Sistemi
- âœ… **RideableMobDefinition.cs** - ScriptableObject tabanlÄ± binek tanÄ±mlarÄ±
- âœ… **RideableMob.cs** - Binek mob
  - Taming system (eÄŸitme)
  - Gender system (cinsiyet)
  - Following behavior (takip)
- âœ… **MobInputController.cs** - WASD kontrolÃ¼
  - FishNet Ownership ile kontrol

### âœ… KuÅŸatma Sistemi
- âœ… **SiegeBeacon.cs** - KuÅŸatma beacon'Ä±
  - Warmup countdown (5 dakika)
  - Two-sided war (iki taraflÄ± savaÅŸ)
- âœ… **SiegeManager.cs** - SavaÅŸ yÃ¶netimi
  - Protection removal (koruma kaldÄ±rma)
  - Offline protection kontrolÃ¼
- âœ… **SiegeWeaponManager.cs** - KuÅŸatma silahlarÄ± (FAZ 8)
  - Balista (30 mermi)
  - MancÄ±nÄ±k (alan hasarÄ±)

### âœ… YapÄ± BufflarÄ±
- âœ… **StructureEffectDefinition.cs** - ScriptableObject tabanlÄ± yapÄ± efekt tanÄ±mlarÄ±
- âœ… **StructureEffectManager.cs** - Efekt yÃ¶netimi
  - Area of effect (etki alanÄ±)
  - Periodic effects (periyodik efektler)
  - Buff/Debuff/Utility/Passive efektler

### âœ… Offline Koruma
- âœ… **OfflineProtectionSystem.cs** - Offline koruma
  - Shield fuel system (kalkan yakÄ±tÄ±)
  - Damage reduction (%95)
  - Fuel consumption (yakÄ±t tÃ¼ketimi)

### ğŸ› ï¸ KullanÄ±lan Teknolojiler (Faz 7)
- **FishNet Ownership** - Binek kontrolÃ¼
- **SQLite** - GÃ¼Ã§ profili kayÄ±tlarÄ±
- **Unity Coroutines** - Async iÅŸlemler
- **Cache System** - Custom, performans optimizasyonu

---

## ğŸ› ï¸ FAZ 8: EKSÄ°K SÄ°STEMLER, ADMIN KOMUTLARI VE CONFIG YÃ–NETÄ°MÄ°

### âœ… Eksik Oyun Sistemleri (9 Sistem)

**1. Kervan Sistemi:**
- âœ… **CaravanManager.cs** - Uzak mesafe ticaret
  - Minimum 1000 blok mesafe
  - Minimum 20 stack yÃ¼k
  - Minimum 5000 altÄ±n deÄŸer
  - Mule ile yÃ¼k taÅŸÄ±ma
  - x1.5 deÄŸer bonusu (hedefe ulaÅŸÄ±nca)
  - Unity NavMesh pathfinding
  - Voxel terrain uyumu (ChunkManager entegrasyonu, chunk bazlÄ± pathfinding kontrolÃ¼)
  - Database entegrasyonu (caravans tablosu)

**2. AraÅŸtÄ±rma Sistemi:**
- âœ… **ResearchManager.cs** - Tarif KitabÄ± paylaÅŸÄ±mÄ±
  - Lectern + Crafting Table = AraÅŸtÄ±rma MasasÄ±
  - 10 blok yarÄ±Ã§ap paylaÅŸÄ±m
  - Envanter + AraÅŸtÄ±rma MasasÄ± kontrolÃ¼
  - Unity Physics OverlapSphere
  - Voxel terrain uyumu (ChunkManager entegrasyonu, chunk bazlÄ± research table cache)
  - Database entegrasyonu (researches tablosu)

**3. Ãœreme Sistemi:**
- âœ… **BreedingManager.cs** - Ã‡iftleÅŸtirme tesisleri
  - Breeding Core ile Ã§iftleÅŸtirme
  - Gender Scanner ile cinsiyet kontrolÃ¼
  - Memeli vs Yumurtlayan canlÄ±lar
  - Seviyeli tesisler (1-5 seviye)
  - Unity Coroutines ile async sÃ¼reÃ§
  - Voxel terrain uyumu (ChunkManager entegrasyonu, chunk bazlÄ± breeding core cache)
  - Database entegrasyonu (breedings tablosu)

**4. Market Sistemi:**
- âœ… **ShopManager.cs** - SandÄ±k + Tabela market
  - GUI menÃ¼ ile alÄ±ÅŸveriÅŸ
  - Teklif sistemi (alternatif Ã¶deme)
  - %5 vergi (koruma bÃ¶lgesinde)
  - TextMeshPro + DoTween UI
  - Voxel terrain uyumu (StructurePlacer entegrasyonu, chunk bazlÄ± shop cache)
  - Database entegrasyonu (shops ve shop_items tablolarÄ±)

**5. GÃ¶rev Sistemi:**
- âœ… **MissionManager.cs** - 8 gÃ¶rev tipi, 4 zorluk seviyesi
  - Kill Mob, Collect Item, Visit Location, vb.
  - Otomatik ilerleme takibi
  - Reward sistemi
  - Voxel terrain uyumu (ChunkManager entegrasyonu, voxel terrain Ã¼zerinde gÃ¶rev takibi)
  - Database entegrasyonu (missions tablosu)
- âœ… **MissionDatabase.cs** - MissionDefinition lookup (O(1) - FAZ 8)
  - Dictionary cache sistemi
  - Zorluk ve tip bazlÄ± filtreleme

**6. Supply Drop Sistemi:**
- âœ… **SupplyDropManager.cs** - GÃ¶kyÃ¼zÃ¼nden dÃ¼ÅŸen hazine
  - Ä°lk bulan alÄ±r
  - DoTween animasyonu
  - Network senkronizasyonu
  - Voxel terrain uyumu (ChunkManager entegrasyonu, voxel terrain Ã¼zerinde spawn)
  - Database entegrasyonu (supply_drops tablosu)

**7. KuÅŸatma SilahlarÄ±:**
- âœ… **SiegeWeaponManager.cs** - Balista ve MancÄ±nÄ±k
  - Balista: 30 mermi, uzun menzil
  - MancÄ±nÄ±k: Alan hasarÄ±, kÄ±sa menzil
  - Projectile physics
  - Voxel terrain uyumu (ChunkManager entegrasyonu, chunk bazlÄ± ateÅŸ kontrolÃ¼)
  - TerrainEditor entegrasyonu (voxel terrain hasarÄ±)

**8. Hayalet Tarif Sistemi:**
- âœ… **GhostRecipeManager.cs** - GÃ¶rsel rehber
  - Blok yerleÅŸtirme Ã§izgileri
  - Hologram gÃ¶sterimi
  - Pattern matching
  - Voxel terrain uyumu (ChunkManager entegrasyonu, chunk bazlÄ± gÃ¶rÃ¼nÃ¼rlÃ¼k kontrolÃ¼)
  - LineRenderer ile voxel terrain Ã¼zerinde blok rehberi

**9. Ä°ttifak Sistemi:**
- âœ… **AllianceManager.cs** - Klanlar arasÄ± anlaÅŸmalar
  - RitÃ¼el ile ittifak kurma
  - Ä°hlal cezasÄ± (%20 bakiye + Hain etiketi)
  - SQLite kayÄ±t sistemi
  - Voxel terrain uyumu (ChunkManager entegrasyonu, chunk bazlÄ± ritÃ¼el kontrolÃ¼)
  - Database entegrasyonu (alliances tablosu)

### âœ… Admin Komut Sistemi
- âœ… **AdminCommandHandler.cs** - 20+ admin komutu
  - give, spawn, disaster, config, vb. kategoriler
  - Permission system (yetki kontrolÃ¼)
  - Voxel terrain uyumu (ChunkManager entegrasyonu, chunk bazlÄ± komut kontrolÃ¼)
- âœ… **AdminTabCompleter.cs** - Tab completion
  - Komut ve parametre tamamlama
  - Voxel terrain uyumu (ChunkManager entegrasyonu, aktif chunk bazlÄ± oyuncu listesi)

### âœ… Config YÃ¶netim Sistemi
- âœ… **ConfigManager.cs** - Merkezi config yÃ¶netimi
  - ScriptableObject config'ler (8 config dosyasÄ±)
  - Runtime config editor (Editor Window)
  - Hot reload desteÄŸi
  - Validation kontrolÃ¼
- âœ… **Config dosyalarÄ±:**
  - GameBalanceConfig
  - DisasterConfig
  - TerritoryConfig
  - ClanProtectionConfig
  - SiegeConfig
  - BossConfig
  - MobConfig
  - EconomyConfig

### ğŸ› ï¸ KullanÄ±lan Teknolojiler (TÃ¼m Fazlar)

**FAZ 1-2: AltyapÄ± ve DÃ¼nya OluÅŸumu**
- **Unity Compute Shaders** - GPU'da density hesaplama (TerrainDensity.compute)
- **Unity Job System + Burst Compiler** - CPU fallback ve paralel iÅŸlemler (CalculateDensityJob, BuildMeshJob)
- **Unity SystemInfo API** - GPU desteÄŸi kontrolÃ¼ ve fallback sistemi (SystemInfo.supportsComputeShaders)
- **Unity Coroutines** - Asenkron chunk yÃ¼kleme (UI donmasÄ±nÄ± Ã¶nleme)
- **Unity Mesh API** - Chunk mesh oluÅŸturma (MeshBuilder.cs)

**FAZ 3: DoÄŸa, Su ve Biyomlar + Voxel AÄŸaÃ§/Maden/Ä°nÅŸa Sistemleri**
- **Unity Job System + Burst Compiler** - Paralel aÄŸaÃ§ generation (GenerateTreeJob), paralel maden spawn (SpawnOresInChunkJob)
- **Unity Coroutines** - AÅŸamalÄ± aÄŸaÃ§ bÃ¼yÃ¼me (TreeGrowthSystem)
- **Unity Mesh API** - Variant mesh generation (VariantMeshGenerator - 740 variant)
- **Unity Compute Shaders** - Voxel su simÃ¼lasyonu (WaterSim.compute - Minecraft benzeri matematiksel su mekaniÄŸi)
- **Unity JSON** - Blueprint kaydetme/yÃ¼kleme (BlueprintSystem)

**FAZ 4: Oyun Mekanikleri**
- **Unity Job System + Burst Compiler** - Territory flood-fill optimizasyonu (FloodFillJob)

**FAZ 8: Eksik Sistemler, Admin KomutlarÄ± ve Config YÃ¶netimi**
- **Unity NavMesh** - Kervan pathfinding (CaravanManager.cs)
- **Unity Physics** - OverlapSphere (ResearchManager.cs), Projectile physics (SiegeWeaponManager.cs)
- **DoTween** - Supply Drop animasyonu (SupplyDropManager.cs)
- **Unity Editor API** - Config editor (ConfigEditor.cs)
- **Unity Input System** - Tab completion (AdminTabCompleter.cs)
- **Unity LineRenderer** - Hayalet tarif Ã§izgileri (GhostRecipeManager.cs)
- **Unity Event System** - GÃ¶rev ilerleme takibi (MissionManager.cs)
- **SQLite** - TÃ¼m Faz 8 sistemleri iÃ§in database kayÄ±tlarÄ± (DatabaseManager.cs)
- **ChunkManager** - Voxel terrain entegrasyonu (tÃ¼m Faz 8 sistemleri)

### ğŸ¯ GeliÅŸtirme SÄ±rasÄ± (DetaylÄ±)

**Faz 1-2: AltyapÄ± ve DÃ¼nya OluÅŸumu (2-3 hafta)**
1. âœ… ServiceLocator, GameEntry, NetworkBootstrap kurulumu
2. âœ… DatabaseManager (SQLite entegrasyonu)
3. âœ… Scrawk entegrasyonu ve TerrainDensity.compute modifikasyonu
4. âœ… ChunkManager.cs implementasyonu (Priority Queue, Mesh Pooling, LOD, Disk Caching)
5. âœ… GPU Fallback Sistemi - SystemInfo.supportsComputeShaders kontrolÃ¼, CPU fallback (CalculateDensityJob, BuildMeshJob)
6. âœ… MarchingCubesGPU.cs (LOD desteÄŸi, Density Data caching)
7. âœ… TerrainMaterialManager.cs ve TerrainShader.shader (Triplanar texturing)
8. âœ… TerrainPoint.cs ve TriplanarTexture.compute
9. âœ… GameTimeManager.cs (GÃ¼n/gece dÃ¶ngÃ¼sÃ¼, dinamik Ä±ÅŸÄ±klandÄ±rma)
10. âœ… NetworkMining.cs ve SyncWorld.cs (Server-authoritative kazÄ±)

**Faz 3: DoÄŸa, Su ve Biyomlar (2-3 hafta)**
1. âœ… BiomeDefinition.cs ve BiomeManager.cs (Data-driven biyom sistemi)
2. âœ… VegetationSpawner.cs (GPU Instancing ile aÄŸaÃ§/kaya spawn - eski sistem, VoxelTreeGenerator ile deÄŸiÅŸtirilebilir)
3. âœ… VoxelTreeGenerator.cs (ProsedÃ¼rel aÄŸaÃ§ oluÅŸturma - L-System/Fractal Tree, Job System ile paralel generation)
4. âœ… TreeGrowthSystem.cs (AÅŸamalÄ± bÃ¼yÃ¼me: Fidan â†’ KÃ¼Ã§Ã¼k â†’ Orta â†’ BÃ¼yÃ¼k â†’ Olgun, 5 aÅŸama, ~32 dakika)
5. âœ… OreSpawner.cs (Voxel maden spawn - TerrainDensity.compute entegrasyonu, Job System ile paralel spawn, yÃ¼kseklik bazlÄ± daÄŸÄ±lÄ±m)
6. âœ… OreDefinition.cs (Maden tanÄ±mlarÄ± - ScriptableObject, minDepth, maxDepth, spawnChance, itemDropId)
7. âœ… GridPlacementSystem.cs (Grid tabanlÄ± yerleÅŸtirme - smooth voxel dÃ¼nyada tutarlÄ± inÅŸa, 1 metre grid)
8. âœ… BlueprintSystem.cs (YapÄ± kaydetme/kopyalama - JSON dosya kaydetme/yÃ¼kleme, blueprint cache)
9. âœ… SculptingSystem.cs (Blok yontma ve ÅŸekil verme - template kaydetme/uygulama, yontulmuÅŸ ÅŸekiller cache)
10. âœ… VariantMeshGenerator.cs (740 variant algoritma tabanlÄ± mesh generation - dik kesimler, Ã§apraz kesimler, yuvarlanmÄ±ÅŸ kÃ¶ÅŸeler, ramp, merdiven, kÃ¶ÅŸe ÅŸekilleri, Ã¶zel ÅŸekiller, mesh cache sistemi)
11. âœ… OceanPlane.cs (Sonsuz okyanus, Y=0 seviyesi)
12. âœ… WaterSim.compute ve WaterSimulator.cs (Minecraft tarzÄ± matematiksel voxel su mekaniÄŸi - aÅŸaÄŸÄ± akÄ±ÅŸ, yan tarafa akÄ±ÅŸ, yayÄ±lma, Ã¶ncelik sistemi, su seviyesi 0-7, kaynak su)
13. âœ… MaÄŸara sistemi (3D Noise ile yer altÄ± boÅŸluklarÄ±)
14. âœ… ChunkManager.cs gÃ¼ncellemeleri (AddDensityAtPoint, RemoveDensityAtPoint, SetBlockType, GetBlockType, GetWorldSeed, OnChunkGenerated event)

**Faz 4: Oyun Mekanikleri (3-4 hafta)**
1. âœ… ItemDefinition.cs ve ItemDatabase.cs (Data-driven item sistemi)
2. âœ… PhysicalItem.cs ve ItemSpawner.cs
3. âœ… RitualRecipe.cs ve RitualManager.cs (Batarya sistemi)
4. âœ… RitualInputHandler.cs ve GhostRecipeManager.cs
5. âœ… TerritoryManager.cs (Flood-Fill algoritmasÄ± - Job System + Burst optimizasyonu ile FloodFillJob)
6. âœ… ContractManager.cs ve ContractData.cs
7. âœ… Contract UI sistemi (FAZ 6'da tamamlandÄ±)

**Faz 5: Yapay Zeka, SavaÅŸ ve Felaketler (3-4 hafta)**
1. âœ… ChunkNavMeshBaker.cs (Dinamik NavMesh baking - Voxel terrain uyumlu)
2. âœ… MobAI.cs (State Machine: Idle, Chase, Attack, Flee - Voxel terrain uyumlu)
3. âœ… BossAI.cs (Panda BT entegrasyonu, faz sistemi - Voxel terrain uyumlu)
4. âœ… MobSpawner.cs ve BossSpawner.cs (Voxel terrain zemin bulma)
5. âœ… HealthComponent.cs, ArmorComponent.cs (SavaÅŸ sistemi)
6. âœ… DisasterManager.cs ve DisasterDefinition.cs (Voxel terrain spawn)
7. âœ… TrapManager.cs ve TrapCore.cs (25 farklÄ± tuzak tipi - Voxel terrain uyumlu)
8. âœ… MobIdentity.cs ve BossIdentity.cs (Mob/Boss kimlik)
9. âœ… MobDatabase.cs ve BossDatabase.cs (O(1) lookup cache - FAZ 5)

**Faz 6: ArayÃ¼z (UI), EtkileÅŸim ve Cila (2-3 hafta)**
1. âœ… IInteractable.cs ve InteractionController.cs (Raycast sistemi - Voxel terrain uyumlu)
2. âœ… HUDManager.cs (Can barÄ±, bÃ¶lge ismi - Voxel terrain uyumlu)
3. âœ… ContractUI.cs ve ClanManagementUI.cs (KarmaÅŸÄ±k menÃ¼ler)
4. âœ… AudioManager.cs ve CameraShake.cs (GÃ¶rsel/iÅŸitsel geri bildirim - Voxel terrain uyumlu)

**Faz 7: GÃ¼Ã§ Sistemi, Binekler ve SavaÅŸ Makineleri (3-4 hafta)**
1. âœ… PlayerPowerProfile.cs ve ClanPowerProfile.cs (SGP sistemi)
2. âœ… StratocraftPowerSystem.cs (GÃ¼Ã§ hesaplama, cache sistemi)
3. âœ… RideableMob.cs ve MobInputController.cs (Binek sistemi)
4. âœ… SiegeBeacon.cs ve SiegeManager.cs (KuÅŸatma sistemi)
5. âœ… StructureEffectManager.cs (YapÄ± bufflarÄ±)
6. âœ… OfflineProtectionSystem.cs (Offline koruma)

**Faz 8: Eksik Sistemler, Admin KomutlarÄ± ve Config YÃ¶netimi (4-5 hafta)**
1. âœ… CaravanManager.cs (Kervan sistemi - Voxel terrain uyumlu, NavMesh pathfinding, ChunkManager entegrasyonu)
2. âœ… ResearchManager.cs (AraÅŸtÄ±rma sistemi - Voxel terrain uyumlu, OverlapSphere, ChunkManager entegrasyonu, chunk bazlÄ± research table cache)
3. âœ… BreedingManager.cs (Ãœreme sistemi - Voxel terrain uyumlu, ChunkManager entegrasyonu, chunk bazlÄ± breeding core cache)
4. âœ… ShopManager.cs (Market sistemi - Voxel terrain uyumlu, StructurePlacer entegrasyonu, chunk bazlÄ± shop cache)
5. âœ… MissionManager.cs (GÃ¶rev sistemi - Voxel terrain uyumlu, Event System, ChunkManager entegrasyonu)
6. âœ… MissionDatabase.cs (GÃ¶rev lookup - O(1) lookup, Dictionary cache - FAZ 8)
7. âœ… SupplyDropManager.cs (Supply Drop sistemi - Voxel terrain uyumlu, DoTween animasyonu, ChunkManager entegrasyonu)
8. âœ… SiegeWeaponManager.cs (KuÅŸatma silahlarÄ± - Voxel terrain uyumlu, Physics, ChunkManager entegrasyonu)
9. âœ… GhostRecipeManager.cs (Hayalet tarif sistemi - Voxel terrain uyumlu, LineRenderer, ChunkManager entegrasyonu)
10. âœ… AllianceManager.cs (Ä°ttifak sistemi - SQLite kayÄ±t sistemi, ChunkManager entegrasyonu)
11. âœ… AdminCommandHandler.cs ve AdminTabCompleter.cs (Unity Input System, ChunkManager entegrasyonu)
12. âœ… ConfigManager.cs ve ConfigEditor.cs (Runtime config yÃ¶netimi, Unity Editor API)
13. âœ… DatabaseManager.cs - Faz 8 database metodlarÄ± eklendi (caravans, researches, breedings, shops, missions, supply_drops tablolarÄ±)

### ğŸ“š Referans Kaynaklar

- **Scrawk / Marching Cubes on GPU:** [GitHub](https://github.com/Scrawk/Marching-Cubes-On-The-GPU)
- **FishNet Networking:** [Asset Store](https://assetstore.unity.com/packages/tools/network/fish-net-networking-evolved-207815)
- **Video Serisi:** [How to Make 7 Days to Die in Unity](https://www.youtube.com/watch?v=dTdn3CC64sc)
- **Triplanar Texturing Video:** [How to Make 7 Days to Die in Unity - Triplanar Texturing](https://www.youtube.com/watch?v=OMh4Zlixu7w&t=1516s)

### âš¡ Performans OptimizasyonlarÄ± (TÃ¼m Fazlar)

**GPU ve Compute Shader OptimizasyonlarÄ±:**
- âœ… GPU Compute Shader - TÃ¼m density hesaplamalarÄ± GPU'da (CPU yÃ¼kÃ¼ yok)
- âœ… GPU Fallback Sistemi - GPU yoksa otomatik CPU'ya geÃ§er (SystemInfo.supportsComputeShaders kontrolÃ¼)
- âœ… CPU Fallback Optimizasyonu - Job System + Burst ile %10-50x hÄ±z artÄ±ÅŸÄ± (CalculateDensityJob, BuildMeshJob)
- âœ… TriplanarTexture.compute - GPU'da triplanar texturing
- âœ… Batch Processing - AynÄ± frame'de birden fazla terrain deÄŸiÅŸikliÄŸi

**Chunk Sistemi OptimizasyonlarÄ±:**
- âœ… Priority Queue (SortedDictionary) - YakÄ±n chunklar Ã¶nce yÃ¼klenir
- âœ… Mesh Pooling - Chunk mesh'lerini yeniden kullanma (GC azaltma)
- âœ… LOD System - Uzak chunklar dÃ¼ÅŸÃ¼k detay (performans artÄ±ÅŸÄ±)
- âœ… Disk Caching - Chunk density data'sÄ±nÄ± disk'e kaydetme (hÄ±zlÄ± yÃ¼kleme)
- âœ… Asenkron Generation - Coroutine ile UI donmasÄ±nÄ± Ã¶nleme
- âœ… Chunk State Management - Loading, Generating, Ready state'leri

**Cache Sistemleri:**
- âœ… Material Caching - Chunk materyalleri cache'lenir
- âœ… Biome Cache - 16x16 grid bazlÄ± biyom cache'i
- âœ… Item Database Cache - Dictionary ile O(1) item lookup
- âœ… Player Power Profile Cache - 5 saniye cache sÃ¼resi
- âœ… Clan Power Profile Cache - 5 dakika cache sÃ¼resi
- âœ… Offline Player Cache - 24 saat geÃ§erli
- âœ… Oyuncu Arama Cache'i - Mob AI performansÄ± (her 2 saniyede bir)
- âœ… Raycast Cache - InteractionController'da gereksiz raycast Ã¶nleme
- âœ… UI Value Cache - HUDManager'da gereksiz gÃ¼ncelleme Ã¶nleme

**Network OptimizasyonlarÄ±:**
- âœ… Server-authoritative - TÃ¼m kritik iÅŸlemler sunucuda
- âœ… ObserversRpc - Sadece gÃ¶rÃ¼nen oyunculara gÃ¶nderim
- âœ… Cooldown sistemleri - Spam Ã¶nleme (mining, dig, vb.)
- âœ… Batch network updates - AynÄ± frame'de birden fazla update

**AI OptimizasyonlarÄ±:**
- âœ… State Machine - Basit mob AI (if-else yerine)
- âœ… Behavior Tree - KarmaÅŸÄ±k boss AI (Panda BT)
- âœ… Chunk bazlÄ± NavMesh - Sadece aktif chunklarda bake
- âœ… Async NavMesh baking - Frame kilitleme Ã¶nleme

**UI OptimizasyonlarÄ±:**
- âœ… UI Element Pooling - MenÃ¼ elementlerini yeniden kullanma
- âœ… Async DB Loading - VeritabanÄ± sorgularÄ± async
- âœ… Interval-based Raycast - Her frame deÄŸil, belirli aralÄ±klarla
- âœ… DoTween animasyonlarÄ± - PerformanslÄ± UI animasyonlarÄ±

**CPU ve Multithreading OptimizasyonlarÄ±:**
- âœ… Unity Job System + Burst Compiler - CPU-intensive paralel iÅŸlemler (mesh building, flood-fill)
- âœ… CalculateDensityJob - CPU fallback density hesaplama (Burst ile optimize)
- âœ… BuildMeshJob - CPU fallback mesh building (Burst ile optimize)
- âœ… FloodFillJob - Territory flood-fill optimizasyonu (Job System + Burst)
- âœ… Thread-safe operations - Power System'de lock objects, NativeArray kullanÄ±mÄ±

**Genel Optimizasyonlar:**
- âœ… Object Pooling - VegetationSpawner'da aÄŸaÃ§/kaya pooling
- âœ… Async operations - Coroutines ve Tasks kullanÄ±mÄ±
- âœ… Memory management - Gereksiz allocation Ã¶nleme (NativeArray, Mesh Pooling)
- âœ… GPU/CPU Dengeleme - GPU varsa GPU, yoksa CPU kullan (otomatik fallback)

---

**Son GÃ¼ncelleme:** BugÃ¼n  
**Durum:** âœ… TÃœM FAZLAR TAMAMLANDI - Stratocraft Unity DÃ¶nÃ¼ÅŸÃ¼mÃ¼ HazÄ±r
